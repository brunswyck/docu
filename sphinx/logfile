Vim: Warning: Output is not to a terminal
chdir(/usr/share/vim)[?25l[J
fchdir() to previous dir[J
sourcing "$VIM/vimrc"[J
line 1: " All system-wide defaults are set in $VIMRUNTIME/debian.vim and sourced by[J

line 2: " the call to :runtime you can find below.  If you wish to change any of those[J

line 3: " settings, you should do it in this file (/etc/vim/vimrc), since debian.vim[J

line 4: " will be overwritten everytime an upgrade of the vim packages is performed.[J

line 5: " It is recommended to make changes after sourcing debian.vim since it alters[J

line 6: " the value of the 'compatible' option.[J

line 7: [J

line 8: " This line should not be removed as it ensures that various options are[J

line 9: " properly set to work with the Vim-related packages available in Debian.[J

line 10: runtime! debian.vim[J

Searching for "debian.vim" in "/home/patrick/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vimfiles/after,/home/patrick/.vim/after"[J
Searching for "/home/patrick/.vim/debian.vim"[J
Searching for "/usr/share/vim/vimfiles/debian.vim"[J
Searching for "/usr/share/vim/vim80/debian.vim"[J
chdir(/usr/share/vim/vim80)[J
fchdir() to previous dir[J
line 10: sourcing "/usr/share/vim/vim80/debian.vim"[J
line 1: " Debian system-wide default configuration Vim[J

line 2: [J

line 3: set runtimepath=~/.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,~/.vim/after[J

line 4: [J

line 5: " Normally we use vim-extensions. If you want true vi-compatibility[J

line 6: " remove change the following statements[J

line 7: set nocompatible^I" Use Vim defaults instead of 100% vi compatibility[J

line 8: set backspace=indent,eol,start^I" more powerful backspacing[J

line 9: [J

line 10: " Now we set some defaults for the editor[J

line 11: set history=50^I^I" keep 50 lines of command line history[J

line 12: set ruler^I^I" show the cursor position all the time[J

line 13: [J

line 14: " modelines have historically been a source of security/resource[J

line 15: " vulnerabilities -- disable by default, even when 'nocompatible' is set[J

line 16: set nomodeline[J

line 17: [J

line 18: " Suffixes that get lower priority when doing tab completion for filenames.[J

line 19: " These are files we are not likely to want to edit or read.[J

line 20: set suffixes=.bak,~,.swp,.o,.info,.aux,.log,.dvi,.bbl,.blg,.brf,.cb,.ind,.idx,.ilg,.inx,.out,.toc[J

line 21: [J

line 22: " We know xterm-debian is a color terminal[J

line 23: if &term =~ "xterm-debian" || &term =~ "xterm-xfree86"[J

line 24:   set t_Co=16[J

line 25:   set t_Sf=^[[3%dm[J

line 26:   set t_Sb=^[[4%dm[J

line 27: endif[J

line 28: [J

line 29: " Some Debian-specific things[J

line 30: if has("autocmd")[J

line 31:   if has('gui')[J

line 32:     " Make shift-insert work like in Xterm[J

line 33:     autocmd GUIEnter * if empty(maparg("<S-Insert>", "nvso")) | execute "map <S-Insert> <MiddleMouse>" | endif[J

line 34:     autocmd GUIEnter * if empty(maparg("<S-Insert>", "ic")) | execute "map! <S-Insert> <MiddleMouse>" | endif[J

line 35:   endif[J

line 36: endif[J

line 37: [J

line 38: " Set paper size from /etc/papersize if available (Debian-specific)[J

line 39: if filereadable("/etc/papersize")[J

line 40:   let s:papersize = matchstr(readfile('/etc/papersize', '', 1), '\p*')[J

line 41:   if strlen(s:papersize)[J

line 42:     exe "set printoptions+=paper:" . s:papersize[J

line 42: set printoptions+=paper:letter[J

line 43:   endif[J

line 44: endif[J

line 45: [J

finished sourcing /usr/share/vim/vim80/debian.vim[J
continuing in /usr/share/vim/vimrc[J
Searching for "/usr/share/vim/vimfiles/after/debian.vim"[J
Searching for "/home/patrick/.vim/after/debian.vim"[J
line 11: [J

line 12: " Vim will load $VIMRUNTIME/defaults.vim if the user does not have a vimrc.[J

line 13: " This happens after /etc/vim/vimrc(.local) are loaded, so it will override[J

line 14: " any settings in these files.[J

line 15: " If you don't want that to happen, uncomment the below line to prevent[J

line 16: " defaults.vim from being loaded.[J

line 17: " let g:skip_defaults_vim = 1[J

line 18: [J

line 19: " Uncomment the next line to make Vim more Vi-compatible[J

line 20: " NOTE: debian.vim sets 'nocompatible'.  Setting 'compatible' changes numerous[J

line 21: " options, so any other options should be set AFTER setting 'compatible'.[J

line 22: "set compatible[J

line 23: [J

line 24: " Vim5 and later versions support syntax highlighting. Uncommenting the next[J

line 25: " line enables syntax highlighting by default.[J

line 26: "syntax on[J

line 27: [J

line 28: " If using a dark background within the editing area and syntax highlighting[J

line 29: " turn on this option as well[J

line 30: "set background=dark[J

line 31: [J

line 32: " Uncomment the following to have Vim jump to the last position when[J

line 33: " reopening a file[J

line 34: "if has("autocmd")[J

line 35: "  au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif[J

line 36: "endif[J

line 37: [J

line 38: " Uncomment the following to have Vim load indentation rules and plugins[J

line 39: " according to the detected filetype.[J

line 40: "if has("autocmd")[J

line 41: "  filetype plugin indent on[J

line 42: "endif[J

line 43: [J

line 44: " The following are commented out as they cause vim to behave a lot[J

line 45: " differently from regular Vi. They are highly recommended though.[J

line 46: "set showcmd^I^I" Show (partial) command in status line.[J

line 47: "set showmatch^I^I" Show matching brackets.[J

line 48: "set ignorecase^I^I" Do case insensitive matching[J

line 49: "set smartcase^I^I" Do smart case matching[J

line 50: "set incsearch^I^I" Incremental search[J

line 51: "set autowrite^I^I" Automatically save before commands like :next and :make[J

line 52: "set hidden^I^I" Hide buffers when they are abandoned[J

line 53: "set mouse=a^I^I" Enable mouse usage (all modes)[J

line 54: [J

line 55: " Source a global configuration file if available[J

line 56: if filereadable("/etc/vim/vimrc.local")[J

line 57:   source /etc/vim/vimrc.local[J

line 58: endif[J

line 59: [J

finished sourcing $VIM/vimrc[J
chdir(/home/patrick)[J
fchdir() to previous dir[J
sourcing "$HOME/.vimrc"[J
line 1: " git clone https://github.com/VundleVim/Vundle.vim.git[J

line 2: " ~/.vim/bundle/Vundle.vim[J

line 3: " for more info check[J

line 4: " in vim do :PluginUpdate[J

line 5: " https://github.com/VundleVim/Vundle.vim[J

line 6: " to config on a new git clone[J

line 7: " git clone https://github.com/gmarik/Vundle.vim.git ~/.vim/bundle/Vundle.vim[J

line 8: " :echo &rtp[J

line 9: " set rtp+=/home/[YourUserName]/.vim/bundle/Vundle.vim[J

line 10: " ---------------------------------------[J

line 11: set nocompatible " turn off defaults required[J

line 12: filetype off     " turn off defaults required[J

Searching for "ftoff.vim" in "/home/patrick/.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after"[J
Searching for "/home/patrick/.vim/ftoff.vim"[J
Searching for "/var/lib/vim/addons/ftoff.vim"[J
Searching for "/usr/share/vim/vimfiles/ftoff.vim"[J
Searching for "/usr/share/vim/vim80/ftoff.vim"[J
chdir(/usr/share/vim/vim80)[J
fchdir() to previous dir[J
line 12: sourcing "/usr/share/vim/vim80/ftoff.vim"[J
line 1: " Vim support file to switch off detection of file types[J

line 2: "[J

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 4: " Last change:^I2001 Jun 11[J

line 5: [J

line 6: if exists("did_load_filetypes")[J

line 7:   unlet did_load_filetypes[J

line 8: endif[J

line 9: [J

line 10: " Remove all autocommands in the filetypedetect group[J

line 11: silent! au! filetypedetect *[J

finished sourcing /usr/share/vim/vim80/ftoff.vim[J
continuing in /home/patrick/.vimrc[J
Searching for "/usr/share/vim/vimfiles/after/ftoff.vim"[J
Searching for "/var/lib/vim/addons/after/ftoff.vim"[J
Searching for "/home/patrick/.vim/after/ftoff.vim"[J
line 13: " set runtime path to include vundle and initialize[J

line 14: set rtp+=~/.vim/bundle/Vundle.vim[J

line 15: " vundle begin[J

line 16: " -------------[J

line 17: call vundle#begin()[J

Searching for "autoload/vundle.vim" in "/home/patrick/.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim"[J
Searching for "/home/patrick/.vim/autoload/vundle.vim"[J
Searching for "/var/lib/vim/addons/autoload/vundle.vim"[J
Searching for "/usr/share/vim/vimfiles/autoload/vundle.vim"[J
Searching for "/usr/share/vim/vim80/autoload/vundle.vim"[J
Searching for "/usr/share/vim/vimfiles/after/autoload/vundle.vim"[J
Searching for "/var/lib/vim/addons/after/autoload/vundle.vim"[J
Searching for "/home/patrick/.vim/after/autoload/vundle.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/autoload/vundle.vim"[J
chdir(/home/patrick/.vim/bundle/Vundle.vim/autoload)[J
fchdir() to previous dir[J
line 17: sourcing "/home/patrick/.vim/bundle/Vundle.vim/autoload/vundle.vim"[J
line 1: " Vundle        is a shortcut for Vim Bundle and Is a simple plugin manager for Vim[J

line 2: " Author:       gmarik[J

line 3: " HomePage:     http://github.com/VundleVim/Vundle.vim[J

line 4: " Readme:       http://github.com/VundleVim/Vundle.vim/blob/master/README.md[J

line 5: " Version:      0.10.2[J

line 6: [J

line 7: " Plugin Commands[J

line 9: com! -nargs=+  -bar   Plugin call vundle#config#bundle(<args>)[J

line 10: [J

line 12: com! -nargs=* -bang -complete=custom,vundle#scripts#complete PluginInstall call vundle#installer#new('!' == '<bang>', <f-args>)[J

line 13: [J

line 15: com! -nargs=? -bang -complete=custom,vundle#scripts#complete PluginSearch call vundle#scripts#all('!' == '<bang>', <q-args>)[J

line 16: [J

line 18: com! -nargs=0 -bang PluginList call vundle#installer#list('!' == '<bang>')[J

line 19: [J

line 21: com! -nargs=? -bang   PluginClean call vundle#installer#clean('!' == '<bang>')[J

line 22: [J

line 24: com! -nargs=0         PluginDocs call vundle#installer#helptags(g:vundle#bundles)[J

line 25: [J

line 26: " Aliases[J

line 27: com! -nargs=* -complete=custom,vundle#scripts#complete PluginUpdate PluginInstall! <args>[J

line 28: [J

line 29: " Vundle Aliases[J

line 30: com! -nargs=? -bang -complete=custom,vundle#scripts#complete VundleInstall PluginInstall<bang> <args>[J

line 31: com! -nargs=? -bang -complete=custom,vundle#scripts#complete VundleSearch  PluginSearch<bang> <args>[J

line 32: com! -nargs=? -bang                                          VundleClean   PluginClean<bang>[J

line 33: com! -nargs=0                                                VundleDocs    PluginDocs[J

line 34: com!                                                         VundleUpdate  PluginInstall![J

line 35: com! -nargs=*       -complete=custom,vundle#scripts#complete VundleUpdate  PluginInstall! <args>[J

line 36: [J

line 37: " Deprecated Commands[J

line 38: com! -nargs=+                                                Bundle        call vundle#config#bundle(<args>)[J

line 39: com! -nargs=? -bang -complete=custom,vundle#scripts#complete BundleInstall PluginInstall<bang> <args>[J

line 40: com! -nargs=? -bang -complete=custom,vundle#scripts#complete BundleSearch  PluginSearch<bang> <args>[J

line 41: com! -nargs=0 -bang                                          BundleList    PluginList<bang>[J

line 42: com! -nargs=? -bang                                          BundleClean   PluginClean<bang>[J

line 43: com! -nargs=0                                                BundleDocs    PluginDocs[J

line 44: com!                                                         BundleUpdate  PluginInstall![J

line 45: [J

line 46: " Set up the signs used in the installer window. (See :help signs)[J

line 47: if (has('signs'))[J

line 48:   sign define Vu_error    text=!  texthl=Error[J

line 49:   sign define Vu_active   text=>  texthl=Comment[J

line 50:   sign define Vu_todate   text=.  texthl=Comment[J

line 51:   sign define Vu_new      text=+  texthl=Comment[J

line 52:   sign define Vu_updated  text=*  texthl=Comment[J

line 53:   sign define Vu_deleted  text=-  texthl=Comment[J

line 54:   sign define Vu_helptags text=*  texthl=Comment[J

line 55:   sign define Vu_pinned   text==  texthl=Comment[J

line 56: endif[J

line 57: [J

line 58: " Set up Vundle.  This function has to be called from the users vimrc file.[J

line 59: " This will force Vim to source this file as a side effect which wil define[J

line 60: " the :Plugin command.  After calling this function the user can use the[J

line 61: " :Plugin command in the vimrc.  It is not possible to do this automatically[J

line 62: " because when loading the vimrc file no plugins where loaded yet.[J

line 63: func! vundle#rc(...) abort[J

line 69: [J

line 70: " Alternative to vundle#rc, offers speed up by modifying rtp only when end()[J

line 71: " called later.[J

line 72: func! vundle#begin(...) abort[J

line 76: [J

line 77: " Finishes putting plugins on the rtp.[J

line 78: func! vundle#end(...) abort[J

line 82: [J

line 83: " Initialize some global variables used by Vundle.[J

line 84: let vundle#bundle_dir = expand('$HOME/.vim/bundle', 1)[J

line 85: let vundle#bundles = [][J

line 86: let vundle#lazy_load = 0[J

line 87: let vundle#log = [][J

line 88: let vundle#updated_bundles = [][J

line 89: [J

line 90: " vim: set expandtab sts=2 ts=2 sw=2 tw=78 norl:[J

finished sourcing /home/patrick/.vim/bundle/Vundle.vim/autoload/vundle.vim[J
continuing in /home/patrick/.vimrc[J
calling function vundle#begin[J()

line 1:   let g:vundle#lazy_load = 1[J

line 2:   call call('vundle#rc', a:000)[J

calling function vundle#begin[2]..vundle#rc[J()

line 1:   if a:0 > 0[J

line 2:     let g:vundle#bundle_dir = expand(a:1, 1)[J

line 3:   endif[J

line 4:   call vundle#config#init()[J

Searching for "autoload/vundle/config.vim" in "/home/patrick/.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim"[J
Searching for "/home/patrick/.vim/autoload/vundle/config.vim"[J
Searching for "/var/lib/vim/addons/autoload/vundle/config.vim"[J
Searching for "/usr/share/vim/vimfiles/autoload/vundle/config.vim"[J
Searching for "/usr/share/vim/vim80/autoload/vundle/config.vim"[J
Searching for "/usr/share/vim/vimfiles/after/autoload/vundle/config.vim"[J
Searching for "/var/lib/vim/addons/after/autoload/vundle/config.vim"[J
Searching for "/home/patrick/.vim/after/autoload/vundle/config.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/autoload/vundle/config.vim"[J
chdir(/home/patrick/.vim/bundle/Vundle.vim/autoload/vundle)[J
fchdir() to previous dir[J
line 4: sourcing "/home/patrick/.vim/bundle/Vundle.vim/autoload/vundle/config.vim"[J
line 1: " ---------------------------------------------------------------------------[J

line 2: " Add a plugin to the runtimepath.[J

line 3: "[J

line 4: " arg    -- a string specifying the plugin[J

line 5: " ...    -- a dictionary of options for the plugin[J

line 6: " return -- the return value from vundle#config#init_bundle()[J

line 7: " ---------------------------------------------------------------------------[J

line 8: func! vundle#config#bundle(arg, ...)[J

line 23: [J

line 24: [J

line 25: " ---------------------------------------------------------------------------[J

line 26: "  When lazy bundle load is used (begin/end functions), add all configured[J

line 27: "  bundles to runtimepath and reorder appropriately.[J

line 28: " ---------------------------------------------------------------------------[J

line 29: func! vundle#config#activate_bundles()[J

line 33: [J

line 34: [J

line 35: " ---------------------------------------------------------------------------[J

line 36: " Initialize Vundle.[J

line 37: "[J

line 38: " Start a new bundles list and make sure the runtimepath does not contain[J

line 39: " directories from a previous call. In theory, this should only be called[J

line 40: " once.[J

line 41: " ---------------------------------------------------------------------------[J

line 42: func! vundle#config#init()[J

line 48: [J

line 49: [J

line 50: " ---------------------------------------------------------------------------[J

line 51: " Add a list of bundles to the runtimepath and source them.[J

line 52: "[J

line 53: " bundles -- a list of bundle objects[J

line 54: " ---------------------------------------------------------------------------[J

line 55: func! vundle#config#require(bundles) abort[J

line 66: [J

line 67: [J

line 68: " ---------------------------------------------------------------------------[J

line 69: " Create a bundle object from a bundle specification.[J

line 70: "[J

line 71: " name   -- the bundle specification as a string[J

line 72: " opts   -- the options dictionary from then bundle definition[J

line 73: " return -- an initialized bundle object[J

line 74: " ---------------------------------------------------------------------------[J

line 75: func! vundle#config#init_bundle(name, opts)[J

line 84: [J

line 85: [J

line 86: " ---------------------------------------------------------------------------[J

line 87: " Check if the current bundle name has already been used in this running[J

line 88: " instance and show an error to that effect.[J

line 89: "[J

line 90: " bundle -- a bundle object whose name is to be checked[J

line 91: " return -- 0 if the bundle's name has been seen before, 1 otherwise[J

line 92: " ---------------------------------------------------------------------------[J

line 93: funct! s:check_bundle_name(bundle)[J

line 107: [J

line 108: [J

line 109: " ---------------------------------------------------------------------------[J

line 110: " Parse the options which can be supplied with the bundle specification.[J

line 111: " Corresponding documentation: vundle-plugins-configure[J

line 112: "[J

line 113: " opts   -- a dictionary with the user supplied options for the bundle[J

line 114: " return -- a dictionary with the user supplied options for the bundle, this[J

line 115: "           will be merged with a s:bundle object into one dictionary.[J

line 116: " ---------------------------------------------------------------------------[J

line 117: func! s:parse_options(opts)[J

line 127: [J

line 128: [J

line 129: " ---------------------------------------------------------------------------[J

line 130: " Parse the plugin specification.  Corresponding documentation:[J

line 131: " vundle-plugins-uris[J

line 132: "[J

line 133: " arg    -- the string supplied to identify the plugin[J

line 134: " return -- a dictionary with the folder name (key 'name') and the uri (key[J

line 135: "           'uri') for cloning the plugin  and the original argument (key[J

line 136: "           'name_spec')[J

line 137: " ---------------------------------------------------------------------------[J

line 138: func! s:parse_name(arg)[J

line 160: [J

line 161: [J

line 162: " ---------------------------------------------------------------------------[J

line 163: "  Modify the runtimepath, after all bundles have been added, so that the[J

line 164: "  directories that were in the default runtimepath appear first in the list[J

line 165: "  (with their 'after' directories last).[J

line 166: " ---------------------------------------------------------------------------[J

line 167: func! s:rtp_add_defaults()[J

line 179: [J

line 180: [J

line 181: " ---------------------------------------------------------------------------[J

line 182: " Remove all paths for the plugins which are managed by Vundle from the[J

line 183: " runtimepath.[J

line 184: " ---------------------------------------------------------------------------[J

line 185: func! s:rtp_rm_a()[J

line 192: [J

line 193: [J

line 194: " ---------------------------------------------------------------------------[J

line 195: " Add all paths for the plugins which are managed by Vundle to the[J

line 196: " runtimepath.[J

line 197: " ---------------------------------------------------------------------------[J

line 198: func! s:rtp_add_a()[J

line 205: [J

line 206: [J

line 207: " ---------------------------------------------------------------------------[J

line 208: " Remove a directory and the corresponding 'after' directory from runtimepath.[J

line 209: "[J

line 210: " dir    -- the directory name to be removed as a string.  The corresponding[J

line 211: "           'after' directory will also be removed.[J

line 212: " ---------------------------------------------------------------------------[J

line 213: func! s:rtp_rm(dir) abort[J

line 217: [J

line 218: [J

line 219: " ---------------------------------------------------------------------------[J

line 220: " Add a directory and the corresponding 'after' directory to runtimepath.[J

line 221: "[J

line 222: " dir    -- the directory name to be added as a string.  The corresponding[J

line 223: "           'after' directory will also be added.[J

line 224: " ---------------------------------------------------------------------------[J

line 225: func! s:rtp_add(dir) abort[J

line 229: [J

line 230: [J

line 231: " ---------------------------------------------------------------------------[J

line 232: " Expand and simplify a path.[J

line 233: "[J

line 234: " path   -- the path to expand as a string[J

line 235: " return -- the expanded and simplified path[J

line 236: " ---------------------------------------------------------------------------[J

line 237: func! s:expand_path(path) abort[J

line 240: [J

line 241: [J

line 242: " ---------------------------------------------------------------------------[J

line 243: " Find the actual path inside a bundle directory to be added to the[J

line 244: " runtimepath.  It might be provided by the user with the 'rtp' option.[J

line 245: " Corresponding documentation: vundle-plugins-configure[J

line 246: "[J

line 247: " opts   -- a bundle dict[J

line 248: " return -- expanded path to the corresponding plugin directory[J

line 249: " ---------------------------------------------------------------------------[J

line 250: func! s:rtpath(opts)[J

line 253: [J

line 254: [J

line 255: " ---------------------------------------------------------------------------[J

line 256: " a bundle 'object'[J

line 257: " ---------------------------------------------------------------------------[J

line 258: let s:bundle = {}[J

line 259: [J

line 260: [J

line 261: " ---------------------------------------------------------------------------[J

line 262: " Return the absolute path to the directory inside the bundle directory[J

line 263: " (prefix) where thr bundle will be cloned.[J

line 264: "[J

line 265: " return -- the target location to clone this bundle to[J

line 266: " ---------------------------------------------------------------------------[J

line 267: func! s:bundle.path()[J

line 270: [J

line 271: [J

line 272: " ---------------------------------------------------------------------------[J

line 273: "  Determine if the bundle has the pinned attribute set in the config[J

line 274: "[J

line 275: "  return -- 1 if the bundle is pinned, 0 otherwise[J

line 276: " ---------------------------------------------------------------------------[J

line 277: func! s:bundle.is_pinned()[J

line 280: [J

line 281: " vim: set expandtab sts=2 ts=2 sw=2 tw=78 norl:[J

finished sourcing /home/patrick/.vim/bundle/Vundle.vim/autoload/vundle/config.vim[J
continuing in function vundle#begin[2]..vundle#rc[J
calling function vundle#begin[2]..vundle#rc[4]..vundle#config#init[J()

line 1:   if !exists('g:vundle#bundles') | let g:vundle#bundles = [] | endif[J

line 1:  let g:vundle#bundles = [] | endif[J

line 1:  endif[J

line 2:   call s:rtp_rm_a()[J

calling function vundle#begin[2]..vundle#rc[4]..vundle#config#init[2]..<SNR>6_rtp_rm_a[J()

line 1:   let paths = map(copy(g:vundle#bundles), 'v:val.rtpath')[J

line 2:   let prepends = join(paths, ',')[J

line 3:   let appends = join(paths, '/after,').'/after'[J

line 4:   exec 'set rtp-='.fnameescape(prepends)[J

line 4: set rtp-=[J

line 5:   exec 'set rtp-='.fnameescape(appends)[J

line 5: set rtp-=/after[J

function vundle#begin[2]..vundle#rc[4]..vundle#config#init[2]..<SNR>6_rtp_rm_a returning #0[J

continuing in function vundle#begin[2]..vundle#rc[4]..vundle#config#init[J

line 3:   let g:vundle#bundles = [][J

line 4:   let s:bundle_names = {}[J

function vundle#begin[2]..vundle#rc[4]..vundle#config#init returning #0[J

continuing in function vundle#begin[2]..vundle#rc[J

function vundle#begin[2]..vundle#rc returning #0[J

continuing in function vundle#begin[J

function vundle#begin returning #0[J

continuing in /home/patrick/.vimrc[J

line 18: [J

line 19: " let Vundle manage Vundle, required[J

line 20: Plugin 'VundleVim/Vundle.vim'[J

line 20: call vundle#config#bundle('VundleVim/Vundle.vim')[J

calling function vundle#config#bundle[J('VundleVim/Vundle.vim')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[J('VundleVim/Vundle.vim', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')[J

line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"[J

line 3:   endif[J

line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_options[J([])

line 1:   " TODO: improve this[J

line 2:   if len(a:opts) != 1 | return {} | endif[J

line 2:  return {} | endif[J

function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_options returning {}[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_name[J('VundleVim/Vundle.vim')

line 1:   let arg = a:arg[J

line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'[J

line 3: [J

line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'[J

line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1][J

line 7:     if uri !~? '\.git$'[J

line 8:       let uri .= '.git'[J

line 9:     endif[J

line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')[J

line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'[J

line 14:     let uri = arg[J

line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1][J

line 16:   else[J

line 17:     let name = arg[J

line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'[J

line 19:   endif[J

line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }[J

function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_name returning {'uri': 'https://github.com/VundleVim/...', 'name_spec': 'VundleVim/Vundle.vim'}[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[J

line 5:   let b = extend(opts, copy(s:bundle))[J

line 6:   let b.rtpath = s:rtpath(opts)[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[J({'uri': 'https://github.com/VundleVim/...Vim/Vundle.vim', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[J()

line 1:   return s:expand_path(g:vundle#bundle_dir.'/') . self.name[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[1]..<SNR>6_expand_path[J('/home/patrick/.vim/bundle/')

line 1:   return simplify(expand(a:path, 1))[J

function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[1]..<SNR>6_expand_path returning '/home/patrick/.vim/bundle/'[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[J

function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1 returning '/home/patrick/.vim/bundle/Vundle.vim'[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[J

function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath returning '/home/patrick/.vim/bundle/Vundle.vim'[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[J

line 7:   return b[J

function vundle#config#bundle[1]..vundle#config#init_bundle returning {'uri': 'https://github.com/VundleVim/...Vim/Vundle.vim', 'path': function('1')}[J

continuing in function vundle#config#bundle[J

line 2:   if !s:check_bundle_name(bundle)[J

calling function vundle#config#bundle[2]..<SNR>6_check_bundle_name[J({'uri': 'https://github.com/VundleVim/...Vim/Vundle.vim', 'path': function('1')})

line 1:   if has_key(s:bundle_names, a:bundle.name)[J

line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . s:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'[J

line 6:     return 0[J

line 7:   elseif a:bundle.name !~ '\v^[A-Za-z0-9_-]%(\.?[A-Za-z0-9_-])*$'[J

line 8:     echoerr 'Invalid plugin name: ' . a:bundle.name[J

line 9:     return 0[J

line 10:   endif[J

line 11:   let s:bundle_names[a:bundle.name] = a:bundle.name_spec[J

line 12:   return 1[J

function vundle#config#bundle[2]..<SNR>6_check_bundle_name returning #1[J

continuing in function vundle#config#bundle[J

line 3:     return[J

line 4:   endif[J

line 5:   if exists('g:vundle#lazy_load') && g:vundle#lazy_load[J

line 6:     call add(g:vundle#bundles, bundle)[J

line 7:   else[J

line 8:     call s:rtp_rm_a()[J

line 9:     call add(g:vundle#bundles, bundle)[J

line 10:     call s:rtp_add_a()[J

line 11:     call s:rtp_add_defaults()[J

line 12:   endif[J

line 13:   return bundle[J

function vundle#config#bundle returning {'uri': 'https://github.com/VundleVim/...Vim/Vundle.vim', 'path': function('1')}[J

continuing in /home/patrick/.vimrc[J

line 21: [J

line 22: " https://github.com/tpope/vim-sensible[J

line 23: " sensible defaults[J

line 24: "[J

line 25: Plugin 'tpope/vim-sensible'[J

line 25: call vundle#config#bundle('tpope/vim-sensible')[J

calling function vundle#config#bundle[J('tpope/vim-sensible')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[J('tpope/vim-sensible', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')[J

line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"[J

line 3:   endif[J

line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_options[J([])

line 1:   " TODO: improve this[J

line 2:   if len(a:opts) != 1 | return {} | endif[J

line 2:  return {} | endif[J

function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_options returning {}[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_name[J('tpope/vim-sensible')

line 1:   let arg = a:arg[J

line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'[J

line 3: [J

line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'[J

line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1][J

line 7:     if uri !~? '\.git$'[J

line 8:       let uri .= '.git'[J

line 9:     endif[J

line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')[J

line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'[J

line 14:     let uri = arg[J

line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1][J

line 16:   else[J

line 17:     let name = arg[J

line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'[J

line 19:   endif[J

line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }[J

function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_name returning {'uri': 'https://github.com/tpope/vim-...le', 'name_spec': 'tpope/vim-sensible'}[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[J

line 5:   let b = extend(opts, copy(s:bundle))[J

line 6:   let b.rtpath = s:rtpath(opts)[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[J({'uri': 'https://github.com/tpope/vim-...e/vim-sensible', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[J()

line 1:   return s:expand_path(g:vundle#bundle_dir.'/') . self.name[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[1]..<SNR>6_expand_path[J('/home/patrick/.vim/bundle/')

line 1:   return simplify(expand(a:path, 1))[J

function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[1]..<SNR>6_expand_path returning '/home/patrick/.vim/bundle/'[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[J

function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1 returning '/home/patrick/.vim/bundle/vim-sensible'[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[J

function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath returning '/home/patrick/.vim/bundle/vim-sensible'[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[J

line 7:   return b[J

function vundle#config#bundle[1]..vundle#config#init_bundle returning {'uri': 'https://github.com/tpope/vim-...e/vim-sensible', 'path': function('1')}[J

continuing in function vundle#config#bundle[J

line 2:   if !s:check_bundle_name(bundle)[J

calling function vundle#config#bundle[2]..<SNR>6_check_bundle_name[J({'uri': 'https://github.com/tpope/vim-...e/vim-sensible', 'path': function('1')})

line 1:   if has_key(s:bundle_names, a:bundle.name)[J

line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . s:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'[J

line 6:     return 0[J

line 7:   elseif a:bundle.name !~ '\v^[A-Za-z0-9_-]%(\.?[A-Za-z0-9_-])*$'[J

line 8:     echoerr 'Invalid plugin name: ' . a:bundle.name[J

line 9:     return 0[J

line 10:   endif[J

line 11:   let s:bundle_names[a:bundle.name] = a:bundle.name_spec[J

line 12:   return 1[J

function vundle#config#bundle[2]..<SNR>6_check_bundle_name returning #1[J

continuing in function vundle#config#bundle[J

line 3:     return[J

line 4:   endif[J

line 5:   if exists('g:vundle#lazy_load') && g:vundle#lazy_load[J

line 6:     call add(g:vundle#bundles, bundle)[J

line 7:   else[J

line 8:     call s:rtp_rm_a()[J

line 9:     call add(g:vundle#bundles, bundle)[J

line 10:     call s:rtp_add_a()[J

line 11:     call s:rtp_add_defaults()[J

line 12:   endif[J

line 13:   return bundle[J

function vundle#config#bundle returning {'uri': 'https://github.com/tpope/vim-...e/vim-sensible', 'path': function('1')}[J

continuing in /home/patrick/.vimrc[J

line 26: [J

line 27: " NERDTree file explorer + git plugin[J

line 28: " https://github.com/scrooloose/nerdtree[J

line 29: " https://github.com/Xuyuanp/nerdtree-git-plugin[J

line 30: [J

line 31: " Molokai-dark color scheme for Vim https://github.com/pR0Ps/molokai-dark[J

line 32: Plugin 'pR0Ps/molokai-dark'[J

line 32: call vundle#config#bundle('pR0Ps/molokai-dark')[J

calling function vundle#config#bundle[J('pR0Ps/molokai-dark')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[J('pR0Ps/molokai-dark', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')[J

line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"[J

line 3:   endif[J

line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_options[J([])

line 1:   " TODO: improve this[J

line 2:   if len(a:opts) != 1 | return {} | endif[J

line 2:  return {} | endif[J

function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_options returning {}[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_name[J('pR0Ps/molokai-dark')

line 1:   let arg = a:arg[J

line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'[J

line 3: [J

line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'[J

line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1][J

line 7:     if uri !~? '\.git$'[J

line 8:       let uri .= '.git'[J

line 9:     endif[J

line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')[J

line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'[J

line 14:     let uri = arg[J

line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1][J

line 16:   else[J

line 17:     let name = arg[J

line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'[J

line 19:   endif[J

line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }[J

function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_name returning {'uri': 'https://github.com/pR0Ps/molo...rk', 'name_spec': 'pR0Ps/molokai-dark'}[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[J

line 5:   let b = extend(opts, copy(s:bundle))[J

line 6:   let b.rtpath = s:rtpath(opts)[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[J({'uri': 'https://github.com/pR0Ps/molo...s/molokai-dark', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[J()

line 1:   return s:expand_path(g:vundle#bundle_dir.'/') . self.name[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[1]..<SNR>6_expand_path[J('/home/patrick/.vim/bundle/')

line 1:   return simplify(expand(a:path, 1))[J

function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[1]..<SNR>6_expand_path returning '/home/patrick/.vim/bundle/'[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[J

function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1 returning '/home/patrick/.vim/bundle/molokai-dark'[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[J

function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath returning '/home/patrick/.vim/bundle/molokai-dark'[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[J

line 7:   return b[J

function vundle#config#bundle[1]..vundle#config#init_bundle returning {'uri': 'https://github.com/pR0Ps/molo...s/molokai-dark', 'path': function('1')}[J

continuing in function vundle#config#bundle[J

line 2:   if !s:check_bundle_name(bundle)[J

calling function vundle#config#bundle[2]..<SNR>6_check_bundle_name[J({'uri': 'https://github.com/pR0Ps/molo...s/molokai-dark', 'path': function('1')})

line 1:   if has_key(s:bundle_names, a:bundle.name)[J

line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . s:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'[J

line 6:     return 0[J

line 7:   elseif a:bundle.name !~ '\v^[A-Za-z0-9_-]%(\.?[A-Za-z0-9_-])*$'[J

line 8:     echoerr 'Invalid plugin name: ' . a:bundle.name[J

line 9:     return 0[J

line 10:   endif[J

line 11:   let s:bundle_names[a:bundle.name] = a:bundle.name_spec[J

line 12:   return 1[J

function vundle#config#bundle[2]..<SNR>6_check_bundle_name returning #1[J

continuing in function vundle#config#bundle[J

line 3:     return[J

line 4:   endif[J

line 5:   if exists('g:vundle#lazy_load') && g:vundle#lazy_load[J

line 6:     call add(g:vundle#bundles, bundle)[J

line 7:   else[J

line 8:     call s:rtp_rm_a()[J

line 9:     call add(g:vundle#bundles, bundle)[J

line 10:     call s:rtp_add_a()[J

line 11:     call s:rtp_add_defaults()[J

line 12:   endif[J

line 13:   return bundle[J

function vundle#config#bundle returning {'uri': 'https://github.com/pR0Ps/molo...s/molokai-dark', 'path': function('1')}[J

continuing in /home/patrick/.vimrc[J

line 33: [J

line 34: Plugin 'scrooloose/nerdtree'[J

line 34: call vundle#config#bundle('scrooloose/nerdtree')[J

calling function vundle#config#bundle[J('scrooloose/nerdtree')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[J('scrooloose/nerdtree', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')[J

line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"[J

line 3:   endif[J

line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_options[J([])

line 1:   " TODO: improve this[J

line 2:   if len(a:opts) != 1 | return {} | endif[J

line 2:  return {} | endif[J

function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_options returning {}[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_name[J('scrooloose/nerdtree')

line 1:   let arg = a:arg[J

line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'[J

line 3: [J

line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'[J

line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1][J

line 7:     if uri !~? '\.git$'[J

line 8:       let uri .= '.git'[J

line 9:     endif[J

line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')[J

line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'[J

line 14:     let uri = arg[J

line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1][J

line 16:   else[J

line 17:     let name = arg[J

line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'[J

line 19:   endif[J

line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }[J

function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_name returning {'uri': 'https://github.com/scrooloose...e', 'name_spec': 'scrooloose/nerdtree'}[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[J

line 5:   let b = extend(opts, copy(s:bundle))[J

line 6:   let b.rtpath = s:rtpath(opts)[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[J({'uri': 'https://github.com/scrooloose...loose/nerdtree', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[J()

line 1:   return s:expand_path(g:vundle#bundle_dir.'/') . self.name[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[1]..<SNR>6_expand_path[J('/home/patrick/.vim/bundle/')

line 1:   return simplify(expand(a:path, 1))[J

function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[1]..<SNR>6_expand_path returning '/home/patrick/.vim/bundle/'[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[J

function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1 returning '/home/patrick/.vim/bundle/nerdtree'[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[J

function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath returning '/home/patrick/.vim/bundle/nerdtree'[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[J

line 7:   return b[J

function vundle#config#bundle[1]..vundle#config#init_bundle returning {'uri': 'https://github.com/scrooloose...loose/nerdtree', 'path': function('1')}[J

continuing in function vundle#config#bundle[J

line 2:   if !s:check_bundle_name(bundle)[J

calling function vundle#config#bundle[2]..<SNR>6_check_bundle_name[J({'uri': 'https://github.com/scrooloose...loose/nerdtree', 'path': function('1')})

line 1:   if has_key(s:bundle_names, a:bundle.name)[J

line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . s:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'[J

line 6:     return 0[J

line 7:   elseif a:bundle.name !~ '\v^[A-Za-z0-9_-]%(\.?[A-Za-z0-9_-])*$'[J

line 8:     echoerr 'Invalid plugin name: ' . a:bundle.name[J

line 9:     return 0[J

line 10:   endif[J

line 11:   let s:bundle_names[a:bundle.name] = a:bundle.name_spec[J

line 12:   return 1[J

function vundle#config#bundle[2]..<SNR>6_check_bundle_name returning #1[J

continuing in function vundle#config#bundle[J

line 3:     return[J

line 4:   endif[J

line 5:   if exists('g:vundle#lazy_load') && g:vundle#lazy_load[J

line 6:     call add(g:vundle#bundles, bundle)[J

line 7:   else[J

line 8:     call s:rtp_rm_a()[J

line 9:     call add(g:vundle#bundles, bundle)[J

line 10:     call s:rtp_add_a()[J

line 11:     call s:rtp_add_defaults()[J

line 12:   endif[J

line 13:   return bundle[J

function vundle#config#bundle returning {'uri': 'https://github.com/scrooloose...loose/nerdtree', 'path': function('1')}[J

continuing in /home/patrick/.vimrc[J

line 35: " Crtl+ww cycle though all windows[J

line 36: " Crtl+wh takes you left a window[J

line 37: " Crtl+wj takes you down a window[J

line 38: " Crtl+wk takes you up a window[J

line 39: " Crtl+wl takes you right a window[J

line 40: " t open new tab[J

line 41: " T open new tab while staying in current tab[J

line 42: " gt cycle though all tabs[J

line 43: " gT cycle though all tabs (moves to the left)[J

line 44: "  [J

line 45: Plugin 'Xuyuanp/nerdtree-git-plugin'[J

line 45: call vundle#config#bundle('Xuyuanp/nerdtree-git-plugin')[J

calling function vundle#config#bundle[J('Xuyuanp/nerdtree-git-plugin')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[J('Xuyuanp/nerdtree-git-plugin', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')[J

line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"[J

line 3:   endif[J

line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_options[J([])

line 1:   " TODO: improve this[J

line 2:   if len(a:opts) != 1 | return {} | endif[J

line 2:  return {} | endif[J

function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_options returning {}[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_name[J('Xuyuanp/nerdtree-git-plugin')

line 1:   let arg = a:arg[J

line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'[J

line 3: [J

line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'[J

line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1][J

line 7:     if uri !~? '\.git$'[J

line 8:       let uri .= '.git'[J

line 9:     endif[J

line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')[J

line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'[J

line 14:     let uri = arg[J

line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1][J

line 16:   else[J

line 17:     let name = arg[J

line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'[J

line 19:   endif[J

line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }[J

function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_name returning {'uri': 'https://github.com/Xuyuanp/ne...e_spec': 'Xuyuanp/nerdtree-git-plugin'}[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[J

line 5:   let b = extend(opts, copy(s:bundle))[J

line 6:   let b.rtpath = s:rtpath(opts)[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[J({'uri': 'https://github.com/Xuyuanp/ne...ree-git-plugin', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[J()

line 1:   return s:expand_path(g:vundle#bundle_dir.'/') . self.name[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[1]..<SNR>6_expand_path[J('/home/patrick/.vim/bundle/')

line 1:   return simplify(expand(a:path, 1))[J

function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[1]..<SNR>6_expand_path returning '/home/patrick/.vim/bundle/'[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[J

function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1 returning '/home/patrick/.vim/bundle/nerdtree-git-plugin'[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[J

function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath returning '/home/patrick/.vim/bundle/nerdtree-git-plugin'[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[J

line 7:   return b[J

function vundle#config#bundle[1]..vundle#config#init_bundle returning {'uri': 'https://github.com/Xuyuanp/ne...ree-git-plugin', 'path': function('1')}[J

continuing in function vundle#config#bundle[J

line 2:   if !s:check_bundle_name(bundle)[J

calling function vundle#config#bundle[2]..<SNR>6_check_bundle_name[J({'uri': 'https://github.com/Xuyuanp/ne...ree-git-plugin', 'path': function('1')})

line 1:   if has_key(s:bundle_names, a:bundle.name)[J

line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . s:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'[J

line 6:     return 0[J

line 7:   elseif a:bundle.name !~ '\v^[A-Za-z0-9_-]%(\.?[A-Za-z0-9_-])*$'[J

line 8:     echoerr 'Invalid plugin name: ' . a:bundle.name[J

line 9:     return 0[J

line 10:   endif[J

line 11:   let s:bundle_names[a:bundle.name] = a:bundle.name_spec[J

line 12:   return 1[J

function vundle#config#bundle[2]..<SNR>6_check_bundle_name returning #1[J

continuing in function vundle#config#bundle[J

line 3:     return[J

line 4:   endif[J

line 5:   if exists('g:vundle#lazy_load') && g:vundle#lazy_load[J

line 6:     call add(g:vundle#bundles, bundle)[J

line 7:   else[J

line 8:     call s:rtp_rm_a()[J

line 9:     call add(g:vundle#bundles, bundle)[J

line 10:     call s:rtp_add_a()[J

line 11:     call s:rtp_add_defaults()[J

line 12:   endif[J

line 13:   return bundle[J

function vundle#config#bundle returning {'uri': 'https://github.com/Xuyuanp/ne...ree-git-plugin', 'path': function('1')}[J

continuing in /home/patrick/.vimrc[J

line 46: " NERD Commenter[J

line 47: " for more info type :help nerdcommenter[J

line 48: [J

line 49: Plugin 'scrooloose/nerdcommenter'[J

line 49: call vundle#config#bundle('scrooloose/nerdcommenter')[J

calling function vundle#config#bundle[J('scrooloose/nerdcommenter')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[J('scrooloose/nerdcommenter', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')[J

line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"[J

line 3:   endif[J

line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_options[J([])

line 1:   " TODO: improve this[J

line 2:   if len(a:opts) != 1 | return {} | endif[J

line 2:  return {} | endif[J

function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_options returning {}[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_name[J('scrooloose/nerdcommenter')

line 1:   let arg = a:arg[J

line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'[J

line 3: [J

line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'[J

line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1][J

line 7:     if uri !~? '\.git$'[J

line 8:       let uri .= '.git'[J

line 9:     endif[J

line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')[J

line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'[J

line 14:     let uri = arg[J

line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1][J

line 16:   else[J

line 17:     let name = arg[J

line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'[J

line 19:   endif[J

line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }[J

function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_name returning {'uri': 'https://github.com/scrooloose...name_spec': 'scrooloose/nerdcommenter'}[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[J

line 5:   let b = extend(opts, copy(s:bundle))[J

line 6:   let b.rtpath = s:rtpath(opts)[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[J({'uri': 'https://github.com/scrooloose.../nerdcommenter', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[J()

line 1:   return s:expand_path(g:vundle#bundle_dir.'/') . self.name[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[1]..<SNR>6_expand_path[J('/home/patrick/.vim/bundle/')

line 1:   return simplify(expand(a:path, 1))[J

function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[1]..<SNR>6_expand_path returning '/home/patrick/.vim/bundle/'[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[J

function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1 returning '/home/patrick/.vim/bundle/nerdcommenter'[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[J

function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath returning '/home/patrick/.vim/bundle/nerdcommenter'[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[J

line 7:   return b[J

function vundle#config#bundle[1]..vundle#config#init_bundle returning {'uri': 'https://github.com/scrooloose.../nerdcommenter', 'path': function('1')}[J

continuing in function vundle#config#bundle[J

line 2:   if !s:check_bundle_name(bundle)[J

calling function vundle#config#bundle[2]..<SNR>6_check_bundle_name[J({'uri': 'https://github.com/scrooloose.../nerdcommenter', 'path': function('1')})

line 1:   if has_key(s:bundle_names, a:bundle.name)[J

line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . s:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'[J

line 6:     return 0[J

line 7:   elseif a:bundle.name !~ '\v^[A-Za-z0-9_-]%(\.?[A-Za-z0-9_-])*$'[J

line 8:     echoerr 'Invalid plugin name: ' . a:bundle.name[J

line 9:     return 0[J

line 10:   endif[J

line 11:   let s:bundle_names[a:bundle.name] = a:bundle.name_spec[J

line 12:   return 1[J

function vundle#config#bundle[2]..<SNR>6_check_bundle_name returning #1[J

continuing in function vundle#config#bundle[J

line 3:     return[J

line 4:   endif[J

line 5:   if exists('g:vundle#lazy_load') && g:vundle#lazy_load[J

line 6:     call add(g:vundle#bundles, bundle)[J

line 7:   else[J

line 8:     call s:rtp_rm_a()[J

line 9:     call add(g:vundle#bundles, bundle)[J

line 10:     call s:rtp_add_a()[J

line 11:     call s:rtp_add_defaults()[J

line 12:   endif[J

line 13:   return bundle[J

function vundle#config#bundle returning {'uri': 'https://github.com/scrooloose.../nerdcommenter', 'path': function('1')}[J

continuing in /home/patrick/.vimrc[J

line 50: [J

line 51: " quick git commands in vim[J

line 52: " https://github.com/tpope/vim-fugitive[J

line 53: [J

line 54: Plugin 'tpope/vim-fugitive'[J

line 54: call vundle#config#bundle('tpope/vim-fugitive')[J

calling function vundle#config#bundle[J('tpope/vim-fugitive')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[J('tpope/vim-fugitive', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')[J

line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"[J

line 3:   endif[J

line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_options[J([])

line 1:   " TODO: improve this[J

line 2:   if len(a:opts) != 1 | return {} | endif[J

line 2:  return {} | endif[J

function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_options returning {}[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_name[J('tpope/vim-fugitive')

line 1:   let arg = a:arg[J

line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'[J

line 3: [J

line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'[J

line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1][J

line 7:     if uri !~? '\.git$'[J

line 8:       let uri .= '.git'[J

line 9:     endif[J

line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')[J

line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'[J

line 14:     let uri = arg[J

line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1][J

line 16:   else[J

line 17:     let name = arg[J

line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'[J

line 19:   endif[J

line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }[J

function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_name returning {'uri': 'https://github.com/tpope/vim-...ve', 'name_spec': 'tpope/vim-fugitive'}[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[J

line 5:   let b = extend(opts, copy(s:bundle))[J

line 6:   let b.rtpath = s:rtpath(opts)[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[J({'uri': 'https://github.com/tpope/vim-...e/vim-fugitive', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[J()

line 1:   return s:expand_path(g:vundle#bundle_dir.'/') . self.name[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[1]..<SNR>6_expand_path[J('/home/patrick/.vim/bundle/')

line 1:   return simplify(expand(a:path, 1))[J

function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[1]..<SNR>6_expand_path returning '/home/patrick/.vim/bundle/'[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[J

function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1 returning '/home/patrick/.vim/bundle/vim-fugitive'[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[J

function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath returning '/home/patrick/.vim/bundle/vim-fugitive'[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[J

line 7:   return b[J

function vundle#config#bundle[1]..vundle#config#init_bundle returning {'uri': 'https://github.com/tpope/vim-...e/vim-fugitive', 'path': function('1')}[J

continuing in function vundle#config#bundle[J

line 2:   if !s:check_bundle_name(bundle)[J

calling function vundle#config#bundle[2]..<SNR>6_check_bundle_name[J({'uri': 'https://github.com/tpope/vim-...e/vim-fugitive', 'path': function('1')})

line 1:   if has_key(s:bundle_names, a:bundle.name)[J

line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . s:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'[J

line 6:     return 0[J

line 7:   elseif a:bundle.name !~ '\v^[A-Za-z0-9_-]%(\.?[A-Za-z0-9_-])*$'[J

line 8:     echoerr 'Invalid plugin name: ' . a:bundle.name[J

line 9:     return 0[J

line 10:   endif[J

line 11:   let s:bundle_names[a:bundle.name] = a:bundle.name_spec[J

line 12:   return 1[J

function vundle#config#bundle[2]..<SNR>6_check_bundle_name returning #1[J

continuing in function vundle#config#bundle[J

line 3:     return[J

line 4:   endif[J

line 5:   if exists('g:vundle#lazy_load') && g:vundle#lazy_load[J

line 6:     call add(g:vundle#bundles, bundle)[J

line 7:   else[J

line 8:     call s:rtp_rm_a()[J

line 9:     call add(g:vundle#bundles, bundle)[J

line 10:     call s:rtp_add_a()[J

line 11:     call s:rtp_add_defaults()[J

line 12:   endif[J

line 13:   return bundle[J

function vundle#config#bundle returning {'uri': 'https://github.com/tpope/vim-...e/vim-fugitive', 'path': function('1')}[J

continuing in /home/patrick/.vimrc[J

line 55: [J

line 56: " syntax checker for vim 8 and up[J

line 57: " Asynchronous Lint Engine[J

line 58: Plugin 'w0rp/ale'[J

line 58: call vundle#config#bundle('w0rp/ale')[J

calling function vundle#config#bundle[J('w0rp/ale')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[J('w0rp/ale', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')[J

line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"[J

line 3:   endif[J

line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_options[J([])

line 1:   " TODO: improve this[J

line 2:   if len(a:opts) != 1 | return {} | endif[J

line 2:  return {} | endif[J

function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_options returning {}[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_name[J('w0rp/ale')

line 1:   let arg = a:arg[J

line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'[J

line 3: [J

line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'[J

line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1][J

line 7:     if uri !~? '\.git$'[J

line 8:       let uri .= '.git'[J

line 9:     endif[J

line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')[J

line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'[J

line 14:     let uri = arg[J

line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1][J

line 16:   else[J

line 17:     let name = arg[J

line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'[J

line 19:   endif[J

line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }[J

function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_name returning {'uri': 'https://github.com/w0rp/ale.g...'name': 'ale', 'name_spec': 'w0rp/ale'}[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[J

line 5:   let b = extend(opts, copy(s:bundle))[J

line 6:   let b.rtpath = s:rtpath(opts)[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[J({'uri': 'https://github.com/w0rp/ale.g...ec': 'w0rp/ale', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[J()

line 1:   return s:expand_path(g:vundle#bundle_dir.'/') . self.name[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[1]..<SNR>6_expand_path[J('/home/patrick/.vim/bundle/')

line 1:   return simplify(expand(a:path, 1))[J

function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[1]..<SNR>6_expand_path returning '/home/patrick/.vim/bundle/'[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[J

function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1 returning '/home/patrick/.vim/bundle/ale'[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[J

function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath returning '/home/patrick/.vim/bundle/ale'[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[J

line 7:   return b[J

function vundle#config#bundle[1]..vundle#config#init_bundle returning {'uri': 'https://github.com/w0rp/ale.g...ec': 'w0rp/ale', 'path': function('1')}[J

continuing in function vundle#config#bundle[J

line 2:   if !s:check_bundle_name(bundle)[J

calling function vundle#config#bundle[2]..<SNR>6_check_bundle_name[J({'uri': 'https://github.com/w0rp/ale.g...ec': 'w0rp/ale', 'path': function('1')})

line 1:   if has_key(s:bundle_names, a:bundle.name)[J

line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . s:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'[J

line 6:     return 0[J

line 7:   elseif a:bundle.name !~ '\v^[A-Za-z0-9_-]%(\.?[A-Za-z0-9_-])*$'[J

line 8:     echoerr 'Invalid plugin name: ' . a:bundle.name[J

line 9:     return 0[J

line 10:   endif[J

line 11:   let s:bundle_names[a:bundle.name] = a:bundle.name_spec[J

line 12:   return 1[J

function vundle#config#bundle[2]..<SNR>6_check_bundle_name returning #1[J

continuing in function vundle#config#bundle[J

line 3:     return[J

line 4:   endif[J

line 5:   if exists('g:vundle#lazy_load') && g:vundle#lazy_load[J

line 6:     call add(g:vundle#bundles, bundle)[J

line 7:   else[J

line 8:     call s:rtp_rm_a()[J

line 9:     call add(g:vundle#bundles, bundle)[J

line 10:     call s:rtp_add_a()[J

line 11:     call s:rtp_add_defaults()[J

line 12:   endif[J

line 13:   return bundle[J

function vundle#config#bundle returning {'uri': 'https://github.com/w0rp/ale.g...ec': 'w0rp/ale', 'path': function('1')}[J

continuing in /home/patrick/.vimrc[J

line 59: [J

line 60: " http://vimcasts.org/episodes/aligning-text-with-tabular-vim/[J

line 61: Plugin 'godlygeek/tabular'[J

line 61: call vundle#config#bundle('godlygeek/tabular')[J

calling function vundle#config#bundle[J('godlygeek/tabular')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[J('godlygeek/tabular', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')[J

line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"[J

line 3:   endif[J

line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_options[J([])

line 1:   " TODO: improve this[J

line 2:   if len(a:opts) != 1 | return {} | endif[J

line 2:  return {} | endif[J

function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_options returning {}[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_name[J('godlygeek/tabular')

line 1:   let arg = a:arg[J

line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'[J

line 3: [J

line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'[J

line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1][J

line 7:     if uri !~? '\.git$'[J

line 8:       let uri .= '.git'[J

line 9:     endif[J

line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')[J

line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'[J

line 14:     let uri = arg[J

line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1][J

line 16:   else[J

line 17:     let name = arg[J

line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'[J

line 19:   endif[J

line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }[J

function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_name returning {'uri': 'https://github.com/godlygeek/...lar', 'name_spec': 'godlygeek/tabular'}[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[J

line 5:   let b = extend(opts, copy(s:bundle))[J

line 6:   let b.rtpath = s:rtpath(opts)[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[J({'uri': 'https://github.com/godlygeek/...lygeek/tabular', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[J()

line 1:   return s:expand_path(g:vundle#bundle_dir.'/') . self.name[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[1]..<SNR>6_expand_path[J('/home/patrick/.vim/bundle/')

line 1:   return simplify(expand(a:path, 1))[J

function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[1]..<SNR>6_expand_path returning '/home/patrick/.vim/bundle/'[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[J

function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1 returning '/home/patrick/.vim/bundle/tabular'[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[J

function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath returning '/home/patrick/.vim/bundle/tabular'[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[J

line 7:   return b[J

function vundle#config#bundle[1]..vundle#config#init_bundle returning {'uri': 'https://github.com/godlygeek/...lygeek/tabular', 'path': function('1')}[J

continuing in function vundle#config#bundle[J

line 2:   if !s:check_bundle_name(bundle)[J

calling function vundle#config#bundle[2]..<SNR>6_check_bundle_name[J({'uri': 'https://github.com/godlygeek/...lygeek/tabular', 'path': function('1')})

line 1:   if has_key(s:bundle_names, a:bundle.name)[J

line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . s:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'[J

line 6:     return 0[J

line 7:   elseif a:bundle.name !~ '\v^[A-Za-z0-9_-]%(\.?[A-Za-z0-9_-])*$'[J

line 8:     echoerr 'Invalid plugin name: ' . a:bundle.name[J

line 9:     return 0[J

line 10:   endif[J

line 11:   let s:bundle_names[a:bundle.name] = a:bundle.name_spec[J

line 12:   return 1[J

function vundle#config#bundle[2]..<SNR>6_check_bundle_name returning #1[J

continuing in function vundle#config#bundle[J

line 3:     return[J

line 4:   endif[J

line 5:   if exists('g:vundle#lazy_load') && g:vundle#lazy_load[J

line 6:     call add(g:vundle#bundles, bundle)[J

line 7:   else[J

line 8:     call s:rtp_rm_a()[J

line 9:     call add(g:vundle#bundles, bundle)[J

line 10:     call s:rtp_add_a()[J

line 11:     call s:rtp_add_defaults()[J

line 12:   endif[J

line 13:   return bundle[J

function vundle#config#bundle returning {'uri': 'https://github.com/godlygeek/...lygeek/tabular', 'path': function('1')}[J

continuing in /home/patrick/.vimrc[J

line 62: [J

line 63: Plugin 'dhruvasagar/vim-table-mode'    [J

line 63: call vundle#config#bundle('dhruvasagar/vim-table-mode')[J

calling function vundle#config#bundle[J('dhruvasagar/vim-table-mode')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[J('dhruvasagar/vim-table-mode', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')[J

line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"[J

line 3:   endif[J

line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_options[J([])

line 1:   " TODO: improve this[J

line 2:   if len(a:opts) != 1 | return {} | endif[J

line 2:  return {} | endif[J

function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_options returning {}[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_name[J('dhruvasagar/vim-table-mode')

line 1:   let arg = a:arg[J

line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'[J

line 3: [J

line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'[J

line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1][J

line 7:     if uri !~? '\.git$'[J

line 8:       let uri .= '.git'[J

line 9:     endif[J

line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')[J

line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'[J

line 14:     let uri = arg[J

line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1][J

line 16:   else[J

line 17:     let name = arg[J

line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'[J

line 19:   endif[J

line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }[J

function vundle#config#bundle[1]..vundle#config#init_bundle[4]..<SNR>6_parse_name returning {'uri': 'https://github.com/dhruvasaga...me_spec': 'dhruvasagar/vim-table-mode'}[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[J

line 5:   let b = extend(opts, copy(s:bundle))[J

line 6:   let b.rtpath = s:rtpath(opts)[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[J({'uri': 'https://github.com/dhruvasaga...vim-table-mode', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[J()

line 1:   return s:expand_path(g:vundle#bundle_dir.'/') . self.name[J

calling function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[1]..<SNR>6_expand_path[J('/home/patrick/.vim/bundle/')

line 1:   return simplify(expand(a:path, 1))[J

function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[1]..<SNR>6_expand_path returning '/home/patrick/.vim/bundle/'[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1[J

function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[1]..1 returning '/home/patrick/.vim/bundle/vim-table-mode'[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath[J

function vundle#config#bundle[1]..vundle#config#init_bundle[6]..<SNR>6_rtpath returning '/home/patrick/.vim/bundle/vim-table-mode'[J

continuing in function vundle#config#bundle[1]..vundle#config#init_bundle[J

line 7:   return b[J

function vundle#config#bundle[1]..vundle#config#init_bundle returning {'uri': 'https://github.com/dhruvasaga...vim-table-mode', 'path': function('1')}[J

continuing in function vundle#config#bundle[J

line 2:   if !s:check_bundle_name(bundle)[J

calling function vundle#config#bundle[2]..<SNR>6_check_bundle_name[J({'uri': 'https://github.com/dhruvasaga...vim-table-mode', 'path': function('1')})

line 1:   if has_key(s:bundle_names, a:bundle.name)[J

line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . s:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'[J

line 6:     return 0[J

line 7:   elseif a:bundle.name !~ '\v^[A-Za-z0-9_-]%(\.?[A-Za-z0-9_-])*$'[J

line 8:     echoerr 'Invalid plugin name: ' . a:bundle.name[J

line 9:     return 0[J

line 10:   endif[J

line 11:   let s:bundle_names[a:bundle.name] = a:bundle.name_spec[J

line 12:   return 1[J

function vundle#config#bundle[2]..<SNR>6_check_bundle_name returning #1[J

continuing in function vundle#config#bundle[J

line 3:     return[J

line 4:   endif[J

line 5:   if exists('g:vundle#lazy_load') && g:vundle#lazy_load[J

line 6:     call add(g:vundle#bundles, bundle)[J

line 7:   else[J

line 8:     call s:rtp_rm_a()[J

line 9:     call add(g:vundle#bundles, bundle)[J

line 10:     call s:rtp_add_a()[J

line 11:     call s:rtp_add_defaults()[J

line 12:   endif[J

line 13:   return bundle[J

function vundle#config#bundle returning {'uri': 'https://github.com/dhruvasaga...vim-table-mode', 'path': function('1')}[J

continuing in /home/patrick/.vimrc[J

line 64: " All of your Plugins must be added before the following line[J

line 65: call vundle#end()            " required[J

calling function vundle#end[J()

line 1:   unlet g:vundle#lazy_load[J

line 2:   call vundle#config#activate_bundles()[J

calling function vundle#end[2]..vundle#config#activate_bundles[J()

line 1:   call s:rtp_add_a()[J

calling function vundle#end[2]..vundle#config#activate_bundles[1]..<SNR>6_rtp_add_a[J()

line 1:   let paths = map(copy(g:vundle#bundles), 'v:val.rtpath')[J

line 2:   let prepends = join(paths, ',')[J

line 3:   let appends = join(paths, '/after,').'/after'[J

line 4:   exec 'set rtp^='.fnameescape(prepends)[J

line 4: set rtp^=/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode[J

line 5:   exec 'set rtp+='.fnameescape(appends)[J

line 5: set rtp+=/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/after,/home/patrick/.vim/bundle/tabular/after,/home/patrick/.vim/bundle/vim-table-mode/after[J

function vundle#end[2]..vundle#config#activate_bundles[1]..<SNR>6_rtp_add_a returning #0[J

continuing in function vundle#end[2]..vundle#config#activate_bundles[J

line 2:   call s:rtp_add_defaults()[J

calling function vundle#end[2]..vundle#config#activate_bundles[2]..<SNR>6_rtp_add_defaults[J()

line 1:   let current = &rtp[J

line 2:   set rtp&vim[J

line 3:   let default = &rtp[J

line 4:   let &rtp = current[J

line 5:   let default_rtp_items = split(default, ',')[J

line 6:   if !empty(default_rtp_items)[J

line 7:     let first_item = fnameescape(default_rtp_items[0])[J

line 8:     exec 'set rtp-=' . first_item[J

line 8: set rtp-=/home/patrick/.vim[J

line 9:     exec 'set rtp^=' . first_item[J

line 9: set rtp^=/home/patrick/.vim[J

line 10:   endif[J

function vundle#end[2]..vundle#config#activate_bundles[2]..<SNR>6_rtp_add_defaults returning #0[J

continuing in function vundle#end[2]..vundle#config#activate_bundles[J

function vundle#end[2]..vundle#config#activate_bundles returning #0[J

continuing in function vundle#end[J

function vundle#end returning #0[J

continuing in /home/patrick/.vimrc[J

line 66: filetype plugin indent on    " required[J

Searching for "filetype.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/after,/home/patrick/.vim/bundle/tabular/after,/home/patrick/.v[J
Searching for "/home/patrick/.vim/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdcommenter/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-fugitive/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/ale/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/tabular/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-table-mode/filetype.vim"[J
Searching for "/var/lib/vim/addons/filetype.vim"[J
Searching for "/usr/share/vim/vimfiles/filetype.vim"[J
Searching for "/usr/share/vim/vim80/filetype.vim"[J
chdir(/usr/share/vim/vim80)[J
fchdir() to previous dir[J
line 66: sourcing "/usr/share/vim/vim80/filetype.vim"[J
line 1: " Vim support file to detect file types[J

line 2: "[J

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 4: " Last Change:^I2017 Jan 06[J

line 5: [J

line 6: " Listen very carefully, I will say this only once[J

line 7: if exists("did_load_filetypes")[J

line 8:   finish[J

line 9: endif[J

line 10: let did_load_filetypes = 1[J

line 11: [J

line 12: " Line continuation is used here, remove 'C' from 'cpoptions'[J

line 13: let s:cpo_save = &cpo[J

line 14: set cpo&vim[J

line 15: [J

line 16: augroup filetypedetect[J

line 17: [J

line 18: " Ignored extensions[J

line 19: if exists("*fnameescape")[J

line 21: au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew,?\+.pacsave,?\+.pacnew exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))[J

line 28: au BufNewFile,BufRead *~ let s:name = expand("<afile>") | let s:short = substitute(s:name, '\~$', '', '') | if s:name != s:short && s:short != "" |   exe "doau filetypedetect BufRead " . fnameescape(s:short) | endif | unlet! s:name s:short[J

line 32: au BufNewFile,BufRead ?\+.in if expand("<afile>:t") != "configure.in" |   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) | endif[J

line 33: elseif &verbose > 0[J

line 34:   echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"[J

line 35: endif[J

line 36: [J

line 37: " Pattern used to match file names which should not be inspected.[J

line 38: " Currently finds compressed files.[J

line 39: if !exists("g:ft_ignore_pat")[J

line 40:   let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'[J

line 41: endif[J

line 42: [J

line 43: " Function used for patterns that end in a star: don't set the filetype if the[J

line 44: " file name matches ft_ignore_pat.[J

line 45: func! s:StarSetf(ft)[J

line 50: [J

line 51: " Abaqus or Trasys[J

line 52: au BufNewFile,BufRead *.inp^I^I^Icall s:Check_inp()[J

line 53: [J

line 54: func! s:Check_inp()[J

line 73: [J

line 74: " A-A-P recipe[J

line 75: au BufNewFile,BufRead *.aap^I^I^Isetf aap[J

line 76: [J

line 77: " A2ps printing utility[J

line 78: au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps[J

line 79: [J

line 80: " ABAB/4[J

line 81: au BufNewFile,BufRead *.abap^I^I^Isetf abap[J

line 82: [J

line 83: " ABC music notation[J

line 84: au BufNewFile,BufRead *.abc^I^I^Isetf abc[J

line 85: [J

line 86: " ABEL[J

line 87: au BufNewFile,BufRead *.abl^I^I^Isetf abel[J

line 88: [J

line 89: " AceDB[J

line 90: au BufNewFile,BufRead *.wrm^I^I^Isetf acedb[J

line 91: [J

line 92: " Ada (83, 9X, 95)[J

line 93: au BufNewFile,BufRead *.adb,*.ads,*.ada^I^Isetf ada[J

line 94: if has("vms")[J

line 95:   au BufNewFile,BufRead *.gpr,*.ada_m,*.adc^Isetf ada[J

line 96: else[J

line 97:   au BufNewFile,BufRead *.gpr^I^I^Isetf ada[J

line 98: endif[J

line 99: [J

line 100: " AHDL[J

line 101: au BufNewFile,BufRead *.tdf^I^I^Isetf ahdl[J

line 102: [J

line 103: " AMPL[J

line 104: au BufNewFile,BufRead *.run^I^I^Isetf ampl[J

line 105: [J

line 106: " Ant[J

line 107: au BufNewFile,BufRead build.xml^I^I^Isetf ant[J

line 108: [J

line 109: " Arduino[J

line 110: au BufNewFile,BufRead *.ino,*.pde^I^Isetf arduino[J

line 111: [J

line 112: " Apache style config file[J

line 113: au BufNewFile,BufRead proftpd.conf*^I^Icall s:StarSetf('apachestyle')[J

line 114: [J

line 115: " Apache config file[J

line 116: au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf^I^Isetf apache[J

line 117: [J

line 118: " XA65 MOS6510 cross assembler[J

line 119: au BufNewFile,BufRead *.a65^I^I^Isetf a65[J

line 120: [J

line 121: " Applescript[J

line 122: au BufNewFile,BufRead *.scpt^I^I^Isetf applescript[J

line 123: [J

line 124: " Applix ELF[J

line 126: au BufNewFile,BufRead *.am if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif[J

line 127: [J

line 128: " ALSA configuration[J

line 129: au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf[J

line 130: [J

line 131: " Arc Macro Language[J

line 132: au BufNewFile,BufRead *.aml^I^I^Isetf aml[J

line 133: [J

line 134: " APT config file[J

line 135: au BufNewFile,BufRead apt.conf^I^I       setf aptconf[J

line 136: au BufNewFile,BufRead */.aptitude/config       setf aptconf[J

line 137: au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} setf aptconf[J

line 138: [J

line 139: " Arch Inventory file[J

line 140: au BufNewFile,BufRead .arch-inventory,=tagging-method^Isetf arch[J

line 141: [J

line 142: " ART*Enterprise (formerly ART-IM)[J

line 143: au BufNewFile,BufRead *.art^I^I^Isetf art[J

line 144: [J

line 145: " AsciiDoc[J

line 146: au BufNewFile,BufRead *.asciidoc,*.adoc^I^Isetf asciidoc[J

line 147: [J

line 148: " ASN.1[J

line 149: au BufNewFile,BufRead *.asn,*.asn1^I^Isetf asn[J

line 150: [J

line 151: " Active Server Pages (with Visual Basic Script)[J

line 157: au BufNewFile,BufRead *.asa if exists("g:filetype_asa") |   exe "setf " . g:filetype_asa | else |   setf aspvbs | endif[J

line 158: [J

line 159: " Active Server Pages (with Perl or Visual Basic Script)[J

line 167: au BufNewFile,BufRead *.asp if exists("g:filetype_asp") |   exe "setf " . g:filetype_asp | elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |   setf aspperl | else |   setf aspvbs | endif[J

line 168: [J

line 169: " Grub (must be before catch *.lst)[J

line 170: au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub[J

line 171: [J

line 172: " Assembly (all kinds)[J

line 173: " *.lst is not pure assembly, it has two extra columns (address, byte codes)[J

line 174: au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst^Icall s:FTasm()[J

line 175: [J

line 176: " This function checks for the kind of assembly that is wanted by the user, or[J

line 177: " can be detected from the first five lines of the file.[J

line 178: func! s:FTasm()[J

line 199: [J

line 200: func! s:FTasmsyntax()[J

line 212: [J

line 213: " Macro (VAX)[J

line 214: au BufNewFile,BufRead *.mar^I^I^Isetf vmasm[J

line 215: [J

line 216: " Atlas[J

line 217: au BufNewFile,BufRead *.atl,*.as^I^Isetf atlas[J

line 218: [J

line 219: " Autoit v3[J

line 220: au BufNewFile,BufRead *.au3^I^I^Isetf autoit[J

line 221: [J

line 222: " Autohotkey[J

line 223: au BufNewFile,BufRead *.ahk^I^I^Isetf autohotkey[J

line 224: [J

line 225: " Automake[J

line 226: au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am^Isetf automake[J

line 227: [J

line 228: " Autotest .at files are actually m4[J

line 229: au BufNewFile,BufRead *.at^I^I^Isetf m4[J

line 230: [J

line 231: " Avenue[J

line 232: au BufNewFile,BufRead *.ave^I^I^Isetf ave[J

line 233: [J

line 234: " Awk[J

line 235: au BufNewFile,BufRead *.awk^I^I^Isetf awk[J

line 236: [J

line 237: " B[J

line 238: au BufNewFile,BufRead *.mch,*.ref,*.imp^I^Isetf b[J

line 239: [J

line 240: " BASIC or Visual Basic[J

line 241: au BufNewFile,BufRead *.bas^I^I^Icall s:FTVB("basic")[J

line 242: [J

line 243: " Check if one of the first five lines contains "VB_Name".  In that case it is[J

line 244: " probably a Visual Basic file.  Otherwise it's assumed to be "alt" filetype.[J

line 245: func! s:FTVB(alt)[J

line 252: [J

line 253: " Visual Basic Script (close to Visual Basic) or Visual Basic .NET[J

line 254: au BufNewFile,BufRead *.vb,*.vbs,*.dsm,*.ctl^Isetf vb[J

line 255: [J

line 256: " IBasic file (similar to QBasic)[J

line 257: au BufNewFile,BufRead *.iba,*.ibi^I^Isetf ibasic[J

line 258: [J

line 259: " FreeBasic file (similar to QBasic)[J

line 260: au BufNewFile,BufRead *.fb,*.bi^I^I^Isetf freebasic[J

line 261: [J

line 262: " Batch file for MSDOS.[J

line 263: au BufNewFile,BufRead *.bat,*.sys^I^Isetf dosbatch[J

line 264: " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.[J

line 266: au BufNewFile,BufRead *.cmd if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif[J

line 267: [J

line 268: " Batch file for 4DOS[J

line 269: au BufNewFile,BufRead *.btm^I^I^Icall s:FTbtm()[J

line 270: func! s:FTbtm()[J

line 277: [J

line 278: " BC calculator[J

line 279: au BufNewFile,BufRead *.bc^I^I^Isetf bc[J

line 280: [J

line 281: " BDF font[J

line 282: au BufNewFile,BufRead *.bdf^I^I^Isetf bdf[J

line 283: [J

line 284: " BibTeX bibliography database file[J

line 285: au BufNewFile,BufRead *.bib^I^I^Isetf bib[J

line 286: [J

line 287: " BibTeX Bibliography Style[J

line 288: au BufNewFile,BufRead *.bst^I^I^Isetf bst[J

line 289: [J

line 290: " BIND configuration[J

line 291: au BufNewFile,BufRead named.conf,rndc.conf^Isetf named[J

line 292: [J

line 293: " BIND zone[J

line 294: au BufNewFile,BufRead named.root^I^Isetf bindzone[J

line 295: au BufNewFile,BufRead *.db^I^I^Icall s:BindzoneCheck('')[J

line 296: [J

line 297: func! s:BindzoneCheck(default)[J

line 304: [J

line 305: " Blank[J

line 306: au BufNewFile,BufRead *.bl^I^I^Isetf blank[J

line 307: [J

line 308: " Blkid cache file[J

line 309: au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml[J

line 310: [J

line 311: " Bazel (http://bazel.io)[J

line 312: autocmd BufRead,BufNewFile *.bzl,WORKSPACE setfiletype bzl[J

line 313: if has("fname_case")[J

line 314:   autocmd BufRead,BufNewFile BUILD setfiletype bzl[J

line 315: endif[J

line 316: [J

line 317: " C or lpc[J

line 318: au BufNewFile,BufRead *.c^I^I^Icall s:FTlpc()[J

line 319: [J

line 320: func! s:FTlpc()[J

line 333: [J

line 334: " Calendar[J

line 335: au BufNewFile,BufRead calendar^I^I^Isetf calendar[J

line 336: [J

line 337: " C#[J

line 338: au BufNewFile,BufRead *.cs^I^I^Isetf cs[J

line 339: [J

line 340: " CSDL[J

line 341: au BufNewFile,BufRead *.csdl^I^I^Isetf csdl[J

line 342: [J

line 343: " Cabal[J

line 344: au BufNewFile,BufRead *.cabal^I^I^Isetf cabal[J

line 345: [J

line 346: " Cdrdao TOC[J

line 347: au BufNewFile,BufRead *.toc^I^I^Isetf cdrtoc[J

line 348: [J

line 349: " Cdrdao config[J

line 350: au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao^Isetf cdrdaoconf[J

line 351: [J

line 352: " Cfengine[J

line 353: au BufNewFile,BufRead cfengine.conf^I^Isetf cfengine[J

line 354: [J

line 355: " ChaiScript[J

line 356: au BufRead,BufNewFile *.chai^I^I^Isetf chaiscript[J

line 357: [J

line 358: " Comshare Dimension Definition Language[J

line 359: au BufNewFile,BufRead *.cdl^I^I^Isetf cdl[J

line 360: [J

line 361: " Conary Recipe[J

line 362: au BufNewFile,BufRead *.recipe^I^I^Isetf conaryrecipe[J

line 363: [J

line 364: " Controllable Regex Mutilator[J

line 365: au BufNewFile,BufRead *.crm^I^I^Isetf crm[J

line 366: [J

line 367: " Cyn++[J

line 368: au BufNewFile,BufRead *.cyn^I^I^Isetf cynpp[J

line 369: [J

line 370: " Cynlib[J

line 371: " .cc and .cpp files can be C++ or Cynlib.[J

line 373: au BufNewFile,BufRead *.cc if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif[J

line 375: au BufNewFile,BufRead *.cpp if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif[J

line 376: [J

line 377: " C++[J

line 378: au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp[J

line 379: if has("fname_case")[J

line 380:   au BufNewFile,BufRead *.C,*.H setf cpp[J

line 381: endif[J

line 382: [J

line 383: " .h files can be C, Ch C++, ObjC or ObjC++.[J

line 384: " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is[J

line 385: " detected automatically.[J

line 386: au BufNewFile,BufRead *.h^I^I^Icall s:FTheader()[J

line 387: [J

line 388: func! s:FTheader()[J

line 403: [J

line 404: " Ch (CHscript)[J

line 405: au BufNewFile,BufRead *.chf^I^I^Isetf ch[J

line 406: [J

line 407: " TLH files are C++ headers generated by Visual C++'s #import from typelibs[J

line 408: au BufNewFile,BufRead *.tlh^I^I^Isetf cpp[J

line 409: [J

line 410: " Cascading Style Sheets[J

line 411: au BufNewFile,BufRead *.css^I^I^Isetf css[J

line 412: [J

line 413: " Century Term Command Scripts (*.cmd too)[J

line 414: au BufNewFile,BufRead *.con^I^I^Isetf cterm[J

line 415: [J

line 416: " Changelog[J

line 418: au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch^Isetf debchangelog[J

line 419: [J

line 425: au BufNewFile,BufRead [cC]hange[lL]og  if getline(1) =~ '; urgency='|   setf debchangelog| else|   setf changelog| endif[J

line 426: [J

line 430: au BufNewFile,BufRead NEWS  if getline(1) =~ '; urgency='|   setf debchangelog| endif[J

line 431: [J

line 432: " CHILL[J

line 433: au BufNewFile,BufRead *..ch^I^I^Isetf chill[J

line 434: [J

line 435: " Changes for WEB and CWEB or CHILL[J

line 436: au BufNewFile,BufRead *.ch^I^I^Icall s:FTchange()[J

line 437: [J

line 438: " This function checks if one of the first ten lines start with a '@'.  In[J

line 439: " that case it is probably a change file.[J

line 440: " If the first line starts with # or ! it's probably a ch file.[J

line 441: " If a line has "main", "include", "//" ir "/*" it's probably ch.[J

line 442: " Otherwise CHILL is assumed.[J

line 443: func! s:FTchange()[J

line 466: [J

line 467: " ChordPro[J

line 468: au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro^Isetf chordpro[J

line 469: [J

line 470: " Clean[J

line 471: au BufNewFile,BufRead *.dcl,*.icl^I^Isetf clean[J

line 472: [J

line 473: " Clever[J

line 474: au BufNewFile,BufRead *.eni^I^I^Isetf cl[J

line 475: [J

line 476: " Clever or dtd[J

line 477: au BufNewFile,BufRead *.ent^I^I^Icall s:FTent()[J

line 478: [J

line 479: func! s:FTent()[J

line 498: [J

line 499: " Clipper (or FoxPro; could also be eviews)[J

line 505: au BufNewFile,BufRead *.prg if exists("g:filetype_prg") |   exe "setf " . g:filetype_prg | else |   setf clipper | endif[J

line 506: [J

line 507: " Clojure[J

line 508: au BufNewFile,BufRead *.clj,*.cljs,*.cljx,*.cljc^I^Isetf clojure[J

line 509: [J

line 510: " Cmake[J

line 511: au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in^I^Isetf cmake[J

line 512: [J

line 513: " Cmusrc[J

line 514: au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc[J

line 515: au BufNewFile,BufRead */cmus/{rc,*.theme}^I^I^Isetf cmusrc[J

line 516: [J

line 517: " Cobol[J

line 518: au BufNewFile,BufRead *.cbl,*.cob,*.lib^Isetf cobol[J

line 519: "   cobol or zope form controller python script? (heuristic)[J

line 525: au BufNewFile,BufRead *.cpy if getline(1) =~ '^##' |   setf python | else |   setf cobol | endif[J

line 526: [J

line 527: " Coco/R[J

line 528: au BufNewFile,BufRead *.atg^I^I^Isetf coco[J

line 529: [J

line 530: " Cold Fusion[J

line 531: au BufNewFile,BufRead *.cfm,*.cfi,*.cfc^I^Isetf cf[J

line 532: [J

line 533: " Configure scripts[J

line 534: au BufNewFile,BufRead configure.in,configure.ac setf config[J

line 535: [J

line 536: " CUDA  Cumpute Unified Device Architecture[J

line 537: au BufNewFile,BufRead *.cu^I^I^Isetf cuda[J

line 538: [J

line 539: " Dockerfile[J

line 540: au BufNewFile,BufRead Dockerfile,*.Dockerfile^Isetf dockerfile[J

line 541: [J

line 542: " WildPackets EtherPeek Decoder[J

line 543: au BufNewFile,BufRead *.dcd^I^I^Isetf dcd[J

line 544: [J

line 545: " Enlightenment configuration files[J

line 546: au BufNewFile,BufRead *enlightenment/*.cfg^Isetf c[J

line 547: [J

line 548: " Eterm[J

line 549: au BufNewFile,BufRead *Eterm/*.cfg^I^Isetf eterm[J

line 550: [J

line 551: " Euphoria 3 or 4[J

line 552: au BufNewFile,BufRead *.eu,*.ew,*.ex,*.exu,*.exw  call s:EuphoriaCheck()[J

line 553: if has("fname_case")[J

line 554:    au BufNewFile,BufRead *.EU,*.EW,*.EX,*.EXU,*.EXW  call s:EuphoriaCheck()[J

line 555: endif[J

line 556: [J

line 557: func! s:EuphoriaCheck()[J

line 564: [J

line 565: " Lynx config files[J

line 566: au BufNewFile,BufRead lynx.cfg^I^I^Isetf lynx[J

line 567: [J

line 568: " Quake[J

line 569: au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg^Isetf quake[J

line 570: au BufNewFile,BufRead *quake[1-3]/*.cfg^I^I^Isetf quake[J

line 571: [J

line 572: " Quake C[J

line 573: au BufNewFile,BufRead *.qc^I^I^Isetf c[J

line 574: [J

line 575: " Configure files[J

line 576: au BufNewFile,BufRead *.cfg^I^I^Isetf cfg[J

line 577: [J

line 578: " Cucumber[J

line 579: au BufNewFile,BufRead *.feature^I^I^Isetf cucumber[J

line 580: [J

line 581: " Communicating Sequential Processes[J

line 582: au BufNewFile,BufRead *.csp,*.fdr^I^Isetf csp[J

line 583: [J

line 584: " CUPL logic description and simulation[J

line 585: au BufNewFile,BufRead *.pld^I^I^Isetf cupl[J

line 586: au BufNewFile,BufRead *.si^I^I^Isetf cuplsim[J

line 587: [J

line 588: " Debian Control[J

line 589: au BufNewFile,BufRead */debian/control^I^Isetf debcontrol[J

line 593: au BufNewFile,BufRead control  if getline(1) =~ '^Source:'|   setf debcontrol| endif[J

line 594: [J

line 595: " Debian Sources.list[J

line 596: au BufNewFile,BufRead */etc/apt/sources.list^I^Isetf debsources[J

line 597: au BufNewFile,BufRead */etc/apt/sources.list.d/*.list^Isetf debsources[J

line 598: [J

line 599: " Deny hosts[J

line 600: au BufNewFile,BufRead denyhosts.conf^I^Isetf denyhosts[J

line 601: [J

line 602: " dnsmasq(8) configuration files[J

line 603: au BufNewFile,BufRead */etc/dnsmasq.conf^Isetf dnsmasq[J

line 604: [J

line 605: " ROCKLinux package description[J

line 606: au BufNewFile,BufRead *.desc^I^I^Isetf desc[J

line 607: [J

line 608: " the D language or dtrace[J

line 609: au BufNewFile,BufRead *.d^I^I^Icall s:DtraceCheck()[J

line 610: [J

line 611: func! s:DtraceCheck()[J

line 622: [J

line 623: " Desktop files[J

line 624: au BufNewFile,BufRead *.desktop,.directory^Isetf desktop[J

line 625: [J

line 626: " Dict config[J

line 627: au BufNewFile,BufRead dict.conf,.dictrc^I^Isetf dictconf[J

line 628: [J

line 629: " Dictd config[J

line 630: au BufNewFile,BufRead dictd.conf^I^Isetf dictdconf[J

line 631: [J

line 632: " Diff files[J

line 633: au BufNewFile,BufRead *.diff,*.rej,*.patch^Isetf diff[J

line 634: [J

line 635: " Dircolors[J

line 636: au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS^Isetf dircolors[J

line 637: [J

line 638: " Diva (with Skill) or InstallShield[J

line 644: au BufNewFile,BufRead *.rul if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |   setf ishd | else |   setf diva | endif[J

line 645: [J

line 646: " DCL (Digital Command Language - vms) or DNS zone file[J

line 647: au BufNewFile,BufRead *.com^I^I^Icall s:BindzoneCheck('dcl')[J

line 648: [J

line 649: " DOT[J

line 650: au BufNewFile,BufRead *.dot^I^I^Isetf dot[J

line 651: [J

line 652: " Dylan - lid files[J

line 653: au BufNewFile,BufRead *.lid^I^I^Isetf dylanlid[J

line 654: [J

line 655: " Dylan - intr files (melange)[J

line 656: au BufNewFile,BufRead *.intr^I^I^Isetf dylanintr[J

line 657: [J

line 658: " Dylan[J

line 659: au BufNewFile,BufRead *.dylan^I^I^Isetf dylan[J

line 660: [J

line 661: " Microsoft Module Definition[J

line 662: au BufNewFile,BufRead *.def^I^I^Isetf def[J

line 663: [J

line 664: " Dracula[J

line 665: au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe^Isetf dracula[J

line 666: [J

line 667: " Datascript[J

line 668: au BufNewFile,BufRead *.ds^I^I^Isetf datascript[J

line 669: [J

line 670: " dsl[J

line 671: au BufNewFile,BufRead *.dsl^I^I^Isetf dsl[J

line 672: [J

line 673: " DTD (Document Type Definition for XML)[J

line 674: au BufNewFile,BufRead *.dtd^I^I^Isetf dtd[J

line 675: [J

line 676: " DTS/DSTI (device tree files)[J

line 677: au BufNewFile,BufRead *.dts,*.dtsi^I^Isetf dts[J

line 678: [J

line 679: " EDIF (*.edf,*.edif,*.edn,*.edo)[J

line 680: au BufNewFile,BufRead *.ed\(f\|if\|n\|o\)^Isetf edif[J

line 681: [J

line 682: " EditorConfig (close enough to dosini)[J

line 683: au BufNewFile,BufRead .editorconfig^I^Isetf dosini[J

line 684: [J

line 685: " Embedix Component Description[J

line 686: au BufNewFile,BufRead *.ecd^I^I^Isetf ecd[J

line 687: [J

line 688: " Eiffel or Specman or Euphoria[J

line 689: au BufNewFile,BufRead *.e,*.E^I^I^Icall s:FTe()[J

line 690: [J

line 691: " Elinks configuration[J

line 692: au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf^Isetf elinks[J

line 693: [J

line 694: func! s:FTe()[J

line 709: [J

line 710: " ERicsson LANGuage; Yaws is erlang too[J

line 711: au BufNewFile,BufRead *.erl,*.hrl,*.yaws^Isetf erlang[J

line 712: [J

line 713: " Elm Filter Rules file[J

line 714: au BufNewFile,BufRead filter-rules^I^Isetf elmfilt[J

line 715: [J

line 716: " ESMTP rc file[J

line 717: au BufNewFile,BufRead *esmtprc^I^I^Isetf esmtprc[J

line 718: [J

line 719: " ESQL-C[J

line 720: au BufNewFile,BufRead *.ec,*.EC^I^I^Isetf esqlc[J

line 721: [J

line 722: " Esterel[J

line 723: au BufNewFile,BufRead *.strl^I^I^Isetf esterel[J

line 724: [J

line 725: " Essbase script[J

line 726: au BufNewFile,BufRead *.csc^I^I^Isetf csc[J

line 727: [J

line 728: " Exim[J

line 729: au BufNewFile,BufRead exim.conf^I^I^Isetf exim[J

line 730: [J

line 731: " Expect[J

line 732: au BufNewFile,BufRead *.exp^I^I^Isetf expect[J

line 733: [J

line 734: " Exports[J

line 735: au BufNewFile,BufRead exports^I^I^Isetf exports[J

line 736: [J

line 737: " Falcon[J

line 738: au BufNewFile,BufRead *.fal^I^I^Isetf falcon[J

line 739: [J

line 740: " Fantom[J

line 741: au BufNewFile,BufRead *.fan,*.fwt^I^Isetf fan[J

line 742: [J

line 743: " Factor[J

line 744: au BufNewFile,BufRead *.factor^I^I^Isetf factor[J

line 745: [J

line 746: " Fetchmail RC file[J

line 747: au BufNewFile,BufRead .fetchmailrc^I^Isetf fetchmail[J

line 748: [J

line 749: " FlexWiki - disabled, because it has side effects when a .wiki file[J

line 750: " is not actually FlexWiki[J

line 751: "au BufNewFile,BufRead *.wiki^I^I^Isetf flexwiki[J

line 752: [J

line 753: " Focus Executable[J

line 754: au BufNewFile,BufRead *.fex,*.focexec^I^Isetf focexec[J

line 755: [J

line 756: " Focus Master file (but not for auto.master)[J

line 757: au BufNewFile,BufRead auto.master^I^Isetf conf[J

line 758: au BufNewFile,BufRead *.mas,*.master^I^Isetf master[J

line 759: [J

line 760: " Forth[J

line 761: au BufNewFile,BufRead *.fs,*.ft^I^I^Isetf forth[J

line 762: [J

line 763: " Reva Forth[J

line 764: au BufNewFile,BufRead *.frt^I^I^Isetf reva[J

line 765: [J

line 766: " Fortran[J

line 767: if has("fname_case")[J

line 768:   au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08^I setf fortran[J

line 769: endif[J

line 770: au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran[J

line 771: [J

line 772: " Framescript[J

line 773: au BufNewFile,BufRead *.fsl^I^I^Isetf framescript[J

line 774: [J

line 775: " FStab[J

line 776: au BufNewFile,BufRead fstab,mtab^I^Isetf fstab[J

line 777: [J

line 778: " GDB command files[J

line 779: au BufNewFile,BufRead .gdbinit^I^I^Isetf gdb[J

line 780: [J

line 781: " GDMO[J

line 782: au BufNewFile,BufRead *.mo,*.gdmo^I^Isetf gdmo[J

line 783: [J

line 784: " Gedcom[J

line 785: au BufNewFile,BufRead *.ged,lltxxxxx.txt^Isetf gedcom[J

line 786: [J

line 787: " Git[J

line 788: au BufNewFile,BufRead COMMIT_EDITMSG,MERGE_MSG,TAG_EDITMSG setf gitcommit[J

line 789: au BufNewFile,BufRead *.git/config,.gitconfig,.gitmodules setf gitconfig[J

line 790: au BufNewFile,BufRead *.git/modules/*/config^Isetf gitconfig[J

line 791: au BufNewFile,BufRead */.config/git/config^Isetf gitconfig[J

line 792: if !empty($XDG_CONFIG_HOME)[J

line 793:   au BufNewFile,BufRead $XDG_CONFIG_HOME/git/config^Isetf gitconfig[J

line 794: endif[J

line 795: au BufNewFile,BufRead git-rebase-todo^I^Isetf gitrebase[J

line 799: au BufNewFile,BufRead .msg.[0-9]* if getline(1) =~ '^From.*# This line is ignored.$' |   setf gitsendemail | endif[J

line 803: au BufNewFile,BufRead *.git/* if getline(1) =~ '^\x\{40\}\>\|^ref: ' |   setf git | endif[J

line 804: [J

line 805: " Gkrellmrc[J

line 806: au BufNewFile,BufRead gkrellmrc,gkrellmrc_?^Isetf gkrellmrc[J

line 807: [J

line 808: " GP scripts (2.0 and onward)[J

line 809: au BufNewFile,BufRead *.gp,.gprc^I^Isetf gp[J

line 810: [J

line 811: " GPG[J

line 812: au BufNewFile,BufRead */.gnupg/options^I^Isetf gpg[J

line 813: au BufNewFile,BufRead */.gnupg/gpg.conf^I^Isetf gpg[J

line 814: au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg[J

line 815: if !empty($GNUPGHOME)[J

line 816:   au BufNewFile,BufRead $GNUPGHOME/options^Isetf gpg[J

line 817:   au BufNewFile,BufRead $GNUPGHOME/gpg.conf^Isetf gpg[J

line 818: endif[J

line 819: [J

line 820: " gnash(1) configuration files[J

line 821: au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash[J

line 822: [J

line 823: " Gitolite[J

line 824: au BufNewFile,BufRead gitolite.conf^I^Isetf gitolite[J

line 825: au BufNewFile,BufRead */gitolite-admin/conf/*^Icall s:StarSetf('gitolite')[J

line 826: au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc^Isetf perl[J

line 827: [J

line 828: " Gnuplot scripts[J

line 829: au BufNewFile,BufRead *.gpi^I^I^Isetf gnuplot[J

line 830: [J

line 831: " Go (Google)[J

line 832: au BufNewFile,BufRead *.go^I^I^Isetf go[J

line 833: [J

line 834: " GrADS scripts[J

line 835: au BufNewFile,BufRead *.gs^I^I^Isetf grads[J

line 836: [J

line 837: " Gretl[J

line 838: au BufNewFile,BufRead *.gretl^I^I^Isetf gretl[J

line 839: [J

line 840: " Groovy[J

line 841: au BufNewFile,BufRead *.gradle,*.groovy^I^Isetf groovy[J

line 842: [J

line 843: " GNU Server Pages[J

line 844: au BufNewFile,BufRead *.gsp^I^I^Isetf gsp[J

line 845: [J

line 846: " Group file[J

line 847: au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group[J

line 848: [J

line 849: " GTK RC[J

line 850: au BufNewFile,BufRead .gtkrc,gtkrc^I^Isetf gtkrc[J

line 851: [J

line 852: " Haml[J

line 853: au BufNewFile,BufRead *.haml^I^I^Isetf haml[J

line 854: [J

line 855: " Hamster Classic | Playground files[J

line 856: au BufNewFile,BufRead *.hsc,*.hsm^I^Isetf hamster[J

line 857: [J

line 858: " Haskell[J

line 859: au BufNewFile,BufRead *.hs,*.hs-boot^I^Isetf haskell[J

line 860: au BufNewFile,BufRead *.lhs^I^I^Isetf lhaskell[J

line 861: au BufNewFile,BufRead *.chs^I^I^Isetf chaskell[J

line 862: [J

line 863: " Haste[J

line 864: au BufNewFile,BufRead *.ht^I^I^Isetf haste[J

line 865: au BufNewFile,BufRead *.htpp^I^I^Isetf hastepreproc[J

line 866: [J

line 867: " Hercules[J

line 868: au BufNewFile,BufRead *.vc,*.ev,*.sum,*.errsum^Isetf hercules[J

line 869: [J

line 870: " HEX (Intel)[J

line 871: au BufNewFile,BufRead *.hex,*.h32^I^Isetf hex[J

line 872: [J

line 873: " Tilde (must be before HTML)[J

line 874: au BufNewFile,BufRead *.t.html^I^I^Isetf tilde[J

line 875: [J

line 876: " HTML (.shtml and .stm for server side)[J

line 877: au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call s:FThtml()[J

line 878: [J

line 879: " Distinguish between HTML, XHTML and Django[J

line 880: func! s:FThtml()[J

line 895: [J

line 896: " HTML with Ruby - eRuby[J

line 897: au BufNewFile,BufRead *.erb,*.rhtml^I^Isetf eruby[J

line 898: [J

line 899: " HTML with M4[J

line 900: au BufNewFile,BufRead *.html.m4^I^I^Isetf htmlm4[J

line 901: [J

line 902: " HTML Cheetah template[J

line 903: au BufNewFile,BufRead *.tmpl^I^I^Isetf htmlcheetah[J

line 904: [J

line 905: " Host config[J

line 906: au BufNewFile,BufRead */etc/host.conf^I^Isetf hostconf[J

line 907: [J

line 908: " Hosts access[J

line 909: au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess[J

line 910: [J

line 911: " Hyper Builder[J

line 912: au BufNewFile,BufRead *.hb^I^I^Isetf hb[J

line 913: [J

line 914: " Httest[J

line 915: au BufNewFile,BufRead *.htt,*.htb^I^Isetf httest[J

line 916: [J

line 917: " Icon[J

line 918: au BufNewFile,BufRead *.icn^I^I^Isetf icon[J

line 919: [J

line 920: " IDL (Interface Description Language)[J

line 921: au BufNewFile,BufRead *.idl^I^I^Icall s:FTidl()[J

line 922: [J

line 923: " Distinguish between standard IDL and MS-IDL[J

line 924: func! s:FTidl()[J

line 935: [J

line 936: " Microsoft IDL (Interface Description Language)  Also *.idl[J

line 937: " MOF = WMI (Windows Management Instrumentation) Managed Object Format[J

line 938: au BufNewFile,BufRead *.odl,*.mof^I^Isetf msidl[J

line 939: [J

line 940: " Icewm menu[J

line 941: au BufNewFile,BufRead */.icewm/menu^I^Isetf icemenu[J

line 942: [J

line 943: " Indent profile (must come before IDL *.pro!)[J

line 944: au BufNewFile,BufRead .indent.pro^I^Isetf indent[J

line 945: au BufNewFile,BufRead indent.pro^I^Icall s:ProtoCheck('indent')[J

line 946: [J

line 947: " IDL (Interactive Data Language)[J

line 948: au BufNewFile,BufRead *.pro^I^I^Icall s:ProtoCheck('idlang')[J

line 949: [J

line 950: " Distinguish between "default" and Cproto prototype file. */[J

line 951: func! s:ProtoCheck(default)[J

line 963: [J

line 964: [J

line 965: " Indent RC[J

line 966: au BufNewFile,BufRead indentrc^I^I^Isetf indent[J

line 967: [J

line 968: " Inform[J

line 969: au BufNewFile,BufRead *.inf,*.INF^I^Isetf inform[J

line 970: [J

line 971: " Initng[J

line 972: au BufNewFile,BufRead */etc/initng/*/*.i,*.ii^Isetf initng[J

line 973: [J

line 974: " Innovation Data Processing[J

line 975: au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c ^Isetf upstreamdat[J

line 976: au BufRead,BufNewFile upstream.log\c,upstream.*.log\c,*.upstream.log\c ^Isetf upstreamlog[J

line 977: au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog[J

line 978: au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c ^Isetf usserverlog[J

line 979: au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c ^Isetf usw2kagtlog[J

line 980: [J

line 981: " Ipfilter[J

line 982: au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules^Isetf ipfilter[J

line 983: [J

line 984: " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)[J

line 985: au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl^Isetf fgl[J

line 986: [J

line 987: " .INI file for MSDOS[J

line 988: au BufNewFile,BufRead *.ini^I^I^Isetf dosini[J

line 989: [J

line 990: " SysV Inittab[J

line 991: au BufNewFile,BufRead inittab^I^I^Isetf inittab[J

line 992: [J

line 993: " Inno Setup[J

line 994: au BufNewFile,BufRead *.iss^I^I^Isetf iss[J

line 995: [J

line 996: " J[J

line 997: au BufNewFile,BufRead *.ijs^I^I^Isetf j[J

line 998: [J

line 999: " JAL[J

line 1000: au BufNewFile,BufRead *.jal,*.JAL^I^Isetf jal[J

line 1001: [J

line 1002: " Jam[J

line 1003: au BufNewFile,BufRead *.jpl,*.jpr^I^Isetf jam[J

line 1004: [J

line 1005: " Java[J

line 1006: au BufNewFile,BufRead *.java,*.jav^I^Isetf java[J

line 1007: [J

line 1008: " JavaCC[J

line 1009: au BufNewFile,BufRead *.jj,*.jjt^I^Isetf javacc[J

line 1010: [J

line 1011: " JavaScript, ECMAScript[J

line 1012: au BufNewFile,BufRead *.js,*.javascript,*.es,*.jsx   setf javascript[J

line 1013: [J

line 1014: " Java Server Pages[J

line 1015: au BufNewFile,BufRead *.jsp^I^I^Isetf jsp[J

line 1016: [J

line 1017: " Java Properties resource file (note: doesn't catch font.properties.pl)[J

line 1018: au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??^Isetf jproperties[J

line 1019: au BufNewFile,BufRead *.properties_??_??_*^Icall s:StarSetf('jproperties')[J

line 1020: [J

line 1021: " Jess[J

line 1022: au BufNewFile,BufRead *.clp^I^I^Isetf jess[J

line 1023: [J

line 1024: " Jgraph[J

line 1025: au BufNewFile,BufRead *.jgr^I^I^Isetf jgraph[J

line 1026: [J

line 1027: " Jovial[J

line 1028: au BufNewFile,BufRead *.jov,*.j73,*.jovial^Isetf jovial[J

line 1029: [J

line 1030: " JSON[J

line 1031: au BufNewFile,BufRead *.json,*.jsonp,*.webmanifest^Isetf json[J

line 1032: [J

line 1033: " Kixtart[J

line 1034: au BufNewFile,BufRead *.kix^I^I^Isetf kix[J

line 1035: [J

line 1036: " Kimwitu[++][J

line 1037: au BufNewFile,BufRead *.k^I^I^Isetf kwt[J

line 1038: [J

line 1039: " Kivy[J

line 1040: au BufNewFile,BufRead *.kv^I^I^Isetf kivy[J

line 1041: [J

line 1042: " KDE script[J

line 1043: au BufNewFile,BufRead *.ks^I^I^Isetf kscript[J

line 1044: [J

line 1045: " Kconfig[J

line 1046: au BufNewFile,BufRead Kconfig,Kconfig.debug^Isetf kconfig[J

line 1047: [J

line 1048: " Lace (ISE)[J

line 1049: au BufNewFile,BufRead *.ace,*.ACE^I^Isetf lace[J

line 1050: [J

line 1051: " Latte[J

line 1052: au BufNewFile,BufRead *.latte,*.lte^I^Isetf latte[J

line 1053: [J

line 1054: " Limits[J

line 1055: au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf^Isetf limits[J

line 1056: [J

line 1057: " LambdaProlog (*.mod too, see Modsim)[J

line 1058: au BufNewFile,BufRead *.sig^I^I^Isetf lprolog[J

line 1059: [J

line 1060: " LDAP LDIF[J

line 1061: au BufNewFile,BufRead *.ldif^I^I^Isetf ldif[J

line 1062: [J

line 1063: " Ld loader[J

line 1064: au BufNewFile,BufRead *.ld^I^I^Isetf ld[J

line 1065: [J

line 1066: " Less[J

line 1067: au BufNewFile,BufRead *.less^I^I^Isetf less[J

line 1068: [J

line 1069: " Lex[J

line 1070: au BufNewFile,BufRead *.lex,*.l,*.lxx,*.l++^Isetf lex[J

line 1071: [J

line 1072: " Libao[J

line 1073: au BufNewFile,BufRead */etc/libao.conf,*/.libao^Isetf libao[J

line 1074: [J

line 1075: " Libsensors[J

line 1076: au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf^Isetf sensors[J

line 1077: [J

line 1078: " LFTP[J

line 1079: au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc^Isetf lftp[J

line 1080: [J

line 1081: " Lifelines (or Lex for C++!)[J

line 1082: au BufNewFile,BufRead *.ll^I^I^Isetf lifelines[J

line 1083: [J

line 1084: " Lilo: Linux loader[J

line 1085: au BufNewFile,BufRead lilo.conf^I^I^Isetf lilo[J

line 1086: [J

line 1087: " Lisp (*.el = ELisp, *.cl = Common Lisp, *.jl = librep Lisp)[J

line 1088: if has("fname_case")[J

line 1089:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,*.L,.emacs,.sawfishrc setf lisp[J

line 1090: else[J

line 1091:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,.emacs,.sawfishrc setf lisp[J

line 1092: endif[J

line 1093: [J

line 1094: " SBCL implementation of Common Lisp[J

line 1095: au BufNewFile,BufRead sbclrc,.sbclrc^I^Isetf lisp[J

line 1096: [J

line 1097: " Liquid[J

line 1098: au BufNewFile,BufRead *.liquid^I^I^Isetf liquid[J

line 1099: [J

line 1100: " Lite[J

line 1101: au BufNewFile,BufRead *.lite,*.lt^I^Isetf lite[J

line 1102: [J

line 1103: " LiteStep RC files[J

line 1104: au BufNewFile,BufRead */LiteStep/*/*.rc^I^Isetf litestep[J

line 1105: [J

line 1106: " Login access[J

line 1107: au BufNewFile,BufRead */etc/login.access^Isetf loginaccess[J

line 1108: [J

line 1109: " Login defs[J

line 1110: au BufNewFile,BufRead */etc/login.defs^I^Isetf logindefs[J

line 1111: [J

line 1112: " Logtalk[J

line 1113: au BufNewFile,BufRead *.lgt^I^I^Isetf logtalk[J

line 1114: [J

line 1115: " LOTOS[J

line 1116: au BufNewFile,BufRead *.lot,*.lotos^I^Isetf lotos[J

line 1117: [J

line 1118: " Lout (also: *.lt)[J

line 1119: au BufNewFile,BufRead *.lou,*.lout^I^Isetf lout[J

line 1120: [J

line 1121: " Lua[J

line 1122: au BufNewFile,BufRead *.lua^I^I^Isetf lua[J

line 1123: [J

line 1124: " Luarocks[J

line 1125: au BufNewFile,BufRead *.rockspec^I^Isetf lua[J

line 1126: [J

line 1127: " Linden Scripting Language (Second Life)[J

line 1128: au BufNewFile,BufRead *.lsl^I^I^Isetf lsl[J

line 1129: [J

line 1130: " Lynx style file (or LotusScript!)[J

line 1131: au BufNewFile,BufRead *.lss^I^I^Isetf lss[J

line 1132: [J

line 1133: " M4[J

line 1135: au BufNewFile,BufRead *.m4 if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif[J

line 1136: [J

line 1137: " MaGic Point[J

line 1138: au BufNewFile,BufRead *.mgp^I^I^Isetf mgp[J

line 1139: [J

line 1140: " Mail (for Elm, trn, mutt, muttng, rn, slrn)[J

line 1141: au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail[J

line 1142: [J

line 1143: " Mail aliases[J

line 1144: au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases^Isetf mailaliases[J

line 1145: [J

line 1146: " Mailcap configuration file[J

line 1147: au BufNewFile,BufRead .mailcap,mailcap^I^Isetf mailcap[J

line 1148: [J

line 1149: " Makefile[J

line 1150: au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make[J

line 1151: [J

line 1152: " MakeIndex[J

line 1153: au BufNewFile,BufRead *.ist,*.mst^I^Isetf ist[J

line 1154: [J

line 1155: " Mallard[J

line 1156: au BufNewFile,BufRead *.page^I^I^Isetf mallard[J

line 1157: [J

line 1158: " Manpage[J

line 1159: au BufNewFile,BufRead *.man^I^I^Isetf man[J

line 1160: [J

line 1161: " Man config[J

line 1162: au BufNewFile,BufRead */etc/man.conf,man.config^Isetf manconf[J

line 1163: [J

line 1164: " Maple V[J

line 1165: au BufNewFile,BufRead *.mv,*.mpl,*.mws^I^Isetf maple[J

line 1166: [J

line 1167: " Map (UMN mapserver config file)[J

line 1168: au BufNewFile,BufRead *.map^I^I^Isetf map[J

line 1169: [J

line 1170: " Markdown[J

line 1171: au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,*.md  setf markdown[J

line 1172: [J

line 1173: " Mason[J

line 1174: au BufNewFile,BufRead *.mason,*.mhtml,*.comp^Isetf mason[J

line 1175: [J

line 1176: " Matlab or Objective C[J

line 1177: au BufNewFile,BufRead *.m^I^I^Icall s:FTm()[J

line 1178: [J

line 1179: func! s:FTm()[J

line 1203: [J

line 1204: " Mathematica notebook[J

line 1205: au BufNewFile,BufRead *.nb^I^I^Isetf mma[J

line 1206: [J

line 1207: " Maya Extension Language[J

line 1208: au BufNewFile,BufRead *.mel^I^I^Isetf mel[J

line 1209: [J

line 1210: " Mercurial (hg) commit file[J

line 1211: au BufNewFile,BufRead hg-editor-*.txt^I^Isetf hgcommit[J

line 1212: [J

line 1213: " Mercurial config (looks like generic config file)[J

line 1214: au BufNewFile,BufRead *.hgrc,*hgrc^I^Isetf cfg[J

line 1215: [J

line 1216: " Messages (logs mostly)[J

line 1217: au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages[J

line 1218: [J

line 1219: " Metafont[J

line 1220: au BufNewFile,BufRead *.mf^I^I^Isetf mf[J

line 1221: [J

line 1222: " MetaPost[J

line 1223: au BufNewFile,BufRead *.mp^I^I^Isetf mp[J

line 1224: [J

line 1225: " MGL[J

line 1226: au BufNewFile,BufRead *.mgl^I^I^Isetf mgl[J

line 1227: [J

line 1228: " MIX - Knuth assembly[J

line 1229: au BufNewFile,BufRead *.mix,*.mixal^I^Isetf mix[J

line 1230: [J

line 1231: " MMIX or VMS makefile[J

line 1232: au BufNewFile,BufRead *.mms^I^I^Icall s:FTmms()[J

line 1233: [J

line 1234: " Symbian meta-makefile definition (MMP)[J

line 1235: au BufNewFile,BufRead *.mmp^I^I^Isetf mmp[J

line 1236: [J

line 1237: func! s:FTmms()[J

line 1253: [J

line 1254: [J

line 1255: " Modsim III (or LambdaProlog)[J

line 1261: au BufNewFile,BufRead *.mod if getline(1) =~ '\<module\>' |   setf lprolog | else |   setf modsim3 | endif[J

line 1262: [J

line 1263: " Modula 2  (.md removed in favor of Markdown)[J

line 1264: au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.mi^Isetf modula2[J

line 1265: [J

line 1266: " Modula 3 (.m3, .i3, .mg, .ig)[J

line 1267: au BufNewFile,BufRead *.[mi][3g]^I^Isetf modula3[J

line 1268: [J

line 1269: " Monk[J

line 1270: au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc^Isetf monk[J

line 1271: [J

line 1272: " MOO[J

line 1273: au BufNewFile,BufRead *.moo^I^I^Isetf moo[J

line 1274: [J

line 1275: " Modconf[J

line 1276: au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf[J

line 1277: [J

line 1278: " Mplayer config[J

line 1279: au BufNewFile,BufRead mplayer.conf,*/.mplayer/config^Isetf mplayerconf[J

line 1280: [J

line 1281: " Motorola S record[J

line 1282: au BufNewFile,BufRead *.s19,*.s28,*.s37,*.mot,*.srec^Isetf srec[J

line 1283: [J

line 1284: " Mrxvtrc[J

line 1285: au BufNewFile,BufRead mrxvtrc,.mrxvtrc^I^Isetf mrxvtrc[J

line 1286: [J

line 1287: " Msql[J

line 1288: au BufNewFile,BufRead *.msql^I^I^Isetf msql[J

line 1289: [J

line 1290: " Mysql[J

line 1291: au BufNewFile,BufRead *.mysql^I^I^Isetf mysql[J

line 1292: [J

line 1293: " Mutt setup files (must be before catch *.rc)[J

line 1294: au BufNewFile,BufRead */etc/Muttrc.d/*^I^Icall s:StarSetf('muttrc')[J

line 1295: [J

line 1296: " M$ Resource files[J

line 1297: au BufNewFile,BufRead *.rc,*.rch^I^Isetf rc[J

line 1298: [J

line 1299: " MuPAD source[J

line 1300: au BufRead,BufNewFile *.mu^I^I^Isetf mupad[J

line 1301: [J

line 1302: " Mush[J

line 1303: au BufNewFile,BufRead *.mush^I^I^Isetf mush[J

line 1304: [J

line 1305: " Mutt setup file (also for Muttng)[J

line 1306: au BufNewFile,BufRead Mutt{ng,}rc^I^Isetf muttrc[J

line 1307: [J

line 1308: " Nano[J

line 1309: au BufNewFile,BufRead */etc/nanorc,*.nanorc  ^Isetf nanorc[J

line 1310: [J

line 1311: " Nastran input/DMAP[J

line 1312: "au BufNewFile,BufRead *.dat^I^I^Isetf nastran[J

line 1313: [J

line 1314: " Natural[J

line 1315: au BufNewFile,BufRead *.NS[ACGLMNPS]^I^Isetf natural[J

line 1316: [J

line 1317: " Netrc[J

line 1318: au BufNewFile,BufRead .netrc^I^I^Isetf netrc[J

line 1319: [J

line 1320: " Ninja file[J

line 1321: au BufNewFile,BufRead *.ninja^I^I^Isetf ninja[J

line 1322: [J

line 1323: " Novell netware batch files[J

line 1324: au BufNewFile,BufRead *.ncf^I^I^Isetf ncf[J

line 1325: [J

line 1326: " Nroff/Troff (*.ms and *.t are checked below)[J

line 1330: au BufNewFile,BufRead *.me if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |   setf nroff | endif[J

line 1331: au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom^Isetf nroff[J

line 1332: au BufNewFile,BufRead *.[1-9]^I^I^Icall s:FTnroff()[J

line 1333: [J

line 1334: " This function checks if one of the first five lines start with a dot.  In[J

line 1335: " that case it is probably an nroff file: 'filetype' is set and 1 is returned.[J

line 1336: func! s:FTnroff()[J

line 1343: [J

line 1344: " Nroff or Objective C++[J

line 1345: au BufNewFile,BufRead *.mm^I^I^Icall s:FTmm()[J

line 1346: [J

line 1347: func! s:FTmm()[J

line 1359: [J

line 1360: " Not Quite C[J

line 1361: au BufNewFile,BufRead *.nqc^I^I^Isetf nqc[J

line 1362: [J

line 1363: " NSIS[J

line 1364: au BufNewFile,BufRead *.nsi,*.nsh^I^Isetf nsis[J

line 1365: [J

line 1366: " OCAML[J

line 1367: au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit^Isetf ocaml[J

line 1368: [J

line 1369: " Occam[J

line 1370: au BufNewFile,BufRead *.occ^I^I^Isetf occam[J

line 1371: [J

line 1372: " Omnimark[J

line 1373: au BufNewFile,BufRead *.xom,*.xin^I^Isetf omnimark[J

line 1374: [J

line 1375: " OpenROAD[J

line 1376: au BufNewFile,BufRead *.or^I^I^Isetf openroad[J

line 1377: [J

line 1378: " OPL[J

line 1379: au BufNewFile,BufRead *.[Oo][Pp][Ll]^I^Isetf opl[J

line 1380: [J

line 1381: " Oracle config file[J

line 1382: au BufNewFile,BufRead *.ora^I^I^Isetf ora[J

line 1383: [J

line 1384: " Packet filter conf[J

line 1385: au BufNewFile,BufRead pf.conf^I^I^Isetf pf[J

line 1386: [J

line 1387: " Pam conf[J

line 1388: au BufNewFile,BufRead */etc/pam.conf^I^Isetf pamconf[J

line 1389: [J

line 1390: " PApp[J

line 1391: au BufNewFile,BufRead *.papp,*.pxml,*.pxsl^Isetf papp[J

line 1392: [J

line 1393: " Password file[J

line 1394: au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd[J

line 1395: [J

line 1396: " Pascal (also *.p)[J

line 1397: au BufNewFile,BufRead *.pas^I^I^Isetf pascal[J

line 1398: [J

line 1399: " Delphi project file[J

line 1400: au BufNewFile,BufRead *.dpr^I^I^Isetf pascal[J

line 1401: [J

line 1402: " PDF[J

line 1403: au BufNewFile,BufRead *.pdf^I^I^Isetf pdf[J

line 1404: [J

line 1405: " Perl[J

line 1406: if has("fname_case")[J

line 1407:   au BufNewFile,BufRead *.pl,*.PL^I^Icall s:FTpl()[J

line 1408: else[J

line 1409:   au BufNewFile,BufRead *.pl^I^I^Icall s:FTpl()[J

line 1410: endif[J

line 1411: au BufNewFile,BufRead *.plx,*.al^I^Isetf perl[J

line 1412: au BufNewFile,BufRead *.p6,*.pm6,*.pl6^I^Isetf perl6[J

line 1413: [J

line 1414: func! s:FTpl()[J

line 1428: [J

line 1429: " Perl, XPM or XPM2[J

line 1437: au BufNewFile,BufRead *.pm if getline(1) =~ "XPM2" |   setf xpm2 | elseif getline(1) =~ "XPM" |   setf xpm | else |   setf perl | endif[J

line 1438: [J

line 1439: " Perl POD[J

line 1440: au BufNewFile,BufRead *.pod^I^I^Isetf pod[J

line 1441: au BufNewFile,BufRead *.pod6^I^I^Isetf pod6[J

line 1442: [J

line 1443: " Php, php3, php4, etc.[J

line 1444: " Also Phtml (was used for PHP 2 in the past)[J

line 1445: " Also .ctp for Cake template file[J

line 1446: au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp^Isetf php[J

line 1447: [J

line 1448: " Pike[J

line 1449: au BufNewFile,BufRead *.pike,*.lpc,*.ulpc,*.pmod setf pike[J

line 1450: [J

line 1451: " Pinfo config[J

line 1452: au BufNewFile,BufRead */etc/pinforc,*/.pinforc^Isetf pinfo[J

line 1453: [J

line 1454: " Palm Resource compiler[J

line 1455: au BufNewFile,BufRead *.rcp^I^I^Isetf pilrc[J

line 1456: [J

line 1457: " Pine config[J

line 1458: au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex^I^Isetf pine[J

line 1459: [J

line 1460: " PL/1, PL/I[J

line 1461: au BufNewFile,BufRead *.pli,*.pl1^I^Isetf pli[J

line 1462: [J

line 1463: " PL/M (also: *.inp)[J

line 1464: au BufNewFile,BufRead *.plm,*.p36,*.pac^I^Isetf plm[J

line 1465: [J

line 1466: " PL/SQL[J

line 1467: au BufNewFile,BufRead *.pls,*.plsql^I^Isetf plsql[J

line 1468: [J

line 1469: " PLP[J

line 1470: au BufNewFile,BufRead *.plp^I^I^Isetf plp[J

line 1471: [J

line 1472: " PO and PO template (GNU gettext)[J

line 1473: au BufNewFile,BufRead *.po,*.pot^I^Isetf po[J

line 1474: [J

line 1475: " Postfix main config[J

line 1476: au BufNewFile,BufRead main.cf^I^I^Isetf pfmain[J

line 1477: [J

line 1478: " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)[J

line 1479: au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai^I  setf postscr[J

line 1480: [J

line 1481: " PostScript Printer Description[J

line 1482: au BufNewFile,BufRead *.ppd^I^I^Isetf ppd[J

line 1483: [J

line 1484: " Povray[J

line 1485: au BufNewFile,BufRead *.pov^I^I^Isetf pov[J

line 1486: [J

line 1487: " Povray configuration[J

line 1488: au BufNewFile,BufRead .povrayrc^I^I^Isetf povini[J

line 1489: [J

line 1490: " Povray, PHP or assembly[J

line 1491: au BufNewFile,BufRead *.inc^I^I^Icall s:FTinc()[J

line 1492: [J

line 1493: func! s:FTinc()[J

line 1514: [J

line 1515: " Printcap and Termcap[J

line 1517: au BufNewFile,BufRead *printcap let b:ptcap_type = "print" | setf ptcap[J

line 1519: au BufNewFile,BufRead *termcap let b:ptcap_type = "term" | setf ptcap[J

line 1520: [J

line 1521: " PCCTS / ANTRL[J

line 1522: "au BufNewFile,BufRead *.g^I^I^Isetf antrl[J

line 1523: au BufNewFile,BufRead *.g^I^I^Isetf pccts[J

line 1524: [J

line 1525: " PPWizard[J

line 1526: au BufNewFile,BufRead *.it,*.ih^I^I^Isetf ppwiz[J

line 1527: [J

line 1528: " Obj 3D file format[J

line 1529: " TODO: is there a way to avoid MS-Windows Object files?[J

line 1530: au BufNewFile,BufRead *.obj^I^I^Isetf obj[J

line 1531: [J

line 1532: " Oracle Pro*C/C++[J

line 1533: au BufNewFile,BufRead *.pc^I^I^Isetf proc[J

line 1534: [J

line 1535: " Privoxy actions file[J

line 1536: au BufNewFile,BufRead *.action^I^I^Isetf privoxy[J

line 1537: [J

line 1538: " Procmail[J

line 1539: au BufNewFile,BufRead .procmail,.procmailrc^Isetf procmail[J

line 1540: [J

line 1541: " Progress or CWEB[J

line 1542: au BufNewFile,BufRead *.w^I^I^Icall s:FTprogress_cweb()[J

line 1543: [J

line 1544: func! s:FTprogress_cweb()[J

line 1555: [J

line 1556: " Progress or assembly[J

line 1557: au BufNewFile,BufRead *.i^I^I^Icall s:FTprogress_asm()[J

line 1558: [J

line 1559: func! s:FTprogress_asm()[J

line 1581: [J

line 1582: " Progress or Pascal[J

line 1583: au BufNewFile,BufRead *.p^I^I^Icall s:FTprogress_pascal()[J

line 1584: [J

line 1585: func! s:FTprogress_pascal()[J

line 1609: [J

line 1610: [J

line 1611: " Software Distributor Product Specification File (POSIX 1387.2-1995)[J

line 1612: au BufNewFile,BufRead *.psf^I^I^Isetf psf[J

line 1616: au BufNewFile,BufRead INDEX,INFO if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |   setf psf | endif[J

line 1617: [J

line 1618: " Prolog[J

line 1619: au BufNewFile,BufRead *.pdb^I^I^Isetf prolog[J

line 1620: [J

line 1621: " Promela[J

line 1622: au BufNewFile,BufRead *.pml^I^I^Isetf promela[J

line 1623: [J

line 1624: " Google protocol buffers[J

line 1625: au BufNewFile,BufRead *.proto^I^I^Isetf proto[J

line 1626: [J

line 1627: " Protocols[J

line 1628: au BufNewFile,BufRead */etc/protocols^I^Isetf protocols[J

line 1629: [J

line 1630: " Pyrex[J

line 1631: au BufNewFile,BufRead *.pyx,*.pxd^I^Isetf pyrex[J

line 1632: [J

line 1633: " Python, Python Shell Startup Files[J

line 1634: " Quixote (Python-based web framework)[J

line 1635: au BufNewFile,BufRead *.py,*.pyw,.pythonstartup,.pythonrc,*.ptl  setf python[J

line 1636: [J

line 1637: " Radiance[J

line 1638: au BufNewFile,BufRead *.rad,*.mat^I^Isetf radiance[J

line 1639: [J

line 1640: " Ratpoison config/command files[J

line 1641: au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc^Isetf ratpoison[J

line 1642: [J

line 1643: " RCS file[J

line 1644: au BufNewFile,BufRead *\,v^I^I^Isetf rcs[J

line 1645: [J

line 1646: " Readline[J

line 1647: au BufNewFile,BufRead .inputrc,inputrc^I^Isetf readline[J

line 1648: [J

line 1649: " Registry for MS-Windows[J

line 1651: au BufNewFile,BufRead *.reg if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif[J

line 1652: [J

line 1653: " Renderman Interface Bytestream[J

line 1654: au BufNewFile,BufRead *.rib^I^I^Isetf rib[J

line 1655: [J

line 1656: " Rexx[J

line 1657: au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit^Isetf rexx[J

line 1658: [J

line 1659: " R (Splus)[J

line 1660: if has("fname_case")[J

line 1661:   au BufNewFile,BufRead *.s,*.S^I^I^Isetf r[J

line 1662: else[J

line 1663:   au BufNewFile,BufRead *.s^I^I^Isetf r[J

line 1664: endif[J

line 1665: [J

line 1666: " R Help file[J

line 1667: if has("fname_case")[J

line 1668:   au BufNewFile,BufRead *.rd,*.Rd^I^Isetf rhelp[J

line 1669: else[J

line 1670:   au BufNewFile,BufRead *.rd^I^I^Isetf rhelp[J

line 1671: endif[J

line 1672: [J

line 1673: " R noweb file[J

line 1674: if has("fname_case")[J

line 1675:   au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw^I^Isetf rnoweb[J

line 1676: else[J

line 1677:   au BufNewFile,BufRead *.rnw,*.snw^I^I^Isetf rnoweb[J

line 1678: endif[J

line 1679: [J

line 1680: " R Markdown file[J

line 1681: if has("fname_case")[J

line 1682:   au BufNewFile,BufRead *.Rmd,*.rmd,*.Smd,*.smd^I^Isetf rmd[J

line 1683: else[J

line 1684:   au BufNewFile,BufRead *.rmd,*.smd^I^I^Isetf rmd[J

line 1685: endif[J

line 1686: [J

line 1687: " R reStructuredText file[J

line 1688: if has("fname_case")[J

line 1689:   au BufNewFile,BufRead *.Rrst,*.rrst,*.Srst,*.srst^Isetf rrst[J

line 1690: else[J

line 1691:   au BufNewFile,BufRead *.rrst,*.srst^I^I^Isetf rrst[J

line 1692: endif[J

line 1693: [J

line 1694: " Rexx, Rebol or R[J

line 1695: au BufNewFile,BufRead *.r,*.R^I^I^Icall s:FTr()[J

line 1696: [J

line 1697: func! s:FTr()[J

line 1729: [J

line 1730: " Remind[J

line 1731: au BufNewFile,BufRead .reminders,*.remind,*.rem^I^Isetf remind[J

line 1732: [J

line 1733: " Resolv.conf[J

line 1734: au BufNewFile,BufRead resolv.conf^I^Isetf resolv[J

line 1735: [J

line 1736: " Relax NG Compact[J

line 1737: au BufNewFile,BufRead *.rnc^I^I^Isetf rnc[J

line 1738: [J

line 1739: " Relax NG XML[J

line 1740: au BufNewFile,BufRead *.rng^I^I^Isetf rng[J

line 1741: [J

line 1742: " RPL/2[J

line 1743: au BufNewFile,BufRead *.rpl^I^I^Isetf rpl[J

line 1744: [J

line 1745: " Robots.txt[J

line 1746: au BufNewFile,BufRead robots.txt^I^Isetf robots[J

line 1747: [J

line 1748: " Rpcgen[J

line 1749: au BufNewFile,BufRead *.x^I^I^Isetf rpcgen[J

line 1750: [J

line 1751: " reStructuredText Documentation Format[J

line 1752: au BufNewFile,BufRead *.rst^I^I^Isetf rst[J

line 1753: [J

line 1754: " RTF[J

line 1755: au BufNewFile,BufRead *.rtf^I^I^Isetf rtf[J

line 1756: [J

line 1757: " Interactive Ruby shell[J

line 1758: au BufNewFile,BufRead .irbrc,irbrc^I^Isetf ruby[J

line 1759: [J

line 1760: " Ruby[J

line 1761: au BufNewFile,BufRead *.rb,*.rbw^I^Isetf ruby[J

line 1762: [J

line 1763: " RubyGems[J

line 1764: au BufNewFile,BufRead *.gemspec^I^I^Isetf ruby[J

line 1765: [J

line 1766: " Rust[J

line 1767: au BufNewFile,BufRead *.rs^I^I^Isetf rust[J

line 1768: [J

line 1769: " Rackup[J

line 1770: au BufNewFile,BufRead *.ru^I^I^Isetf ruby[J

line 1771: [J

line 1772: " Bundler[J

line 1773: au BufNewFile,BufRead Gemfile^I^I^Isetf ruby[J

line 1774: [J

line 1775: " Ruby on Rails[J

line 1776: au BufNewFile,BufRead *.builder,*.rxml,*.rjs^Isetf ruby[J

line 1777: [J

line 1778: " Rantfile and Rakefile is like Ruby[J

line 1779: au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake^Isetf ruby[J

line 1780: [J

line 1781: " S-lang (or shader language, or SmallLisp)[J

line 1782: au BufNewFile,BufRead *.sl^I^I^Isetf slang[J

line 1783: [J

line 1784: " Samba config[J

line 1785: au BufNewFile,BufRead smb.conf^I^I^Isetf samba[J

line 1786: [J

line 1787: " SAS script[J

line 1788: au BufNewFile,BufRead *.sas^I^I^Isetf sas[J

line 1789: [J

line 1790: " Sass[J

line 1791: au BufNewFile,BufRead *.sass^I^I^Isetf sass[J

line 1792: [J

line 1793: " Sather[J

line 1794: au BufNewFile,BufRead *.sa^I^I^Isetf sather[J

line 1795: [J

line 1796: " Scala[J

line 1797: au BufNewFile,BufRead *.scala^I^I^Isetf scala[J

line 1798: [J

line 1799: " Scilab[J

line 1800: au BufNewFile,BufRead *.sci,*.sce^I^Isetf scilab[J

line 1801: [J

line 1802: " SCSS[J

line 1803: au BufNewFile,BufRead *.scss^I^I^Isetf scss[J

line 1804: [J

line 1805: " SD: Streaming Descriptors[J

line 1806: au BufNewFile,BufRead *.sd^I^I^Isetf sd[J

line 1807: [J

line 1808: " SDL[J

line 1809: au BufNewFile,BufRead *.sdl,*.pr^I^Isetf sdl[J

line 1810: [J

line 1811: " sed[J

line 1812: au BufNewFile,BufRead *.sed^I^I^Isetf sed[J

line 1813: [J

line 1814: " Sieve (RFC 3028)[J

line 1815: au BufNewFile,BufRead *.siv^I^I^Isetf sieve[J

line 1816: [J

line 1817: " Sendmail[J

line 1818: au BufNewFile,BufRead sendmail.cf^I^Isetf sm[J

line 1819: [J

line 1820: " Sendmail .mc files are actually m4.  Could also be MS Message text file.[J

line 1821: au BufNewFile,BufRead *.mc^I^I^Icall s:McSetf()[J

line 1822: [J

line 1823: func! s:McSetf()[J

line 1838: [J

line 1839: " Services[J

line 1840: au BufNewFile,BufRead */etc/services^I^Isetf services[J

line 1841: [J

line 1842: " Service Location config[J

line 1843: au BufNewFile,BufRead */etc/slp.conf^I^Isetf slpconf[J

line 1844: [J

line 1845: " Service Location registration[J

line 1846: au BufNewFile,BufRead */etc/slp.reg^I^Isetf slpreg[J

line 1847: [J

line 1848: " Service Location SPI[J

line 1849: au BufNewFile,BufRead */etc/slp.spi^I^Isetf slpspi[J

line 1850: [J

line 1851: " Setserial config[J

line 1852: au BufNewFile,BufRead */etc/serial.conf^I^Isetf setserial[J

line 1853: [J

line 1854: " SGML[J

line 1864: au BufNewFile,BufRead *.sgm,*.sgml if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |   setf sgmllnx | elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |   let b:docbk_type = "sgml" |   let b:docbk_ver = 4 |   setf docbk | else |   setf sgml | endif[J

line 1865: [J

line 1866: " SGMLDECL[J

line 1870: au BufNewFile,BufRead *.decl,*.dcl,*.dec if getline(1).getline(2).getline(3) =~? '^<!SGML' |    setf sgmldecl | endif[J

line 1871: [J

line 1872: " SGML catalog file[J

line 1873: au BufNewFile,BufRead catalog^I^I^Isetf catalog[J

line 1874: au BufNewFile,BufRead sgml.catalog*^I^Icall s:StarSetf('catalog')[J

line 1875: [J

line 1876: " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.[J

line 1877: " Gentoo ebuilds and Arch Linux PKGBUILDs are actually bash scripts[J

line 1878: au BufNewFile,BufRead .bashrc*,bashrc,bash.bashrc,.bash[_-]profile*,.bash[_-]logout*,.bash[_-]aliases*,*.bash,*/{,.}bash[_-]completion{,.d,.sh}{,/*},*.ebuild,*.eclass,PKGBUILD* call SetFileTypeSH("bash")[J

line 1879: au BufNewFile,BufRead .kshrc*,*.ksh call SetFileTypeSH("ksh")[J

line 1880: au BufNewFile,BufRead */etc/profile,.profile*,*.sh,*.env call SetFileTypeSH(getline(1))[J

line 1881: [J

line 1882: " Shell script (Arch Linux) or PHP file (Drupal)[J

line 1888: au BufNewFile,BufRead *.install if getline(1) =~ '<?php' |   setf php | else |   call SetFileTypeSH("bash") | endif[J

line 1889: [J

line 1890: " Also called from scripts.vim.[J

line 1891: func! SetFileTypeSH(name)[J

line 1934: [J

line 1935: " For shell-like file types, check for an "exec" command hidden in a comment,[J

line 1936: " as used for Tcl.[J

line 1937: " Also called from scripts.vim, thus can't be local to this script.[J

line 1938: func! SetFileTypeShell(name)[J

line 1957: [J

line 1958: " tcsh scripts[J

line 1959: au BufNewFile,BufRead .tcshrc*,*.tcsh,tcsh.tcshrc,tcsh.login^Icall SetFileTypeShell("tcsh")[J

line 1960: [J

line 1961: " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)[J

line 1962: au BufNewFile,BufRead .login*,.cshrc*,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call s:CSH()[J

line 1963: [J

line 1964: func! s:CSH()[J

line 1973: [J

line 1974: " Z-Shell script[J

line 1975: au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh[J

line 1976: au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')[J

line 1977: au BufNewFile,BufRead *.zsh^I^I^Isetf zsh[J

line 1978: [J

line 1979: " Scheme[J

line 1980: au BufNewFile,BufRead *.scm,*.ss,*.rkt^I^Isetf scheme[J

line 1981: [J

line 1982: " Screen RC[J

line 1983: au BufNewFile,BufRead .screenrc,screenrc^Isetf screen[J

line 1984: [J

line 1985: " Simula[J

line 1986: au BufNewFile,BufRead *.sim^I^I^Isetf simula[J

line 1987: [J

line 1988: " SINDA[J

line 1989: au BufNewFile,BufRead *.sin,*.s85^I^Isetf sinda[J

line 1990: [J

line 1991: " SiSU[J

line 1992: au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu[J

line 1993: au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu[J

line 1994: [J

line 1995: " SKILL[J

line 1996: au BufNewFile,BufRead *.il,*.ils,*.cdf^I^Isetf skill[J

line 1997: [J

line 1998: " SLRN[J

line 1999: au BufNewFile,BufRead .slrnrc^I^I^Isetf slrnrc[J

line 2000: au BufNewFile,BufRead *.score^I^I^Isetf slrnsc[J

line 2001: [J

line 2002: " Smalltalk (and TeX)[J

line 2003: au BufNewFile,BufRead *.st^I^I^Isetf st[J

line 2011: au BufNewFile,BufRead *.cls if getline(1) =~ '^%' |  setf tex | elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |  setf rexx | else |  setf st | endif[J

line 2012: [J

line 2013: " Smarty templates[J

line 2014: au BufNewFile,BufRead *.tpl^I^I^Isetf smarty[J

line 2015: [J

line 2016: " SMIL or XML[J

line 2022: au BufNewFile,BufRead *.smil if getline(1) =~ '<?\s*xml.*?>' |   setf xml | else |   setf smil | endif[J

line 2023: [J

line 2024: " SMIL or SNMP MIB file[J

line 2030: au BufNewFile,BufRead *.smi if getline(1) =~ '\<smil\>' |   setf smil | else |   setf mib | endif[J

line 2031: [J

line 2032: " SMITH[J

line 2033: au BufNewFile,BufRead *.smt,*.smith^I^Isetf smith[J

line 2034: [J

line 2035: " Snobol4 and spitbol[J

line 2036: au BufNewFile,BufRead *.sno,*.spt^I^Isetf snobol4[J

line 2037: [J

line 2038: " SNMP MIB files[J

line 2039: au BufNewFile,BufRead *.mib,*.my^I^Isetf mib[J

line 2040: [J

line 2041: " Snort Configuration[J

line 2042: au BufNewFile,BufRead *.hog,snort.conf,vision.conf^Isetf hog[J

line 2043: au BufNewFile,BufRead *.rules^I^I^Icall s:FTRules()[J

line 2044: [J

line 2045: let s:ft_rules_udev_rules_pattern = '^\s*\cudev_rules\s*=\s*"\([^"]\{-1,}\)/*".*'[J

line 2046: func! s:FTRules()[J

line 2078: [J

line 2079: [J

line 2080: " Spec (Linux RPM)[J

line 2081: au BufNewFile,BufRead *.spec^I^I^Isetf spec[J

line 2082: [J

line 2083: " Speedup (AspenTech plant simulator)[J

line 2084: au BufNewFile,BufRead *.speedup,*.spdata,*.spd^Isetf spup[J

line 2085: [J

line 2086: " Slice[J

line 2087: au BufNewFile,BufRead *.ice^I^I^Isetf slice[J

line 2088: [J

line 2089: " Spice[J

line 2090: au BufNewFile,BufRead *.sp,*.spice^I^Isetf spice[J

line 2091: [J

line 2092: " Spyce[J

line 2093: au BufNewFile,BufRead *.spy,*.spi^I^Isetf spyce[J

line 2094: [J

line 2095: " Squid[J

line 2096: au BufNewFile,BufRead squid.conf^I^Isetf squid[J

line 2097: [J

line 2098: " SQL for Oracle Designer[J

line 2099: au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks^Isetf sql[J

line 2100: [J

line 2101: " SQL[J

line 2102: au BufNewFile,BufRead *.sql^I^I^Icall s:SQL()[J

line 2103: [J

line 2104: func! s:SQL()[J

line 2111: [J

line 2112: " SQLJ[J

line 2113: au BufNewFile,BufRead *.sqlj^I^I^Isetf sqlj[J

line 2114: [J

line 2115: " SQR[J

line 2116: au BufNewFile,BufRead *.sqr,*.sqi^I^Isetf sqr[J

line 2117: [J

line 2118: " OpenSSH configuration[J

line 2119: au BufNewFile,BufRead ssh_config,*/.ssh/config^Isetf sshconfig[J

line 2120: [J

line 2121: " OpenSSH server configuration[J

line 2122: au BufNewFile,BufRead sshd_config^I^Isetf sshdconfig[J

line 2123: [J

line 2124: " Stata[J

line 2125: au BufNewFile,BufRead *.ado,*.class,*.do,*.imata,*.mata   setf stata[J

line 2126: [J

line 2127: " SMCL[J

line 2128: au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl^Isetf smcl[J

line 2129: [J

line 2130: " Stored Procedures[J

line 2131: au BufNewFile,BufRead *.stp^I^I^Isetf stp[J

line 2132: [J

line 2133: " Standard ML[J

line 2134: au BufNewFile,BufRead *.sml^I^I^Isetf sml[J

line 2135: [J

line 2136: " Sratus VOS command macro[J

line 2137: au BufNewFile,BufRead *.cm^I^I^Isetf voscm[J

line 2138: [J

line 2139: " Sysctl[J

line 2140: au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf^Isetf sysctl[J

line 2141: [J

line 2142: " Systemd unit files[J

line 2143: au BufNewFile,BufRead */systemd/*.{automount,mount,path,service,socket,swap,target,timer}^Isetf systemd[J

line 2144: [J

line 2145: " Synopsys Design Constraints[J

line 2146: au BufNewFile,BufRead *.sdc^I^I^Isetf sdc[J

line 2147: [J

line 2148: " Sudoers[J

line 2149: au BufNewFile,BufRead */etc/sudoers,sudoers.tmp^Isetf sudoers[J

line 2150: [J

line 2151: " SVG (Scalable Vector Graphics)[J

line 2152: au BufNewFile,BufRead *.svg^I^I^Isetf svg[J

line 2153: [J

line 2154: " If the file has an extension of 't' and is in a directory 't' or 'xt' then[J

line 2155: " it is almost certainly a Perl test file.[J

line 2156: " If the first line starts with '#' and contains 'perl' it's probably a Perl[J

line 2157: " file.[J

line 2158: " (Slow test) If a file contains a 'use' statement then it is almost certainly[J

line 2159: " a Perl file.[J

line 2160: func! s:FTperl()[J

line 2176: [J

line 2177: " Tads (or Nroff or Perl test file)[J

line 2179: au BufNewFile,BufRead *.t if !s:FTnroff() && !s:FTperl() | setf tads | endif[J

line 2180: [J

line 2181: " Tags[J

line 2182: au BufNewFile,BufRead tags^I^I^Isetf tags[J

line 2183: [J

line 2184: " TAK[J

line 2185: au BufNewFile,BufRead *.tak^I^I^Isetf tak[J

line 2186: [J

line 2187: " Task[J

line 2188: au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata[J

line 2189: au BufRead,BufNewFile *.task^I^I^Isetf taskedit[J

line 2190: [J

line 2191: " Tcl (JACL too)[J

line 2192: au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl^Isetf tcl[J

line 2193: [J

line 2194: " TealInfo[J

line 2195: au BufNewFile,BufRead *.tli^I^I^Isetf tli[J

line 2196: [J

line 2197: " Telix Salt[J

line 2198: au BufNewFile,BufRead *.slt^I^I^Isetf tsalt[J

line 2199: [J

line 2200: " Tera Term Language[J

line 2201: au BufRead,BufNewFile *.ttl^I^I^Isetf teraterm[J

line 2202: [J

line 2203: " Terminfo[J

line 2204: au BufNewFile,BufRead *.ti^I^I^Isetf terminfo[J

line 2205: [J

line 2206: " TeX[J

line 2207: au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl^Isetf tex[J

line 2208: au BufNewFile,BufRead *.tex^I^I^Icall s:FTtex()[J

line 2209: [J

line 2210: " Choose context, plaintex, or tex (LaTeX) based on these rules:[J

line 2211: " 1. Check the first line of the file for "%&<format>".[J

line 2212: " 2. Check the first 1000 non-comment lines for LaTeX or ConTeXt keywords.[J

line 2213: " 3. Default to "latex" or to g:tex_flavor, can be set in user's vimrc.[J

line 2214: func! s:FTtex()[J

line 2261: [J

line 2262: " ConTeXt[J

line 2263: au BufNewFile,BufRead tex/context/*/*.tex,*.mkii,*.mkiv,*.mkvi   setf context[J

line 2264: [J

line 2265: " Texinfo[J

line 2266: au BufNewFile,BufRead *.texinfo,*.texi,*.txi^Isetf texinfo[J

line 2267: [J

line 2268: " TeX configuration[J

line 2269: au BufNewFile,BufRead texmf.cnf^I^I^Isetf texmf[J

line 2270: [J

line 2271: " Tidy config[J

line 2272: au BufNewFile,BufRead .tidyrc,tidyrc^I^Isetf tidy[J

line 2273: [J

line 2274: " TF mud client[J

line 2275: au BufNewFile,BufRead *.tf,.tfrc,tfrc^I^Isetf tf[J

line 2276: [J

line 2277: " TPP - Text Presentation Program[J

line 2278: au BufNewFile,BufReadPost *.tpp^I^I^Isetf tpp[J

line 2279: [J

line 2280: " Treetop[J

line 2281: au BufRead,BufNewFile *.treetop^I^I^Isetf treetop[J

line 2282: [J

line 2283: " Trustees[J

line 2284: au BufNewFile,BufRead trustees.conf^I^Isetf trustees[J

line 2285: [J

line 2286: " TSS - Geometry[J

line 2287: au BufNewFile,BufReadPost *.tssgm^I^Isetf tssgm[J

line 2288: [J

line 2289: " TSS - Optics[J

line 2290: au BufNewFile,BufReadPost *.tssop^I^Isetf tssop[J

line 2291: [J

line 2292: " TSS - Command Line (temporary)[J

line 2293: au BufNewFile,BufReadPost *.tsscl^I^Isetf tsscl[J

line 2294: [J

line 2295: " TWIG files[J

line 2296: au BufNewFile,BufReadPost *.twig^I^Isetf twig[J

line 2297: [J

line 2298: " Motif UIT/UIL files[J

line 2299: au BufNewFile,BufRead *.uit,*.uil^I^Isetf uil[J

line 2300: [J

line 2301: " Udev conf[J

line 2302: au BufNewFile,BufRead */etc/udev/udev.conf^Isetf udevconf[J

line 2303: [J

line 2304: " Udev permissions[J

line 2305: au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm[J

line 2306: "[J

line 2307: " Udev symlinks config[J

line 2308: au BufNewFile,BufRead */etc/udev/cdsymlinks.conf^Isetf sh[J

line 2309: [J

line 2310: " UnrealScript[J

line 2311: au BufNewFile,BufRead *.uc^I^I^Isetf uc[J

line 2312: [J

line 2313: " Updatedb[J

line 2314: au BufNewFile,BufRead */etc/updatedb.conf^Isetf updatedb[J

line 2315: [J

line 2316: " Upstart (init(8)) config files[J

line 2317: au BufNewFile,BufRead */usr/share/upstart/*.conf^I       setf upstart[J

line 2318: au BufNewFile,BufRead */usr/share/upstart/*.override^I       setf upstart[J

line 2319: au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart[J

line 2320: au BufNewFile,BufRead */.init/*.conf,*/.init/*.override^I       setf upstart[J

line 2321: au BufNewFile,BufRead */.config/upstart/*.conf^I^I       setf upstart[J

line 2322: au BufNewFile,BufRead */.config/upstart/*.override^I       setf upstart[J

line 2323: [J

line 2324: " Vera[J

line 2325: au BufNewFile,BufRead *.vr,*.vri,*.vrh^I^Isetf vera[J

line 2326: [J

line 2327: " Verilog HDL[J

line 2328: au BufNewFile,BufRead *.v^I^I^Isetf verilog[J

line 2329: [J

line 2330: " Verilog-AMS HDL[J

line 2331: au BufNewFile,BufRead *.va,*.vams^I^Isetf verilogams[J

line 2332: [J

line 2333: " SystemVerilog[J

line 2334: au BufNewFile,BufRead *.sv,*.svh^I^Isetf systemverilog[J

line 2335: [J

line 2336: " VHDL[J

line 2337: au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl[J

line 2338: au BufNewFile,BufRead *.vhdl_[0-9]*^I^Icall s:StarSetf('vhdl')[J

line 2339: [J

line 2340: " Vim script[J

line 2341: au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc^Isetf vim[J

line 2342: [J

line 2343: " Viminfo file[J

line 2344: au BufNewFile,BufRead .viminfo,_viminfo^I^Isetf viminfo[J

line 2345: [J

line 2346: " Virata Config Script File or Drupal module[J

line 2352: au BufRead,BufNewFile *.hw,*.module,*.pkg if getline(1) =~ '<?php' |   setf php | else |   setf virata | endif[J

line 2353: [J

line 2354: " Visual Basic (also uses *.bas) or FORM[J

line 2355: au BufNewFile,BufRead *.frm^I^I^Icall s:FTVB("form")[J

line 2356: [J

line 2357: " SaxBasic is close to Visual Basic[J

line 2358: au BufNewFile,BufRead *.sba^I^I^Isetf vb[J

line 2359: [J

line 2360: " Vgrindefs file[J

line 2361: au BufNewFile,BufRead vgrindefs^I^I^Isetf vgrindefs[J

line 2362: [J

line 2363: " VRML V1.0c[J

line 2364: au BufNewFile,BufRead *.wrl^I^I^Isetf vrml[J

line 2365: [J

line 2366: " Vroom (vim testing and executable documentation)[J

line 2367: au BufNewFile,BufRead *.vroom^I^I^Isetf vroom[J

line 2368: [J

line 2369: " Webmacro[J

line 2370: au BufNewFile,BufRead *.wm^I^I^Isetf webmacro[J

line 2371: [J

line 2372: " Wget config[J

line 2373: au BufNewFile,BufRead .wgetrc,wgetrc^I^Isetf wget[J

line 2374: [J

line 2375: " Website MetaLanguage[J

line 2376: au BufNewFile,BufRead *.wml^I^I^Isetf wml[J

line 2377: [J

line 2378: " Winbatch[J

line 2379: au BufNewFile,BufRead *.wbt^I^I^Isetf winbatch[J

line 2380: [J

line 2381: " WSML[J

line 2382: au BufNewFile,BufRead *.wsml^I^I^Isetf wsml[J

line 2383: [J

line 2384: " WvDial[J

line 2385: au BufNewFile,BufRead wvdial.conf,.wvdialrc^Isetf wvdial[J

line 2386: [J

line 2387: " CVS RC file[J

line 2388: au BufNewFile,BufRead .cvsrc^I^I^Isetf cvsrc[J

line 2389: [J

line 2390: " CVS commit file[J

line 2391: au BufNewFile,BufRead cvs\d\+^I^I^Isetf cvs[J

line 2392: [J

line 2393: " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment[J

line 2394: " lines in a WEB file).[J

line 2400: au BufNewFile,BufRead *.web if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |   setf web | else |   setf winbatch | endif[J

line 2401: [J

line 2402: " Windows Scripting Host and Windows Script Component[J

line 2403: au BufNewFile,BufRead *.ws[fc]^I^I^Isetf wsh[J

line 2404: [J

line 2405: " XHTML[J

line 2406: au BufNewFile,BufRead *.xhtml,*.xht^I^Isetf xhtml[J

line 2407: [J

line 2408: " X Pixmap (dynamically sets colors, use BufEnter to make it work better)[J

line 2414: au BufEnter *.xpm if getline(1) =~ "XPM2" |   setf xpm2 | else |   setf xpm | endif[J

line 2415: au BufEnter *.xpm2^I^I^I^Isetf xpm2[J

line 2416: [J

line 2417: " XFree86 config[J

line 2422: au BufNewFile,BufRead XF86Config if getline(1) =~ '\<XConfigurator\>' |   let b:xf86conf_xfree86_version = 3 | endif | setf xf86conf[J

line 2425: au BufNewFile,BufRead */xorg.conf.d/*.conf let b:xf86conf_xfree86_version = 4 | setf xf86conf[J

line 2426: [J

line 2427: " Xorg config[J

line 2428: au BufNewFile,BufRead xorg.conf,xorg.conf-4^Ilet b:xf86conf_xfree86_version = 4 | setf xf86conf[J

line 2429: [J

line 2430: " Xinetd conf[J

line 2431: au BufNewFile,BufRead */etc/xinetd.conf^I^Isetf xinetd[J

line 2432: [J

line 2433: " XS Perl extension interface language[J

line 2434: au BufNewFile,BufRead *.xs^I^I^Isetf xs[J

line 2435: [J

line 2436: " X resources file[J

line 2437: au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults[J

line 2438: [J

line 2439: " Xmath[J

line 2440: au BufNewFile,BufRead *.msc,*.msf^I^Isetf xmath[J

line 2442: au BufNewFile,BufRead *.ms if !s:FTnroff() | setf xmath | endif[J

line 2443: [J

line 2444: " XML  specific variants: docbk and xbl[J

line 2445: au BufNewFile,BufRead *.xml^I^I^Icall s:FTxml()[J

line 2446: [J

line 2447: func! s:FTxml()[J

line 2472: [J

line 2473: " XMI (holding UML models) is also XML[J

line 2474: au BufNewFile,BufRead *.xmi^I^I^Isetf xml[J

line 2475: [J

line 2476: " CSPROJ files are Visual Studio.NET's XML-based project config files[J

line 2477: au BufNewFile,BufRead *.csproj,*.csproj.user^Isetf xml[J

line 2478: [J

line 2479: " Qt Linguist translation source and Qt User Interface Files are XML[J

line 2480: au BufNewFile,BufRead *.ts,*.ui^I^I^Isetf xml[J

line 2481: [J

line 2482: " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)[J

line 2483: au BufNewFile,BufRead *.tpm^I^I^Isetf xml[J

line 2484: [J

line 2485: " Xdg menus[J

line 2486: au BufNewFile,BufRead */etc/xdg/menus/*.menu^Isetf xml[J

line 2487: [J

line 2488: " ATI graphics driver configuration[J

line 2489: au BufNewFile,BufRead fglrxrc^I^I^Isetf xml[J

line 2490: [J

line 2491: " XLIFF (XML Localisation Interchange File Format) is also XML[J

line 2492: au BufNewFile,BufRead *.xlf^I^I^Isetf xml[J

line 2493: au BufNewFile,BufRead *.xliff^I^I^Isetf xml[J

line 2494: [J

line 2495: " XML User Interface Language[J

line 2496: au BufNewFile,BufRead *.xul^I^I^Isetf xml[J

line 2497: [J

line 2498: " X11 xmodmap (also see below)[J

line 2499: au BufNewFile,BufRead *Xmodmap^I^I^Isetf xmodmap[J

line 2500: [J

line 2501: " Xquery[J

line 2502: au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy^Isetf xquery[J

line 2503: [J

line 2504: " XSD[J

line 2505: au BufNewFile,BufRead *.xsd^I^I^Isetf xsd[J

line 2506: [J

line 2507: " Xslt[J

line 2508: au BufNewFile,BufRead *.xsl,*.xslt^I^Isetf xslt[J

line 2509: [J

line 2510: " Yacc[J

line 2511: au BufNewFile,BufRead *.yy,*.yxx,*.y++^I^Isetf yacc[J

line 2512: [J

line 2513: " Yacc or racc[J

line 2514: au BufNewFile,BufRead *.y^I^I^Icall s:FTy()[J

line 2515: [J

line 2516: func! s:FTy()[J

line 2532: [J

line 2533: [J

line 2534: " Yaml[J

line 2535: au BufNewFile,BufRead *.yaml,*.yml^I^Isetf yaml[J

line 2536: [J

line 2537: " yum conf (close enough to dosini)[J

line 2538: au BufNewFile,BufRead */etc/yum.conf^I^Isetf dosini[J

line 2539: [J

line 2540: " Zimbu[J

line 2541: au BufNewFile,BufRead *.zu^I^I^Isetf zimbu[J

line 2542: " Zimbu Templates[J

line 2543: au BufNewFile,BufRead *.zut^I^I^Isetf zimbutempl[J

line 2544: [J

line 2545: " Zope[J

line 2546: "   dtml (zope dynamic template markup language), pt (zope page template),[J

line 2547: "   cpt (zope form controller page template)[J

line 2548: au BufNewFile,BufRead *.dtml,*.pt,*.cpt^I^Icall s:FThtml()[J

line 2549: "   zsql (zope sql method)[J

line 2550: au BufNewFile,BufRead *.zsql^I^I^Icall s:SQL()[J

line 2551: [J

line 2552: " Z80 assembler asz80[J

line 2553: au BufNewFile,BufRead *.z8a^I^I^Isetf z8a[J

line 2554: [J

line 2555: augroup END[J

line 2556: [J

line 2557: [J

line 2558: " Source the user-specified filetype file, for backwards compatibility with[J

line 2559: " Vim 5.x.[J

line 2560: if exists("myfiletypefile") && filereadable(expand(myfiletypefile))[J

line 2561:   execute "source " . myfiletypefile[J

line 2562: endif[J

line 2563: [J

line 2564: [J

line 2565: " Check for "*" after loading myfiletypefile, so that scripts.vim is only used[J

line 2566: " when there are no matching file name extensions.[J

line 2567: " Don't do this for compressed files.[J

line 2568: augroup filetypedetect[J

line 2571: au BufNewFile,BufRead * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif[J

line 2572: au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif[J

line 2573: [J

line 2574: [J

line 2575: " Extra checks for when no filetype has been detected now.  Mostly used for[J

line 2576: " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim[J

line 2577: " script file.[J

line 2578: " Most of these should call s:StarSetf() to avoid names ending in .gz and the[J

line 2579: " like are used.[J

line 2580: [J

line 2581: " More Apache config files[J

line 2582: au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*^Icall s:StarSetf('apache')[J

line 2583: au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.d/*.conf*^I^Icall s:StarSetf('apache')[J

line 2584: [J

line 2585: " Asterisk config file[J

line 2586: au BufNewFile,BufRead *asterisk/*.conf*^I^Icall s:StarSetf('asterisk')[J

line 2587: au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')[J

line 2588: [J

line 2589: " Bazaar version control[J

line 2590: au BufNewFile,BufRead bzr_log.*^I^I^Isetf bzr[J

line 2591: [J

line 2592: " BIND zone[J

line 2593: au BufNewFile,BufRead */named/db.*,*/bind/db.*^Icall s:StarSetf('bindzone')[J

line 2594: [J

line 2595: " Calendar[J

line 2598: au BufNewFile,BufRead */.calendar/*,*/share/calendar/*/calendar.*,*/share/calendar/calendar.*^I^I^I^I^Icall s:StarSetf('calendar')[J

line 2599: [J

line 2600: " Changelog[J

line 2606: au BufNewFile,BufRead [cC]hange[lL]og* if getline(1) =~ '; urgency='|  call s:StarSetf('debchangelog')|else|  call s:StarSetf('changelog')|endif[J

line 2607: [J

line 2608: " Crontab[J

line 2609: au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*^I^Icall s:StarSetf('crontab')[J

line 2610: [J

line 2611: " dnsmasq(8) configuration[J

line 2612: au BufNewFile,BufRead */etc/dnsmasq.d/*^I^Icall s:StarSetf('dnsmasq')[J

line 2613: [J

line 2614: " Dracula[J

line 2615: au BufNewFile,BufRead drac.*^I^I^Icall s:StarSetf('dracula')[J

line 2616: [J

line 2617: " Fvwm[J

line 2618: au BufNewFile,BufRead */.fvwm/*^I^I^Icall s:StarSetf('fvwm')[J

line 2620: au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook let b:fvwm_version = 1 | call s:StarSetf('fvwm')[J

line 2626: au BufNewFile,BufRead *fvwm2rc* if expand("<afile>:e") == "m4"|  call s:StarSetf('fvwm2m4')|else|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')|endif[J

line 2627: [J

line 2628: " Gedcom[J

line 2629: au BufNewFile,BufRead */tmp/lltmp*^I^Icall s:StarSetf('gedcom')[J

line 2630: [J

line 2631: " GTK RC[J

line 2632: au BufNewFile,BufRead .gtkrc*,gtkrc*^I^Icall s:StarSetf('gtkrc')[J

line 2633: [J

line 2634: " Jam[J

line 2635: au BufNewFile,BufRead Prl*.*,JAM*.*^I^Icall s:StarSetf('jam')[J

line 2636: [J

line 2637: " Jargon[J

line 2641: au! BufNewFile,BufRead *jarg* if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'|  call s:StarSetf('jargon')|endif[J

line 2642: [J

line 2643: " Kconfig[J

line 2644: au BufNewFile,BufRead Kconfig.*^I^I^Icall s:StarSetf('kconfig')[J

line 2645: [J

line 2646: " Lilo: Linux loader[J

line 2647: au BufNewFile,BufRead lilo.conf*^I^Icall s:StarSetf('lilo')[J

line 2648: [J

line 2649: " Logcheck[J

line 2650: au BufNewFile,BufRead */etc/logcheck/*.d*/*^Icall s:StarSetf('logcheck')[J

line 2651: [J

line 2652: " Makefile[J

line 2653: au BufNewFile,BufRead [mM]akefile*^I^Icall s:StarSetf('make')[J

line 2654: [J

line 2655: " Ruby Makefile[J

line 2656: au BufNewFile,BufRead [rR]akefile*^I^Icall s:StarSetf('ruby')[J

line 2657: [J

line 2658: " Mail (also matches muttrc.vim, so this is below the other checks)[J

line 2659: au BufNewFile,BufRead mutt[[:alnum:]._-]\\\{6\}^Isetf mail[J

line 2660: [J

line 2661: au BufNewFile,BufRead reportbug-*^I^Icall s:StarSetf('mail')[J

line 2662: [J

line 2663: " Modconf[J

line 2667: au BufNewFile,BufRead */etc/modutils/* if executable(expand("<afile>")) != 1|  call s:StarSetf('modconf')|endif[J

line 2668: au BufNewFile,BufRead */etc/modprobe.*^I^Icall s:StarSetf('modconf')[J

line 2669: [J

line 2670: " Mutt setup file[J

line 2671: au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*^Icall s:StarSetf('muttrc')[J

line 2672: au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*^I^Icall s:StarSetf('muttrc')[J

line 2673: [J

line 2674: " Nroff macros[J

line 2675: au BufNewFile,BufRead tmac.*^I^I^Icall s:StarSetf('nroff')[J

line 2676: [J

line 2677: " OpenBSD hostname.if[J

line 2678: au BufNewFile,BufRead /etc/hostname.*^I^Icall s:StarSetf('config')[J

line 2679: [J

line 2680: " Pam conf[J

line 2681: au BufNewFile,BufRead */etc/pam.d/*^I^Icall s:StarSetf('pamconf')[J

line 2682: [J

line 2683: " Printcap and Termcap[J

line 2687: au BufNewFile,BufRead *printcap* if !did_filetype()|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')|endif[J

line 2691: au BufNewFile,BufRead *termcap* if !did_filetype()|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')|endif[J

line 2692: [J

line 2693: " ReDIF[J

line 2694: " Only used when the .rdf file was not detected to be XML.[J

line 2695: au BufRead,BufNewFile *.rdf^I^I^Icall s:Redif()[J

line 2696: func! s:Redif()[J

line 2706: [J

line 2707: " Remind[J

line 2708: au BufNewFile,BufRead .reminders*^I^Icall s:StarSetf('remind')[J

line 2709: [J

line 2710: " Vim script[J

line 2711: au BufNewFile,BufRead *vimrc*^I^I^Icall s:StarSetf('vim')[J

line 2712: [J

line 2713: " Subversion commit file[J

line 2714: au BufNewFile,BufRead svn-commit*.tmp^I^Isetf svn[J

line 2715: [J

line 2716: " X resources file[J

line 2717: au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')[J

line 2718: [J

line 2719: " XFree86 config[J

line 2721: au BufNewFile,BufRead XF86Config-4* let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')[J

line 2726: au BufNewFile,BufRead XF86Config* if getline(1) =~ '\<XConfigurator\>'|  let b:xf86conf_xfree86_version = 3|endif|call s:StarSetf('xf86conf')[J

line 2727: [J

line 2728: " X11 xmodmap[J

line 2729: au BufNewFile,BufRead *xmodmap*^I^I^Icall s:StarSetf('xmodmap')[J

line 2730: [J

line 2731: " Xinetd conf[J

line 2732: au BufNewFile,BufRead */etc/xinetd.d/*^I^Icall s:StarSetf('xinetd')[J

line 2733: [J

line 2734: " yum conf (close enough to dosini)[J

line 2735: au BufNewFile,BufRead */etc/yum.repos.d/*^Icall s:StarSetf('dosini')[J

line 2736: [J

line 2737: " Z-Shell script[J

line 2738: au BufNewFile,BufRead zsh*,zlog*^I^Icall s:StarSetf('zsh')[J

line 2739: [J

line 2740: [J

line 2741: " Plain text files, needs to be far down to not override others.  This avoids[J

line 2742: " the "conf" type being used if there is a line starting with '#'.[J

line 2743: au BufNewFile,BufRead *.txt,*.text,README^Isetf text[J

line 2744: [J

line 2745: [J

line 2746: " Use the filetype detect plugins.  They may overrule any of the previously[J

line 2747: " detected filetypes.[J

line 2748: runtime! ftdetect/*.vim[J

Searching for "ftdetect/*.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/after,/home/patrick/.vim/bundle/tabular/after,/home/patrick/[J
Searching for "/home/patrick/.vim/ftdetect/*.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/ftdetect/*.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/ftdetect/*.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/ftdetect/*.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/ftdetect/*.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/ftdetect/*.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdcommenter/ftdetect/*.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-fugitive/ftdetect/*.vim"[J
Searching for "/home/patrick/.vim/bundle/ale/ftdetect/*.vim"[J
Searching for "/home/patrick/.vim/bundle/tabular/ftdetect/*.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-table-mode/ftdetect/*.vim"[J
Searching for "/var/lib/vim/addons/ftdetect/*.vim"[J
Searching for "/usr/share/vim/vimfiles/ftdetect/*.vim"[J
Searching for "/usr/share/vim/vim80/ftdetect/*.vim"[J
Searching for "/usr/share/vim/vimfiles/after/ftdetect/*.vim"[J
Searching for "/var/lib/vim/addons/after/ftdetect/*.vim"[J
Searching for "/home/patrick/.vim/after/ftdetect/*.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/ftdetect/*.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/after/ftdetect/*.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/after/ftdetect/*.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/after/ftdetect/*.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/after/ftdetect/*.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/after/ftdetect/*.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdcommenter/after/ftdetect/*.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-fugitive/after/ftdetect/*.vim"[J
Searching for "/home/patrick/.vim/bundle/ale/after/ftdetect/*.vim"[J
Searching for "/home/patrick/.vim/bundle/tabular/after/ftdetect/*.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-table-mode/after/ftdetect/*.vim"[J
not found in 'runtimepath': "ftdetect/*.vim"[J
line 2749: [J

line 2750: " NOTE: The above command could have ended the filetypedetect autocmd group[J

line 2751: " and started another one. Let's make sure it has ended to get to a consistent[J

line 2752: " state.[J

line 2753: augroup END[J

line 2754: [J

line 2755: " Generic configuration file (check this last, it's just guessing!)[J

line 2761: au filetypedetect BufNewFile,BufRead,StdinReadPost * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'^I|| getline(4) =~ '^#' || getline(5) =~ '^#') |   setf conf | endif[J

line 2762: [J

line 2763: [J

line 2764: " If the GUI is already running, may still need to install the Syntax menu.[J

line 2765: " Don't do it when the 'M' flag is included in 'guioptions'.[J

line 2767: if has("menu") && has("gui_running") && !exists("did_install_syntax_menu") && &guioptions !~# "M"[J

line 2768:   source <sfile>:p:h/menu.vim[J

line 2769: endif[J

line 2770: [J

line 2771: " Function called for testing all functions defined here.  These are[J

line 2772: " script-local, thus need to be executed here.[J

line 2773: " Returns a string with error messages (hopefully empty).[J

line 2774: func! TestFiletypeFuncs(testlist)[J

line 2785: [J

line 2786: " Restore 'cpoptions'[J

line 2787: let &cpo = s:cpo_save[J

line 2788: unlet s:cpo_save[J

finished sourcing /usr/share/vim/vim80/filetype.vim[J
continuing in /home/patrick/.vimrc[J
Searching for "/usr/share/vim/vimfiles/after/filetype.vim"[J
Searching for "/var/lib/vim/addons/after/filetype.vim"[J
Searching for "/home/patrick/.vim/after/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/after/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/after/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/after/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/after/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/after/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdcommenter/after/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-fugitive/after/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/ale/after/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/tabular/after/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-table-mode/after/filetype.vim"[J
Searching for "ftplugin.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/after,/home/patrick/.vim/bundle/tabular/after,/home/patrick/.v[J
Searching for "/home/patrick/.vim/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdcommenter/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-fugitive/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/ale/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/tabular/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-table-mode/ftplugin.vim"[J
Searching for "/var/lib/vim/addons/ftplugin.vim"[J
Searching for "/usr/share/vim/vimfiles/ftplugin.vim"[J
Searching for "/usr/share/vim/vim80/ftplugin.vim"[J
chdir(/usr/share/vim/vim80)[J
fchdir() to previous dir[J
line 66: sourcing "/usr/share/vim/vim80/ftplugin.vim"[J
line 1: " Vim support file to switch on loading plugins for file types[J

line 2: "[J

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 4: " Last change:^I2006 Apr 30[J

line 5: [J

line 6: if exists("did_load_ftplugin")[J

line 7:   finish[J

line 8: endif[J

line 9: let did_load_ftplugin = 1[J

line 10: [J

line 11: augroup filetypeplugin[J

line 12:   au FileType * call s:LoadFTPlugin()[J

line 13: [J

line 14:   func! s:LoadFTPlugin()[J

line 35: augroup END[J

finished sourcing /usr/share/vim/vim80/ftplugin.vim[J
continuing in /home/patrick/.vimrc[J
Searching for "/usr/share/vim/vimfiles/after/ftplugin.vim"[J
Searching for "/var/lib/vim/addons/after/ftplugin.vim"[J
Searching for "/home/patrick/.vim/after/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/after/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/after/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/after/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/after/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/after/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdcommenter/after/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-fugitive/after/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/ale/after/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/tabular/after/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-table-mode/after/ftplugin.vim"[J
Searching for "indent.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/after,/home/patrick/.vim/bundle/tabular/after,/home/patrick/.vim[J
Searching for "/home/patrick/.vim/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdcommenter/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-fugitive/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/ale/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/tabular/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-table-mode/indent.vim"[J
Searching for "/var/lib/vim/addons/indent.vim"[J
Searching for "/usr/share/vim/vimfiles/indent.vim"[J
Searching for "/usr/share/vim/vim80/indent.vim"[J
chdir(/usr/share/vim/vim80)[J
fchdir() to previous dir[J
line 66: sourcing "/usr/share/vim/vim80/indent.vim"[J
line 1: " Vim support file to switch on loading indent files for file types[J

line 2: "[J

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 4: " Last Change:^I2008 Feb 22[J

line 5: [J

line 6: if exists("did_indent_on")[J

line 7:   finish[J

line 8: endif[J

line 9: let did_indent_on = 1[J

line 10: [J

line 11: augroup filetypeindent[J

line 12:   au FileType * call s:LoadIndent()[J

line 13:   func! s:LoadIndent()[J

line 31: augroup END[J

finished sourcing /usr/share/vim/vim80/indent.vim[J
continuing in /home/patrick/.vimrc[J
Searching for "/usr/share/vim/vimfiles/after/indent.vim"[J
Searching for "/var/lib/vim/addons/after/indent.vim"[J
Searching for "/home/patrick/.vim/after/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/after/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/after/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/after/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/after/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/after/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdcommenter/after/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-fugitive/after/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/ale/after/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/tabular/after/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-table-mode/after/indent.vim"[J
line 67: " To ignore plugin indent changes, instead use:[J

line 68: "filetype plugin on[J

line 69: "[J

line 70: " Brief help[J

line 71: " :PluginList       - lists configured plugins[J

line 72: " :PluginInstall    - installs plugins; append `!` to update or just :PluginUpdate[J

line 73: " :PluginSearch foo - searches for foo; append `!` to refresh local cache[J

line 74: " :PluginClean      - confirms removal of unused plugins; append `!` to auto-approve removal[J

line 75: "[J

line 76: " see :h vundle for more details or wiki for FAQ[J

line 77: " Put your non-Plugin stuff after this line[J

line 78: " -----------------------------------------[J

line 79: [J

line 80: [J

line 81: [J

line 82: "first of all, create these three folders:[J

line 83: "[J

line 84: " mkdir ~/.vim/.backup ~/.vim/.swp ~/.vim/.undo[J

line 85: "[J

line 86: " keep swap files etc out of git directories[J

line 87: " swap files (.swp) in a common location[J

line 88: " // means use the file's full path[J

line 89: set undodir=~/.vim/.undo//[J

line 90: set backupdir=~/.vim/.backup//[J

line 91: set directory=~/.vim/.swp//[J

line 92: "Alternatively you can turn them off, putting this in your vimrc file:[J

line 93: "set nobackup[J

line 94: "set noswapfile[J

line 95: [J

line 96: " set tabstops every 4 spaces and set the shiftwidth (the amount you indent)[J

line 97: " to 2 spaces[J

line 98: "[J

line 99: set ts=4 sw=2[J

line 100: syntax on[J

line 100: so $VIMRUNTIME/syntax/syntax.vim[J

chdir(/usr/share/vim/vim80/syntax)[J
fchdir() to previous dir[J
line 100: sourcing "/usr/share/vim/vim80/syntax/syntax.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2001 Sep 04[J

line 4: [J

line 5: " This file is used for ":syntax on".[J

line 6: " It installs the autocommands and starts highlighting for all buffers.[J

line 7: [J

line 8: if !has("syntax")[J

line 9:   finish[J

line 10: endif[J

line 11: [J

line 12: " If Syntax highlighting appears to be on already, turn it off first, so that[J

line 13: " any leftovers are cleared.[J

line 14: if exists("syntax_on") || exists("syntax_manual")[J

line 15:   so <sfile>:p:h/nosyntax.vim[J

line 16: endif[J

line 17: [J

line 18: " Load the Syntax autocommands and set the default methods for highlighting.[J

line 19: runtime syntax/synload.vim[J

Searching for "syntax/synload.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/after,/home/patrick/.vim/bundle/tabular/after,/home/patr[J
Searching for "/home/patrick/.vim/syntax/synload.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/syntax/synload.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/syntax/synload.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/syntax/synload.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/syntax/synload.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/syntax/synload.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdcommenter/syntax/synload.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-fugitive/syntax/synload.vim"[J
Searching for "/home/patrick/.vim/bundle/ale/syntax/synload.vim"[J
Searching for "/home/patrick/.vim/bundle/tabular/syntax/synload.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-table-mode/syntax/synload.vim"[J
Searching for "/var/lib/vim/addons/syntax/synload.vim"[J
Searching for "/usr/share/vim/vimfiles/syntax/synload.vim"[J
Searching for "/usr/share/vim/vim80/syntax/synload.vim"[J
chdir(/usr/share/vim/vim80/syntax)[J
fchdir() to previous dir[J
line 19: sourcing "/usr/share/vim/vim80/syntax/synload.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2016 Nov 04[J

line 4: [J

line 5: " This file sets up for syntax highlighting.[J

line 6: " It is loaded from "syntax.vim" and "manual.vim".[J

line 7: " 1. Set the default highlight groups.[J

line 8: " 2. Install Syntax autocommands for all the available syntax files.[J

line 9: [J

line 10: if !has("syntax")[J

line 11:   finish[J

line 12: endif[J

line 13: [J

line 14: " let others know that syntax has been switched on[J

line 15: let syntax_on = 1[J

line 16: [J

line 17: " Set the default highlighting colors.  Use a color scheme if specified.[J

line 18: if exists("colors_name")[J

line 19:   exe "colors " . colors_name[J

line 20: else[J

line 21:   runtime! syntax/syncolor.vim[J

Searching for "syntax/syncolor.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/after,/home/patrick/.vim/bundle/tabular/after,/home/pat[J
Searching for "/home/patrick/.vim/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdcommenter/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-fugitive/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/ale/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/tabular/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-table-mode/syntax/syncolor.vim"[J
Searching for "/var/lib/vim/addons/syntax/syncolor.vim"[J
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"[J
Searching for "/usr/share/vim/vim80/syntax/syncolor.vim"[J
chdir(/usr/share/vim/vim80/syntax)[J
fchdir() to previous dir[J
line 21: sourcing "/usr/share/vim/vim80/syntax/syncolor.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2001 Sep 12[J

line 4: [J

line 5: " This file sets up the default methods for highlighting.[J

line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".[J

line 7: " Also used from init_highlight().[J

line 8: [J

line 9: if !exists("syntax_cmd") || syntax_cmd == "on"[J

line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links[J

line 11:   command -nargs=* SynColor hi <args>[J

line 12:   command -nargs=* SynLink hi link <args>[J

line 13: else[J

line 14:   if syntax_cmd == "enable"[J

line 15:     " ":syntax enable" keeps any existing colors[J

line 16:     command -nargs=* SynColor hi def <args>[J

line 17:     command -nargs=* SynLink hi def link <args>[J

line 18:   elseif syntax_cmd == "reset"[J

line 19:     " ":syntax reset" resets all colors to the default[J

line 20:     command -nargs=* SynColor hi <args>[J

line 21:     command -nargs=* SynLink hi! link <args>[J

line 22:   else[J

line 23:     " User defined syncolor file has already set the colors.[J

line 24:     finish[J

line 25:   endif[J

line 26: endif[J

line 27: [J

line 28: " Many terminals can only use six different colors (plus black and white).[J

line 29: " Therefore the number of colors used is kept low. It doesn't look nice with[J

line 30: " too many colors anyway.[J

line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.[J

line 32: " There are two sets of defaults: for a dark and a light background.[J

line 33: if &background == "dark"[J

line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 43: else[J

line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE[J

line 44: hi Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE[J

line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE[J

line 45: hi Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE[J

line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE[J

line 46: hi Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE[J

line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE[J

line 47: hi Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE[J

line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE[J

line 48: hi Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE[J

line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE[J

line 49: hi PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE[J

line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE[J

line 50: hi Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE[J

line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue[J

line 51: hi Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue[J

line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 52: hi Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 53: endif[J

line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 56: [J

line 57: " Common groups that link to default highlighting.[J

line 58: " You can specify other highlighting easily.[J

line 59: SynLink String^I^IConstant[J

line 59: hi link String^I^IConstant[J

line 60: SynLink Character^IConstant[J

line 60: hi link Character^IConstant[J

line 61: SynLink Number^I^IConstant[J

line 61: hi link Number^I^IConstant[J

line 62: SynLink Boolean^I^IConstant[J

line 62: hi link Boolean^I^IConstant[J

line 63: SynLink Float^I^INumber[J

line 63: hi link Float^I^INumber[J

line 64: SynLink Function^IIdentifier[J

line 64: hi link Function^IIdentifier[J

line 65: SynLink Conditional^IStatement[J

line 65: hi link Conditional^IStatement[J

line 66: SynLink Repeat^I^IStatement[J

line 66: hi link Repeat^I^IStatement[J

line 67: SynLink Label^I^IStatement[J

line 67: hi link Label^I^IStatement[J

line 68: SynLink Operator^IStatement[J

line 68: hi link Operator^IStatement[J

line 69: SynLink Keyword^I^IStatement[J

line 69: hi link Keyword^I^IStatement[J

line 70: SynLink Exception^IStatement[J

line 70: hi link Exception^IStatement[J

line 71: SynLink Include^I^IPreProc[J

line 71: hi link Include^I^IPreProc[J

line 72: SynLink Define^I^IPreProc[J

line 72: hi link Define^I^IPreProc[J

line 73: SynLink Macro^I^IPreProc[J

line 73: hi link Macro^I^IPreProc[J

line 74: SynLink PreCondit^IPreProc[J

line 74: hi link PreCondit^IPreProc[J

line 75: SynLink StorageClass^IType[J

line 75: hi link StorageClass^IType[J

line 76: SynLink Structure^IType[J

line 76: hi link Structure^IType[J

line 77: SynLink Typedef^I^IType[J

line 77: hi link Typedef^I^IType[J

line 78: SynLink Tag^I^ISpecial[J

line 78: hi link Tag^I^ISpecial[J

line 79: SynLink SpecialChar^ISpecial[J

line 79: hi link SpecialChar^ISpecial[J

line 80: SynLink Delimiter^ISpecial[J

line 80: hi link Delimiter^ISpecial[J

line 81: SynLink SpecialComment^ISpecial[J

line 81: hi link SpecialComment^ISpecial[J

line 82: SynLink Debug^I^ISpecial[J

line 82: hi link Debug^I^ISpecial[J

line 83: [J

line 84: delcommand SynColor[J

line 85: delcommand SynLink[J

finished sourcing /usr/share/vim/vim80/syntax/syncolor.vim[J
continuing in /usr/share/vim/vim80/syntax/synload.vim[J
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"[J
Searching for "/var/lib/vim/addons/after/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/after/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/after/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/after/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/after/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/after/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/after/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdcommenter/after/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-fugitive/after/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/ale/after/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/tabular/after/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-table-mode/after/syntax/syncolor.vim"[J
line 22: endif[J

line 23: [J

line 24: " Line continuation is used here, remove 'C' from 'cpoptions'[J

line 25: let s:cpo_save = &cpo[J

line 26: set cpo&vim[J

line 27: [J

line 28: " First remove all old syntax autocommands.[J

line 29: au! Syntax[J

line 30: [J

line 31: au Syntax *^I^Icall s:SynSet()[J

line 32: [J

line 33: fun! s:SynSet()[J

line 61: [J

line 62: [J

line 63: " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)[J

line 68: au Syntax c,cpp,cs,idl,java,php,datascript if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif[J

line 69: [J

line 70: [J

line 71: " Source the user-specified syntax highlighting file[J

line 72: if exists("mysyntaxfile")[J

line 73:   let s:fname = expand(mysyntaxfile)[J

line 74:   if filereadable(s:fname)[J

line 75:     execute "source " . fnameescape(s:fname)[J

line 76:   endif[J

line 77: endif[J

line 78: [J

line 79: " Restore 'cpoptions'[J

line 80: let &cpo = s:cpo_save[J

line 81: unlet s:cpo_save[J

finished sourcing /usr/share/vim/vim80/syntax/synload.vim[J
continuing in /usr/share/vim/vim80/syntax/syntax.vim[J
line 20: [J

line 21: " Load the FileType autocommands if not done yet.[J

line 22: if exists("did_load_filetypes")[J

line 23:   let s:did_ft = 1[J

line 24: else[J

line 25:   filetype on[J

line 26:   let s:did_ft = 0[J

line 27: endif[J

line 28: [J

line 29: " Set up the connection between FileType and Syntax autocommands.[J

line 30: " This makes the syntax automatically set when the file type is detected.[J

line 31: augroup syntaxset[J

line 32:   au! FileType *^Iexe "set syntax=" . expand("<amatch>")[J

line 33: augroup END[J

line 34: [J

line 35: [J

line 36: " Execute the syntax autocommands for the each buffer.[J

line 37: " If the filetype wasn't detected yet, do that now.[J

line 38: " Always do the syntaxset autocommands, for buffers where the 'filetype'[J

line 39: " already was set manually (e.g., help buffers).[J

line 40: doautoall syntaxset FileType[J

line 41: if !s:did_ft[J

line 42:   doautoall filetypedetect BufRead[J

line 43: endif[J

finished sourcing /usr/share/vim/vim80/syntax/syntax.vim[J
continuing in /home/patrick/.vimrc[J
line 101: [J

line 102: set number relativenumber " show relative line numbers[J

line 103: :augroup numbertoggle[J

line 104: :  autocmd![J

line 105: :  autocmd BufEnter,FocusGained,InsertLeave * set relativenumber[J

line 106: :  autocmd BufLeave,FocusLost,InsertEnter   * set norelativenumber[J

line 107: :augroup END[J

line 108: [J

line 109: " you need some color in your life :)[J

line 110: colorscheme molokai-dark[J

Searching for "colors/molokai-dark.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/after,/home/patrick/.vim/bundle/tabular/after,/home[J
Searching for "/home/patrick/.vim/colors/molokai-dark.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/colors/molokai-dark.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/colors/molokai-dark.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/colors/molokai-dark.vim"[J
chdir(/home/patrick/.vim/bundle/molokai-dark/colors)[J
fchdir() to previous dir[J
line 110: sourcing "/home/patrick/.vim/bundle/molokai-dark/colors/molokai-dark.vim"[J
line 1: " Based on Tomas Restrepo's molokai theme at https://github.com/tomasr/molokai[J

line 2: [J

line 3: hi clear[J

Searching for "syntax/syncolor.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/after,/home/patrick/.vim/bundle/tabular/after,/home/pat[J
Searching for "/home/patrick/.vim/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdcommenter/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-fugitive/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/ale/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/tabular/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-table-mode/syntax/syncolor.vim"[J
Searching for "/var/lib/vim/addons/syntax/syncolor.vim"[J
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"[J
Searching for "/usr/share/vim/vim80/syntax/syncolor.vim"[J
chdir(/usr/share/vim/vim80/syntax)[J
fchdir() to previous dir[J
line 3: sourcing "/usr/share/vim/vim80/syntax/syncolor.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2001 Sep 12[J

line 4: [J

line 5: " This file sets up the default methods for highlighting.[J

line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".[J

line 7: " Also used from init_highlight().[J

line 8: [J

line 9: if !exists("syntax_cmd") || syntax_cmd == "on"[J

line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links[J

line 11:   command -nargs=* SynColor hi <args>[J

line 12:   command -nargs=* SynLink hi link <args>[J

line 13: else[J

line 14:   if syntax_cmd == "enable"[J

line 15:     " ":syntax enable" keeps any existing colors[J

line 16:     command -nargs=* SynColor hi def <args>[J

line 17:     command -nargs=* SynLink hi def link <args>[J

line 18:   elseif syntax_cmd == "reset"[J

line 19:     " ":syntax reset" resets all colors to the default[J

line 20:     command -nargs=* SynColor hi <args>[J

line 21:     command -nargs=* SynLink hi! link <args>[J

line 22:   else[J

line 23:     " User defined syncolor file has already set the colors.[J

line 24:     finish[J

line 25:   endif[J

line 26: endif[J

line 27: [J

line 28: " Many terminals can only use six different colors (plus black and white).[J

line 29: " Therefore the number of colors used is kept low. It doesn't look nice with[J

line 30: " too many colors anyway.[J

line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.[J

line 32: " There are two sets of defaults: for a dark and a light background.[J

line 33: if &background == "dark"[J

line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 43: else[J

line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE[J

line 44: hi Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE[J

line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE[J

line 45: hi Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE[J

line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE[J

line 46: hi Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE[J

line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE[J

line 47: hi Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE[J

line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE[J

line 48: hi Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE[J

line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE[J

line 49: hi PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE[J

line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE[J

line 50: hi Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE[J

line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue[J

line 51: hi Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue[J

line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 52: hi Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 53: endif[J

line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 56: [J

line 57: " Common groups that link to default highlighting.[J

line 58: " You can specify other highlighting easily.[J

line 59: SynLink String^I^IConstant[J

line 59: hi link String^I^IConstant[J

line 60: SynLink Character^IConstant[J

line 60: hi link Character^IConstant[J

line 61: SynLink Number^I^IConstant[J

line 61: hi link Number^I^IConstant[J

line 62: SynLink Boolean^I^IConstant[J

line 62: hi link Boolean^I^IConstant[J

line 63: SynLink Float^I^INumber[J

line 63: hi link Float^I^INumber[J

line 64: SynLink Function^IIdentifier[J

line 64: hi link Function^IIdentifier[J

line 65: SynLink Conditional^IStatement[J

line 65: hi link Conditional^IStatement[J

line 66: SynLink Repeat^I^IStatement[J

line 66: hi link Repeat^I^IStatement[J

line 67: SynLink Label^I^IStatement[J

line 67: hi link Label^I^IStatement[J

line 68: SynLink Operator^IStatement[J

line 68: hi link Operator^IStatement[J

line 69: SynLink Keyword^I^IStatement[J

line 69: hi link Keyword^I^IStatement[J

line 70: SynLink Exception^IStatement[J

line 70: hi link Exception^IStatement[J

line 71: SynLink Include^I^IPreProc[J

line 71: hi link Include^I^IPreProc[J

line 72: SynLink Define^I^IPreProc[J

line 72: hi link Define^I^IPreProc[J

line 73: SynLink Macro^I^IPreProc[J

line 73: hi link Macro^I^IPreProc[J

line 74: SynLink PreCondit^IPreProc[J

line 74: hi link PreCondit^IPreProc[J

line 75: SynLink StorageClass^IType[J

line 75: hi link StorageClass^IType[J

line 76: SynLink Structure^IType[J

line 76: hi link Structure^IType[J

line 77: SynLink Typedef^I^IType[J

line 77: hi link Typedef^I^IType[J

line 78: SynLink Tag^I^ISpecial[J

line 78: hi link Tag^I^ISpecial[J

line 79: SynLink SpecialChar^ISpecial[J

line 79: hi link SpecialChar^ISpecial[J

line 80: SynLink Delimiter^ISpecial[J

line 80: hi link Delimiter^ISpecial[J

line 81: SynLink SpecialComment^ISpecial[J

line 81: hi link SpecialComment^ISpecial[J

line 82: SynLink Debug^I^ISpecial[J

line 82: hi link Debug^I^ISpecial[J

line 83: [J

line 84: delcommand SynColor[J

line 85: delcommand SynLink[J

finished sourcing /usr/share/vim/vim80/syntax/syncolor.vim[J
continuing in /home/patrick/.vim/bundle/molokai-dark/colors/molokai-dark.vim[J
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"[J
Searching for "/var/lib/vim/addons/after/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/after/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/after/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/after/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/after/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/after/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/after/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdcommenter/after/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-fugitive/after/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/ale/after/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/tabular/after/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-table-mode/after/syntax/syncolor.vim"[J
line 4: syntax reset[J

line 4: runtime! syntax/syncolor.vim[J

Searching for "syntax/syncolor.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/after,/home/patrick/.vim/bundle/tabular/after,/home/pat[J
Searching for "/home/patrick/.vim/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdcommenter/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-fugitive/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/ale/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/tabular/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-table-mode/syntax/syncolor.vim"[J
Searching for "/var/lib/vim/addons/syntax/syncolor.vim"[J
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"[J
Searching for "/usr/share/vim/vim80/syntax/syncolor.vim"[J
chdir(/usr/share/vim/vim80/syntax)[J
fchdir() to previous dir[J
line 4: sourcing "/usr/share/vim/vim80/syntax/syncolor.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2001 Sep 12[J

line 4: [J

line 5: " This file sets up the default methods for highlighting.[J

line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".[J

line 7: " Also used from init_highlight().[J

line 8: [J

line 9: if !exists("syntax_cmd") || syntax_cmd == "on"[J

line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links[J

line 11:   command -nargs=* SynColor hi <args>[J

line 12:   command -nargs=* SynLink hi link <args>[J

line 13: else[J

line 14:   if syntax_cmd == "enable"[J

line 15:     " ":syntax enable" keeps any existing colors[J

line 16:     command -nargs=* SynColor hi def <args>[J

line 17:     command -nargs=* SynLink hi def link <args>[J

line 18:   elseif syntax_cmd == "reset"[J

line 19:     " ":syntax reset" resets all colors to the default[J

line 20:     command -nargs=* SynColor hi <args>[J

line 21:     command -nargs=* SynLink hi! link <args>[J

line 22:   else[J

line 23:     " User defined syncolor file has already set the colors.[J

line 24:     finish[J

line 25:   endif[J

line 26: endif[J

line 27: [J

line 28: " Many terminals can only use six different colors (plus black and white).[J

line 29: " Therefore the number of colors used is kept low. It doesn't look nice with[J

line 30: " too many colors anyway.[J

line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.[J

line 32: " There are two sets of defaults: for a dark and a light background.[J

line 33: if &background == "dark"[J

line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 43: else[J

line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE[J

line 44: hi Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE[J

line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE[J

line 45: hi Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE[J

line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE[J

line 46: hi Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE[J

line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE[J

line 47: hi Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE[J

line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE[J

line 48: hi Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE[J

line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE[J

line 49: hi PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE[J

line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE[J

line 50: hi Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE[J

line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue[J

line 51: hi Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue[J

line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 52: hi Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 53: endif[J

line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 56: [J

line 57: " Common groups that link to default highlighting.[J

line 58: " You can specify other highlighting easily.[J

line 59: SynLink String^I^IConstant[J

line 59: hi! link String^I^IConstant[J

line 60: SynLink Character^IConstant[J

line 60: hi! link Character^IConstant[J

line 61: SynLink Number^I^IConstant[J

line 61: hi! link Number^I^IConstant[J

line 62: SynLink Boolean^I^IConstant[J

line 62: hi! link Boolean^I^IConstant[J

line 63: SynLink Float^I^INumber[J

line 63: hi! link Float^I^INumber[J

line 64: SynLink Function^IIdentifier[J

line 64: hi! link Function^IIdentifier[J

line 65: SynLink Conditional^IStatement[J

line 65: hi! link Conditional^IStatement[J

line 66: SynLink Repeat^I^IStatement[J

line 66: hi! link Repeat^I^IStatement[J

line 67: SynLink Label^I^IStatement[J

line 67: hi! link Label^I^IStatement[J

line 68: SynLink Operator^IStatement[J

line 68: hi! link Operator^IStatement[J

line 69: SynLink Keyword^I^IStatement[J

line 69: hi! link Keyword^I^IStatement[J

line 70: SynLink Exception^IStatement[J

line 70: hi! link Exception^IStatement[J

line 71: SynLink Include^I^IPreProc[J

line 71: hi! link Include^I^IPreProc[J

line 72: SynLink Define^I^IPreProc[J

line 72: hi! link Define^I^IPreProc[J

line 73: SynLink Macro^I^IPreProc[J

line 73: hi! link Macro^I^IPreProc[J

line 74: SynLink PreCondit^IPreProc[J

line 74: hi! link PreCondit^IPreProc[J

line 75: SynLink StorageClass^IType[J

line 75: hi! link StorageClass^IType[J

line 76: SynLink Structure^IType[J

line 76: hi! link Structure^IType[J

line 77: SynLink Typedef^I^IType[J

line 77: hi! link Typedef^I^IType[J

line 78: SynLink Tag^I^ISpecial[J

line 78: hi! link Tag^I^ISpecial[J

line 79: SynLink SpecialChar^ISpecial[J

line 79: hi! link SpecialChar^ISpecial[J

line 80: SynLink Delimiter^ISpecial[J

line 80: hi! link Delimiter^ISpecial[J

line 81: SynLink SpecialComment^ISpecial[J

line 81: hi! link SpecialComment^ISpecial[J

line 82: SynLink Debug^I^ISpecial[J

line 82: hi! link Debug^I^ISpecial[J

line 83: [J

line 84: delcommand SynColor[J

line 85: delcommand SynLink[J

finished sourcing /usr/share/vim/vim80/syntax/syncolor.vim[J
continuing in /home/patrick/.vim/bundle/molokai-dark/colors/molokai-dark.vim[J
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"[J
Searching for "/var/lib/vim/addons/after/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/after/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/after/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/after/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/after/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/after/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/after/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdcommenter/after/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-fugitive/after/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/ale/after/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/tabular/after/syntax/syncolor.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-table-mode/after/syntax/syncolor.vim"[J
line 5: [J

line 6: let g:colors_name="molokai-dark"[J

line 7: [J

line 8: set background=dark[J

line 9: [J

line 10: hi Normal               guifg=#F8F8F2 guibg=#000000               ctermfg=15   ctermbg=0    cterm=none[J

line 11: hi Cursor               guifg=#000000 guibg=#F8F8F0               ctermfg=16   ctermbg=253[J

line 12: hi iCursor              guifg=#000000 guibg=#F8F8F0               ctermfg=16   ctermbg=253[J

line 13: hi CursorLine                         guibg=#1C1C1C                            ctermbg=234  cterm=none[J

line 14: hi CursorColumn                       guibg=#1C1C1C                            ctermbg=234[J

line 15: [J

line 16: hi Constant             guifg=#AE81FF                             ctermfg=135[J

line 17:  hi String              guifg=#FFDF5F                             ctermfg=221[J

line 18:  hi Character           guifg=#FFDF5F                             ctermfg=221[J

line 19:  hi Number              guifg=#AE81FF                             ctermfg=135[J

line 20:  hi Boolean             guifg=#AE81FF                             ctermfg=135[J

line 21:  hi Float               guifg=#AE81FF                             ctermfg=135[J

line 22: [J

line 23: hi Identifier           guifg=#FD971F                             ctermfg=208               cterm=none[J

line 24:  hi Function            guifg=#A6E22E                             ctermfg=118[J

line 25: [J

line 26: hi Statement            guifg=#F92672                             ctermfg=197[J

line 27:  hi Conditional         guifg=#F92672               gui=bold      ctermfg=197               cterm=bold[J

line 28:  hi Repeat              guifg=#F92672               gui=bold      ctermfg=197               cterm=bold[J

line 29:  hi Label               guifg=#E6DB74               gui=none      ctermfg=229               cterm=none[J

line 30:  hi Operator            guifg=#F92672                             ctermfg=197[J

line 31:  hi Keyword             guifg=#F92672               gui=bold      ctermfg=197               cterm=bold[J

line 32:  hi Exception           guifg=#A6E22E               gui=bold      ctermfg=118               cterm=bold[J

line 33: [J

line 34: hi PreProc              guifg=#A6E22E                             ctermfg=118[J

line 35:  hi Include             guifg=#A6E22E                             ctermfg=118[J

line 36:  hi Define              guifg=#66D9EF                             ctermfg=81[J

line 37:  hi Macro               guifg=#C4BE89               gui=italic    ctermfg=193[J

line 38:  hi PreCondit           guifg=#A6E22E                             ctermfg=118[J

line 39: [J

line 40: hi Type                 guifg=#66D9EF               gui=none      ctermfg=81                cterm=none[J

line 41:  hi StorageClass        guifg=#FD971F               gui=italic    ctermfg=208[J

line 42:  hi Structure           guifg=#66D9EF                             ctermfg=81[J

line 43:  hi Typedef             guifg=#66D9EF                             ctermfg=81[J

line 44: [J

line 45: hi Special              guifg=#66D9EF guibg=bg      gui=italic    ctermfg=81[J

line 46:  hi SpecialChar         guifg=#F92672               gui=bold      ctermfg=197               cterm=bold[J

line 47:  hi Tag                 guifg=#F92672               gui=italic    ctermfg=197[J

line 48:  hi Delimiter           guifg=#8F8F8F                             ctermfg=241[J

line 49:  hi SpecialComment      guifg=#7E8E91               gui=bold      ctermfg=245               cterm=bold[J

line 50:  hi SpecialKey          guifg=#465457                             ctermfg=239[J

line 51:  hi Debug               guifg=#BCA3A3               gui=bold      ctermfg=225               cterm=bold[J

line 52: [J

line 53: hi Comment              guifg=#7E8E91                             ctermfg=244[J

line 54: hi Todo                 guifg=#FFFFFF guibg=bg      gui=bold      ctermfg=231  ctermbg=232  cterm=bold[J

line 55: hi Underlined           guifg=#808080               gui=underline ctermfg=244               cterm=underline[J

line 56: [J

line 57: hi Search               guifg=#000000 guibg=#FFE792               ctermfg=0    ctermbg=222  cterm=none[J

line 58: hi IncSearch            guifg=#C4BE89 guibg=#000000               ctermfg=193  ctermbg=16[J

line 59: [J

line 60: hi MatchParen           guifg=#000000 guibg=#FD971F gui=bold      ctermfg=233  ctermbg=208  cterm=bold[J

line 61: [J

line 62: hi ModeMsg              guifg=#E6DB74                             ctermfg=229[J

line 63: hi MoreMsg              guifg=#E6DB74                             ctermfg=229[J

line 64: hi StatusLine           guifg=#455354 guibg=fg                    ctermfg=238  ctermbg=253[J

line 65: hi StatusLineNC         guifg=#808080 guibg=#080808               ctermfg=244  ctermbg=232[J

line 66: [J

line 67: hi Error                guifg=#E6DB74 guibg=#FF3333               ctermfg=219  ctermbg=196[J

line 68: hi ErrorMsg             guifg=#F92672 guibg=#232526 gui=bold      ctermfg=199  ctermbg=16   cterm=bold[J

line 69: hi WarningMsg           guifg=#FFFFFF guibg=#333333 gui=bold      ctermfg=231  ctermbg=238  cterm=bold[J

line 70: hi Question             guifg=#66D9EF                             ctermfg=81[J

line 71: hi Title                guifg=#EF5939                             ctermfg=166[J

line 72: [J

line 73: hi DiffAdd                            guibg=#13354A                            ctermbg=24[J

line 74: hi DiffChange           guifg=#89807D guibg=#4C4745               ctermfg=181  ctermbg=239[J

line 75: hi DiffDelete           guifg=#960050 guibg=#1E0010               ctermfg=162  ctermbg=53[J

line 76: hi DiffText                           guibg=#4C4745 gui=bold                   ctermbg=102  cterm=bold[J

line 77: [J

line 78: hi Directory            guifg=#A6E22E               gui=bold      ctermfg=118               cterm=bold[J

line 79: [J

line 80: hi Folded               guifg=#465457 guibg=#000000               ctermfg=67   ctermbg=16[J

line 81: hi FoldColumn           guifg=#465457 guibg=#000000               ctermfg=67   ctermbg=16[J

line 82: [J

line 83: hi Pmenu                guifg=#66D9EF guibg=#000000               ctermfg=81   ctermbg=16[J

line 84: hi PmenuSel                           guibg=#808080               ctermfg=255  ctermbg=242[J

line 85: hi PmenuSbar                          guibg=#080808                            ctermbg=232[J

line 86: hi PmenuThumb           guifg=#66D9EF                             ctermfg=81[J

line 87: [J

line 88: hi WildMenu             guifg=#66D9EF guibg=#000000               ctermfg=81   ctermbg=16[J

line 89: [J

line 90: if has("spell")[J

line 91:     hi SpellBad         guisp=#FF0000               gui=undercurl              ctermbg=52[J

line 92:     hi SpellCap         guisp=#7070F0               gui=undercurl              ctermbg=17[J

line 93:     hi SpellLocal       guisp=#70F0F0               gui=undercurl              ctermbg=17[J

line 94:     hi SpellRare        guisp=#FFFFFF               gui=undercurl ctermfg=none ctermbg=none cterm=reverse[J

line 95: endif[J

line 96: [J

line 97: hi VisualNOS                          guibg=#403D3D                            ctermbg=238[J

line 98: hi Visual                             guibg=#403D3D                            ctermbg=238[J

line 99: [J

line 100: hi TabLineFill          guifg=#1B1D1E guibg=#1B1D1E[J

line 101: hi TabLine              guifg=#808080 guibg=#1B1D1E gui=none[J

line 102: hi TabLineSel           guifg=#808080 guibg=#5F6061 gui=bold[J

line 103: [J

line 104: hi LineNr               guifg=#465457 guibg=#232526               ctermfg=239  ctermbg=235[J

line 105: hi CursorLineNr         guifg=#FD971F guibg=#1C1C1C gui=none      ctermfg=208  ctermbg=234  cterm=none[J

line 106: hi SignColumn           guifg=#A6E22E guibg=#232526               ctermfg=118  ctermbg=235[J

line 107: hi VertSplit            guifg=#808080 guibg=#080808 gui=bold      ctermfg=244  ctermbg=232  cterm=bold[J

line 108: hi ColorColumn                        guibg=#232526                            ctermbg=236[J

line 109: [J

line 110: hi NonText              guifg=#465457                             ctermfg=239[J

line 111: hi Ignore               guifg=#808080 guibg=bg                    ctermfg=244  ctermbg=232[J

line 112: [J

line 113: " Special cases[J

line 114: [J

line 115: " Show default Git colors[J

line 116: hi diffAdded            guifg=#00AF00               gui=none      ctermfg=40                cterm=none[J

line 117: hi diffRemoved          guifg=#AF0000               gui=none      ctermfg=160               cterm=none[J

line 118: hi diffLine             guifg=#00D7AF               gui=none      ctermfg=43                cterm=none[J

line 119: hi link diffSubname Normal[J

line 120: [J

line 121: " Syntastic[J

line 122: hi SyntasticErrorSign   guifg=#F92672 guibg=#232526               ctermfg=197  ctermbg=235[J

line 123: hi SyntasticWarningSign guifg=#FFDF5F guibg=#232526               ctermfg=221  ctermbg=235[J

line 124: [J

line 125: " vim:cc=24,38,52,66,79,92[J

finished sourcing /home/patrick/.vim/bundle/molokai-dark/colors/molokai-dark.vim[J
continuing in /home/patrick/.vimrc[J
line 111: " for terminal which supports truecolor[J

line 112: set termguicolors[J

line 113: " else set t_Co=256[J

line 114: [J

line 115: [J

line 116: " configure keyboard mappings here[J

line 117: " type Ojj or ojj to quickly insert newline[J

line 118: " oo and OO go back to cursor position[J

line 119: nmap oo o<Esc>k[J

line 120: nmap OO O<Esc>j[J

line 121: inoremap jj<ESC> [J

No mapping found[J
line 122: set listchars=eol:¬,tab:>-,trail:~,extends:>,precedes:<,space:␣[J

line 123:  [J

line 124: " Quickly go to line number[J

line 125: :nnoremap <CR> G[J

line 126: [J

line 127: "  Give a shortcut key to NERD Tree[J

line 128: map <F1> :NERDTreeToggle<CR>[J

line 129: " autopen NERDTree and focus cursor in new document[J

line 130: autocmd VimEnter * NERDTree[J

line 131: autocmd VimEnter * wincmd p[J

line 132: " for now I'm just toggling hidden files by pressing uppercase i[J

line 133: " let NERDTreeShowHidden=1[J

line 134: set pastetoggle=<F2>[J

line 135: map <F3> :TableModeToggle<CR>[J

line 136: " get ReST-compatible tables with vim-table-mode plugin[J

line 137: let g:table_mode_corner_corner='+'[J

line 138: let g:table_mode_header_fillchar='='[J

finished sourcing $HOME/.vimrc[J
Searching for "plugin/**/*.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/after,/home/patrick/.vim/bundle/tabular/after,/home/patrick[J
Searching for "/home/patrick/.vim/plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/plugin/**/*.vim"[J
chdir(/home/patrick/.vim/bundle/vim-sensible/plugin)[J
fchdir() to previous dir[J
sourcing "/home/patrick/.vim/bundle/vim-sensible/plugin/sensible.vim"[J
line 1: " sensible.vim - Defaults everyone can agree on[J

line 2: " Maintainer:   Tim Pope <http://tpo.pe/>[J

line 3: " Version:      1.1[J

line 4: [J

line 5: if exists('g:loaded_sensible') || &compatible[J

line 6:   finish[J

line 7: else[J

line 8:   let g:loaded_sensible = 'yes'[J

line 9: endif[J

line 10: [J

line 11: if has('autocmd')[J

line 12:   filetype plugin indent on[J

Searching for "filetype.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/after,/home/patrick/.vim/bundle/tabular/after,/home/patrick/.v[J
Searching for "/home/patrick/.vim/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdcommenter/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-fugitive/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/ale/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/tabular/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-table-mode/filetype.vim"[J
Searching for "/var/lib/vim/addons/filetype.vim"[J
Searching for "/usr/share/vim/vimfiles/filetype.vim"[J
Searching for "/usr/share/vim/vim80/filetype.vim"[J
chdir(/usr/share/vim/vim80)[J
fchdir() to previous dir[J
line 12: sourcing "/usr/share/vim/vim80/filetype.vim"[J
line 1: " Vim support file to detect file types[J

line 2: "[J

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 4: " Last Change:^I2017 Jan 06[J

line 5: [J

line 6: " Listen very carefully, I will say this only once[J

line 7: if exists("did_load_filetypes")[J

line 8:   finish[J

finished sourcing /usr/share/vim/vim80/filetype.vim[J
continuing in /home/patrick/.vim/bundle/vim-sensible/plugin/sensible.vim[J
Searching for "/usr/share/vim/vimfiles/after/filetype.vim"[J
Searching for "/var/lib/vim/addons/after/filetype.vim"[J
Searching for "/home/patrick/.vim/after/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/after/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/after/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/after/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/after/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/after/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdcommenter/after/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-fugitive/after/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/ale/after/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/tabular/after/filetype.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-table-mode/after/filetype.vim"[J
Searching for "ftplugin.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/after,/home/patrick/.vim/bundle/tabular/after,/home/patrick/.v[J
Searching for "/home/patrick/.vim/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdcommenter/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-fugitive/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/ale/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/tabular/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-table-mode/ftplugin.vim"[J
Searching for "/var/lib/vim/addons/ftplugin.vim"[J
Searching for "/usr/share/vim/vimfiles/ftplugin.vim"[J
Searching for "/usr/share/vim/vim80/ftplugin.vim"[J
chdir(/usr/share/vim/vim80)[J
fchdir() to previous dir[J
line 12: sourcing "/usr/share/vim/vim80/ftplugin.vim"[J
line 1: " Vim support file to switch on loading plugins for file types[J

line 2: "[J

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 4: " Last change:^I2006 Apr 30[J

line 5: [J

line 6: if exists("did_load_ftplugin")[J

line 7:   finish[J

finished sourcing /usr/share/vim/vim80/ftplugin.vim[J
continuing in /home/patrick/.vim/bundle/vim-sensible/plugin/sensible.vim[J
Searching for "/usr/share/vim/vimfiles/after/ftplugin.vim"[J
Searching for "/var/lib/vim/addons/after/ftplugin.vim"[J
Searching for "/home/patrick/.vim/after/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/after/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/after/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/after/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/after/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/after/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdcommenter/after/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-fugitive/after/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/ale/after/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/tabular/after/ftplugin.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-table-mode/after/ftplugin.vim"[J
Searching for "indent.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/after,/home/patrick/.vim/bundle/tabular/after,/home/patrick/.vim[J
Searching for "/home/patrick/.vim/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdcommenter/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-fugitive/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/ale/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/tabular/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-table-mode/indent.vim"[J
Searching for "/var/lib/vim/addons/indent.vim"[J
Searching for "/usr/share/vim/vimfiles/indent.vim"[J
Searching for "/usr/share/vim/vim80/indent.vim"[J
chdir(/usr/share/vim/vim80)[J
fchdir() to previous dir[J
line 12: sourcing "/usr/share/vim/vim80/indent.vim"[J
line 1: " Vim support file to switch on loading indent files for file types[J

line 2: "[J

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 4: " Last Change:^I2008 Feb 22[J

line 5: [J

line 6: if exists("did_indent_on")[J

line 7:   finish[J

finished sourcing /usr/share/vim/vim80/indent.vim[J
continuing in /home/patrick/.vim/bundle/vim-sensible/plugin/sensible.vim[J
Searching for "/usr/share/vim/vimfiles/after/indent.vim"[J
Searching for "/var/lib/vim/addons/after/indent.vim"[J
Searching for "/home/patrick/.vim/after/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/after/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/after/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/after/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/after/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/after/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdcommenter/after/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-fugitive/after/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/ale/after/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/tabular/after/indent.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-table-mode/after/indent.vim"[J
line 13: endif[J

line 14: if has('syntax') && !exists('g:syntax_on')[J

line 15:   syntax enable[J

line 16: endif[J

line 17: [J

line 18: " Use :help 'option' to see the documentation for the given option.[J

line 19: [J

line 20: set autoindent[J

line 21: set backspace=indent,eol,start[J

line 22: set complete-=i[J

line 23: set smarttab[J

line 24: [J

line 25: set nrformats-=octal[J

line 26: [J

line 27: if !has('nvim') && &ttimeoutlen == -1[J

line 28:   set ttimeout[J

line 29:   set ttimeoutlen=100[J

line 30: endif[J

line 31: [J

line 32: set incsearch[J

line 33: " Use <C-L> to clear the highlighting of :set hlsearch.[J

line 34: if maparg('<C-L>', 'n') ==# ''[J

line 35:   nnoremap <silent> <C-L> :nohlsearch<C-R>=has('diff')?'<Bar>diffupdate':''<CR><CR><C-L>[J

line 36: endif[J

line 37: [J

line 38: set laststatus=2[J

line 39: set ruler[J

line 40: set wildmenu[J

line 41: [J

line 42: if !&scrolloff[J

line 43:   set scrolloff=1[J

line 44: endif[J

line 45: if !&sidescrolloff[J

line 46:   set sidescrolloff=5[J

line 47: endif[J

line 48: set display+=lastline[J

line 49: [J

line 50: if &encoding ==# 'latin1' && has('gui_running')[J

line 51:   set encoding=utf-8[J

line 52: endif[J

line 53: [J

line 54: if &listchars ==# 'eol:$'[J

line 55:   set listchars=tab:>\ ,trail:-,extends:>,precedes:<,nbsp:+[J

line 56: endif[J

line 57: [J

line 58: if v:version > 703 || v:version == 703 && has("patch541")[J

line 59:   set formatoptions+=j " Delete comment character when joining commented lines[J

line 60: endif[J

line 61: [J

line 62: if has('path_extra')[J

line 63:   setglobal tags-=./tags tags-=./tags; tags^=./tags;[J

line 64: endif[J

line 65: [J

line 66: if &shell =~# 'fish$' && (v:version < 704 || v:version == 704 && !has('patch276'))[J

line 67:   set shell=/bin/bash[J

line 68: endif[J

line 69: [J

line 70: set autoread[J

line 71: [J

line 72: if &history < 1000[J

line 73:   set history=1000[J

line 74: endif[J

line 75: if &tabpagemax < 50[J

line 76:   set tabpagemax=50[J

line 77: endif[J

line 78: if !empty(&viminfo)[J

line 79:   set viminfo^=![J

line 80: endif[J

line 81: set sessionoptions-=options[J

line 82: [J

line 83: " Allow color schemes to do bright colors without forcing bold.[J

line 84: if &t_Co == 8 && $TERM !~# '^linux\|^Eterm'[J

line 85:   set t_Co=16[J

line 86: endif[J

line 87: [J

line 88: " Load matchit.vim, but only if the user hasn't installed a newer version.[J

line 89: if !exists('g:loaded_matchit') && findfile('plugin/matchit.vim', &rtp) ==# ''[J

line 90:   runtime! macros/matchit.vim[J

Searching for "macros/matchit.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/after,/home/patrick/.vim/bundle/tabular/after,/home/patr[J
Searching for "/home/patrick/.vim/macros/matchit.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/macros/matchit.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/macros/matchit.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/macros/matchit.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/macros/matchit.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/macros/matchit.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdcommenter/macros/matchit.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-fugitive/macros/matchit.vim"[J
Searching for "/home/patrick/.vim/bundle/ale/macros/matchit.vim"[J
Searching for "/home/patrick/.vim/bundle/tabular/macros/matchit.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-table-mode/macros/matchit.vim"[J
Searching for "/var/lib/vim/addons/macros/matchit.vim"[J
Searching for "/usr/share/vim/vimfiles/macros/matchit.vim"[J
Searching for "/usr/share/vim/vim80/macros/matchit.vim"[J
chdir(/usr/share/vim/vim80/macros)[J
fchdir() to previous dir[J
line 90: sourcing "/usr/share/vim/vim80/macros/matchit.vim"[J
line 1: " Load the matchit package.[J

line 2: " For those users who were loading the matchit plugin from here.[J

line 3: packadd matchit[J

Searching for "pack/*/opt/matchit" in "/home/patrick/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vimfiles/after,/home/patrick/.vim/after"[J
Searching for "/home/patrick/.vim/pack/*/opt/matchit"[J
Searching for "/usr/share/vim/vimfiles/pack/*/opt/matchit"[J
Searching for "/usr/share/vim/vim80/pack/*/opt/matchit"[J
chdir(/usr/share/vim/vim80/pack/dist/opt)[J
fchdir() to previous dir[J
chdir(/usr/share/vim/vim80/pack/dist/opt/matchit/plugin)[J
fchdir() to previous dir[J
line 3: sourcing "/usr/share/vim/vim80/pack/dist/opt/matchit/plugin/matchit.vim"[J
line 1: "  matchit.vim: (global plugin) Extended "%" matching[J

line 2: "  Last Change: 2016 Aug 21[J

line 3: "  Maintainer:  Benji Fisher PhD   <benji@member.AMS.org>[J

line 4: "  Version:     1.13.2, for Vim 6.3+[J

line 5: "^I^IFix from Fernando Torres included.[J

line 6: "^I^IImprovement from Ken Takata included.[J

line 7: "  URL:^I^Ihttp://www.vim.org/script.php?script_id=39[J

line 8: [J

line 9: " Documentation:[J

line 10: "  The documentation is in a separate file, matchit.txt .[J

line 11: [J

line 12: " Credits:[J

line 13: "  Vim editor by Bram Moolenaar (Thanks, Bram!)[J

line 14: "  Original script and design by Raul Segura Acevedo[J

line 15: "  Support for comments by Douglas Potts[J

line 16: "  Support for back references and other improvements by Benji Fisher[J

line 17: "  Support for many languages by Johannes Zellner[J

line 18: "  Suggestions for improvement, bug reports, and support for additional[J

line 19: "  languages by Jordi-Albert Batalla, Neil Bird, Servatius Brandt, Mark[J

line 20: "  Collett, Stephen Wall, Dany St-Amant, Yuheng Xie, and Johannes Zellner.[J

line 21: [J

line 22: " Debugging:[J

line 23: "  If you'd like to try the built-in debugging commands...[J

line 24: "   :MatchDebug      to activate debugging for the current buffer[J

line 25: "  This saves the values of several key script variables as buffer-local[J

line 26: "  variables.  See the MatchDebug() function, below, for details.[J

line 27: [J

line 28: " TODO:  I should think about multi-line patterns for b:match_words.[J

line 29: "   This would require an option:  how many lines to scan (default 1).[J

line 30: "   This would be useful for Python, maybe also for *ML.[J

line 31: " TODO:  Maybe I should add a menu so that people will actually use some of[J

line 32: "   the features that I have implemented.[J

line 33: " TODO:  Eliminate the MultiMatch function.  Add yet another argument to[J

line 34: "   Match_wrapper() instead.[J

line 35: " TODO:  Allow :let b:match_words = '\(\(foo\)\(bar\)\):\3\2:end\1'[J

line 36: " TODO:  Make backrefs safer by using '\V' (very no-magic).[J

line 37: " TODO:  Add a level of indirection, so that custom % scripts can use my[J

line 38: "   work but extend it.[J

line 39: [J

line 40: " allow user to prevent loading[J

line 41: " and prevent duplicate loading[J

line 42: if exists("loaded_matchit") || &cp[J

line 43:   finish[J

line 44: endif[J

line 45: let loaded_matchit = 1[J

line 46: let s:last_mps = ""[J

line 47: let s:last_words = ":"[J

line 48: let s:patBR = ""[J

line 49: [J

line 50: let s:save_cpo = &cpo[J

line 51: set cpo&vim[J

line 52: [J

line 53: nnoremap <silent> %  :<C-U>call <SID>Match_wrapper('',1,'n') <CR>[J

line 54: nnoremap <silent> g% :<C-U>call <SID>Match_wrapper('',0,'n') <CR>[J

line 55: vnoremap <silent> %  :<C-U>call <SID>Match_wrapper('',1,'v') <CR>m'gv``[J

line 56: vnoremap <silent> g% :<C-U>call <SID>Match_wrapper('',0,'v') <CR>m'gv``[J

line 57: onoremap <silent> %  v:<C-U>call <SID>Match_wrapper('',1,'o') <CR>[J

line 58: onoremap <silent> g% v:<C-U>call <SID>Match_wrapper('',0,'o') <CR>[J

line 59: [J

line 60: " Analogues of [{ and ]} using matching patterns:[J

line 61: nnoremap <silent> [% :<C-U>call <SID>MultiMatch("bW", "n") <CR>[J

line 62: nnoremap <silent> ]% :<C-U>call <SID>MultiMatch("W",  "n") <CR>[J

line 63: vmap [% <Esc>[%m'gv``[J

line 64: vmap ]% <Esc>]%m'gv``[J

line 65: " vnoremap <silent> [% :<C-U>call <SID>MultiMatch("bW", "v") <CR>m'gv``[J

line 66: " vnoremap <silent> ]% :<C-U>call <SID>MultiMatch("W",  "v") <CR>m'gv``[J

line 67: onoremap <silent> [% v:<C-U>call <SID>MultiMatch("bW", "o") <CR>[J

line 68: onoremap <silent> ]% v:<C-U>call <SID>MultiMatch("W",  "o") <CR>[J

line 69: [J

line 70: " text object:[J

line 71: vmap a% <Esc>[%v]%[J

line 72: [J

line 73: " Auto-complete mappings:  (not yet "ready for prime time")[J

line 74: " TODO Read :help write-plugin for the "right" way to let the user[J

line 75: " specify a key binding.[J

line 76: "   let g:match_auto = '<C-]>'[J

line 77: "   let g:match_autoCR = '<C-CR>'[J

line 78: " if exists("g:match_auto")[J

line 79: "   execute "inoremap " . g:match_auto . ' x<Esc>"=<SID>Autocomplete()<CR>Pls'[J

line 80: " endif[J

line 81: " if exists("g:match_autoCR")[J

line 82: "   execute "inoremap " . g:match_autoCR . ' <CR><C-R>=<SID>Autocomplete()<CR>'[J

line 83: " endif[J

line 84: " if exists("g:match_gthhoh")[J

line 85: "   execute "inoremap " . g:match_gthhoh . ' <C-O>:call <SID>Gthhoh()<CR>'[J

line 86: " endif " gthhoh = "Get the heck out of here!"[J

line 87: [J

line 88: let s:notslash = '\\\@<!\%(\\\\\)*'[J

line 89: [J

line 90: function! s:Match_wrapper(word, forward, mode) range[J

line 286: [J

line 287: " Restore options and do some special handling for Operator-pending mode.[J

line 288: " The optional argument is the tail of the matching group.[J

line 289: fun! s:CleanUp(options, mode, startline, startcol, ...)[J

line 315: [J

line 316: " Example (simplified HTML patterns):  if[J

line 317: "   a:groupBR^I= '<\(\k\+\)>:</\1>'[J

line 318: "   a:prefix^I= '^.\{3}\('[J

line 319: "   a:group^I= '<\(\k\+\)>:</\(\k\+\)>'[J

line 320: "   a:suffix^I= '\).\{2}$'[J

line 321: "   a:matchline^I=  "123<tag>12" or "123</tag>12"[J

line 322: " then extract "tag" from a:matchline and return "<tag>:</tag>" .[J

line 323: fun! s:InsertRefs(groupBR, prefix, group, suffix, matchline)[J

line 378: [J

line 379: " Input a comma-separated list of groups with backrefs, such as[J

line 380: "   a:groups = '\(foo\):end\1,\(bar\):end\1'[J

line 381: " and return a comma-separated list of groups with backrefs replaced:[J

line 382: "   return '\(foo\):end\(foo\),\(bar\):end\(bar\)'[J

line 383: fun! s:ParseWords(groups)[J

line 407: [J

line 408: " TODO I think this can be simplified and/or made more efficient.[J

line 409: " TODO What should I do if a:start is out of range?[J

line 410: " Return a regexp that matches all of a:string, such that[J

line 411: " matchstr(a:string, regexp) represents the match for a:pat that starts[J

line 412: " as close to a:start as possible, before being preferred to after, and[J

line 413: " ends after a:start .[J

line 414: " Usage:[J

line 415: " let regexp = s:Wholematch(getline("."), 'foo\|bar', col(".")-1)[J

line 416: " let i      = match(getline("."), regexp)[J

line 417: " let j      = matchend(getline("."), regexp)[J

line 418: " let match  = matchstr(getline("."), regexp)[J

line 419: fun! s:Wholematch(string, pat, start)[J

line 429: [J

line 430: " No extra arguments:  s:Ref(string, d) will[J

line 431: " find the d'th occurrence of '\(' and return it, along with everything up[J

line 432: " to and including the matching '\)'.[J

line 433: " One argument:  s:Ref(string, d, "start") returns the index of the start[J

line 434: " of the d'th '\(' and any other argument returns the length of the group.[J

line 435: " Two arguments:  s:Ref(string, d, "foo", "bar") returns a string to be[J

line 436: " executed, having the effect of[J

line 437: "   :let foo = s:Ref(string, d, "start")[J

line 438: "   :let bar = s:Ref(string, d, "len")[J

line 439: fun! s:Ref(string, d, ...)[J

line 480: [J

line 481: " Count the number of disjoint copies of pattern in string.[J

line 482: " If the pattern is a literal string and contains no '0' or '1' characters[J

line 483: " then s:Count(string, pattern, '0', '1') should be faster than[J

line 484: " s:Count(string, pattern).[J

line 485: fun! s:Count(string, pattern, ...)[J

line 503: [J

line 504: " s:Resolve('\(a\)\(b\)', '\(c\)\2\1\1\2') should return table.word, where[J

line 505: " word = '\(c\)\(b\)\(a\)\3\2' and table = '-32-------'.  That is, the first[J

line 506: " '\1' in target is replaced by '\(a\)' in word, table[1] = 3, and this[J

line 507: " indicates that all other instances of '\1' in target are to be replaced[J

line 508: " by '\3'.  The hard part is dealing with nesting...[J

line 509: " Note that ":" is an illegal character for source and target,[J

line 510: " unless it is preceded by "\".[J

line 511: fun! s:Resolve(source, target, output)[J

line 558: [J

line 559: " Assume a:comma = ",".  Then the format for a:patterns and a:1 is[J

line 560: "   a:patterns = "<pat1>,<pat2>,..."[J

line 561: "   a:1 = "<alt1>,<alt2>,..."[J

line 562: " If <patn> is the first pattern that matches a:string then return <patn>[J

line 563: " if no optional arguments are given; return <patn>,<altn> if a:1 is given.[J

line 564: fun! s:Choose(patterns, string, comma, branch, prefix, suffix, ...)[J

line 599: [J

line 600: " Call this function to turn on debugging information.  Every time the main[J

line 601: " script is run, buffer variables will be saved.  These can be used directly[J

line 602: " or viewed using the menu items below.[J

line 603: if !exists(":MatchDebug")[J

line 604:   command! -nargs=0 MatchDebug call s:Match_debug()[J

line 605: endif[J

line 606: [J

line 607: fun! s:Match_debug()[J

line 628: [J

line 629: " Jump to the nearest unmatched "(" or "if" or "<tag>" if a:spflag == "bW"[J

line 630: " or the nearest unmatched "</tag>" or "endif" or ")" if a:spflag == "W".[J

line 631: " Return a "mark" for the original position, so that[J

line 632: "   let m = MultiMatch("bW", "n") ... execute m[J

line 633: " will return to the original position.  If there is a problem, do not[J

line 634: " move the cursor and return "", unless a count is given, in which case[J

line 635: " go up or down as many levels as possible and again return "".[J

line 636: " TODO This relies on the same patterns as % matching.  It might be a good[J

line 637: " idea to give it its own matching patterns.[J

line 638: fun! s:MultiMatch(spflag, mode)[J

line 736: [J

line 737: " Search backwards for "if" or "while" or "<tag>" or ...[J

line 738: " and return "endif" or "endwhile" or "</tag>" or ... .[J

line 739: " For now, this uses b:match_words and the same script variables[J

line 740: " as s:Match_wrapper() .  Later, it may get its own patterns,[J

line 741: " either from a buffer variable or passed as arguments.[J

line 742: " fun! s:Autocomplete()[J

line 743: "   echo "autocomplete not yet implemented :-("[J

line 744: "   if !exists("b:match_words") || b:match_words == ""[J

line 745: "     return ""[J

line 746: "   end[J

line 747: "   let startpos = s:MultiMatch("bW")[J

line 748: "[J

line 749: "   if startpos == ""[J

line 750: "     return ""[J

line 751: "   endif[J

line 752: "   " - TODO:  figure out whether 'if' or '<tag>' matched, and construct[J

line 753: "   " - the appropriate closing.[J

line 754: "   let matchline = getline(".")[J

line 755: "   let curcol = col(".") - 1[J

line 756: "   " - TODO:  Change the s:all argument if there is a new set of match pats.[J

line 757: "   let regexp = s:Wholematch(matchline, s:all, curcol)[J

line 758: "   let suf = strlen(matchline) - matchend(matchline, regexp)[J

line 759: "   let prefix = (curcol ? '^.\{'  . curcol . '}\%(' : '^\%(')[J

line 760: "   let suffix = (suf ? '\).\{' . suf . '}$'  : '\)$')[J

line 761: "   " Reconstruct the version with unresolved backrefs.[J

line 762: "   let patBR = substitute(b:match_words.',', '[,:]*,[,:]*', ',', 'g')[J

line 763: "   let patBR = substitute(patBR, ':\{2,}', ':', "g")[J

line 764: "   " Now, set group and groupBR to the matching group: 'if:endif' or[J

line 765: "   " 'while:endwhile' or whatever.[J

line 766: "   let group = s:Choose(s:pat, matchline, ",", ":", prefix, suffix, patBR)[J

line 767: "   let i = matchend(group, s:notslash . ",")[J

line 768: "   let groupBR = strpart(group, i)[J

line 769: "   let group = strpart(group, 0, i-1)[J

line 770: "   " Now, matchline =~ prefix . substitute(group,':','\|','g') . suffix[J

line 771: "   if s:do_BR[J

line 772: "     let group = s:InsertRefs(groupBR, prefix, group, suffix, matchline)[J

line 773: "   endif[J

line 774: " " let g:group = group[J

line 775: "[J

line 776: "   " - TODO:  Construct the closing from group.[J

line 777: "   let fake = "end" . expand("<cword>")[J

line 778: "   execute startpos[J

line 779: "   return fake[J

line 780: " endfun[J

line 781: [J

line 782: " Close all open structures.  "Get the heck out of here!"[J

line 783: " fun! s:Gthhoh()[J

line 784: "   let close = s:Autocomplete()[J

line 785: "   while strlen(close)[J

line 786: "     put=close[J

line 787: "     let close = s:Autocomplete()[J

line 788: "   endwhile[J

line 789: " endfun[J

line 790: [J

line 791: " Parse special strings as typical skip arguments for searchpair():[J

line 792: "   s:foo becomes (current syntax item) =~ foo[J

line 793: "   S:foo becomes (current syntax item) !~ foo[J

line 794: "   r:foo becomes (line before cursor) =~ foo[J

line 795: "   R:foo becomes (line before cursor) !~ foo[J

line 796: fun! s:ParseSkip(str)[J

line 813: [J

line 814: let &cpo = s:save_cpo[J

line 815: unlet s:save_cpo[J

line 816: [J

line 817: " vim:sts=2:sw=2:[J

finished sourcing /usr/share/vim/vim80/pack/dist/opt/matchit/plugin/matchit.vim[J
continuing in /usr/share/vim/vim80/macros/matchit.vim[J
line 3: augroup filetypedetect[J

line 3: augroup END[J

Searching for "/usr/share/vim/vimfiles/after/pack/*/opt/matchit"[J
Searching for "/home/patrick/.vim/after/pack/*/opt/matchit"[J
finished sourcing /usr/share/vim/vim80/macros/matchit.vim[J
continuing in /home/patrick/.vim/bundle/vim-sensible/plugin/sensible.vim[J
Searching for "/usr/share/vim/vimfiles/after/macros/matchit.vim"[J
Searching for "/var/lib/vim/addons/after/macros/matchit.vim"[J
Searching for "/home/patrick/.vim/after/macros/matchit.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/macros/matchit.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/after/macros/matchit.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/after/macros/matchit.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/after/macros/matchit.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/after/macros/matchit.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/after/macros/matchit.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdcommenter/after/macros/matchit.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-fugitive/after/macros/matchit.vim"[J
Searching for "/home/patrick/.vim/bundle/ale/after/macros/matchit.vim"[J
Searching for "/home/patrick/.vim/bundle/tabular/after/macros/matchit.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-table-mode/after/macros/matchit.vim"[J
line 91: endif[J

line 92: [J

line 93: inoremap <C-U> <C-G>u<C-U>[J

line 94: [J

line 95: " vim:set ft=vim et sw=2:[J

finished sourcing /home/patrick/.vim/bundle/vim-sensible/plugin/sensible.vim[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/plugin/**/*.vim"[J
chdir(/home/patrick/.vim/bundle/nerdtree/plugin)[J
fchdir() to previous dir[J
sourcing "/home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim"[J
line 1: " ============================================================================[J

line 2: " File:        NERD_tree.vim[J

line 3: " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>[J

line 4: " License:     This program is free software. It comes without any warranty,[J

line 5: "              to the extent permitted by applicable law. You can redistribute[J

line 6: "              it and/or modify it under the terms of the Do What The Fuck You[J

line 7: "              Want To Public License, Version 2, as published by Sam Hocevar.[J

line 8: "              See http://sam.zoy.org/wtfpl/COPYING for more details.[J

line 9: "[J

line 10: " ============================================================================[J

line 11: "[J

line 12: " SECTION: Script init stuff {{{1[J

line 13: "============================================================[J

line 14: if exists("loaded_nerd_tree")[J

line 15:     finish[J

line 16: endif[J

line 17: if v:version < 700[J

line 18:     echoerr "NERDTree: this plugin requires vim >= 7. DOWNLOAD IT! You'll thank me later!"[J

line 19:     finish[J

line 20: endif[J

line 21: let loaded_nerd_tree = 1[J

line 22: [J

line 23: "for line continuation - i.e dont want C in &cpo[J

line 24: let s:old_cpo = &cpo[J

line 25: set cpo&vim[J

line 26: [J

line 27: "Function: s:initVariable() function {{{2[J

line 28: "This function is used to initialise a given variable to a given value. The[J

line 29: "variable is only initialised if it does not exist prior[J

line 30: "[J

line 31: "Args:[J

line 32: "var: the name of the var to be initialised[J

line 33: "value: the value to initialise var to[J

line 34: "[J

line 35: "Returns:[J

line 36: "1 if the var is set, 0 otherwise[J

line 37: function! s:initVariable(var, value)[J

line 44: [J

line 45: "SECTION: Init variable calls and other random constants {{{2[J

line 46: call s:initVariable("g:NERDTreeAutoCenter", 1)[J

calling function <SNR>17_initVariable[J('g:NERDTreeAutoCenter', 1)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeAutoCenter = '1'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 47: call s:initVariable("g:NERDTreeAutoCenterThreshold", 3)[J

calling function <SNR>17_initVariable[J('g:NERDTreeAutoCenterThreshold', 3)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeAutoCenterThreshold = '3'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 48: call s:initVariable("g:NERDTreeCaseSensitiveSort", 0)[J

calling function <SNR>17_initVariable[J('g:NERDTreeCaseSensitiveSort', 0)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeCaseSensitiveSort = '0'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 49: call s:initVariable("g:NERDTreeNaturalSort", 0)[J

calling function <SNR>17_initVariable[J('g:NERDTreeNaturalSort', 0)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeNaturalSort = '0'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 50: call s:initVariable("g:NERDTreeSortHiddenFirst", 1)[J

calling function <SNR>17_initVariable[J('g:NERDTreeSortHiddenFirst', 1)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeSortHiddenFirst = '1'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 51: call s:initVariable("g:NERDTreeChDirMode", 0)[J

calling function <SNR>17_initVariable[J('g:NERDTreeChDirMode', 0)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeChDirMode = '0'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 52: call s:initVariable("g:NERDTreeCreatePrefix", "silent")[J

calling function <SNR>17_initVariable[J('g:NERDTreeCreatePrefix', 'silent')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeCreatePrefix = 'silent'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 53: call s:initVariable("g:NERDTreeMinimalUI", 0)[J

calling function <SNR>17_initVariable[J('g:NERDTreeMinimalUI', 0)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMinimalUI = '0'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 54: if !exists("g:NERDTreeIgnore")[J

line 55:     let g:NERDTreeIgnore = ['\~$'][J

line 56: endif[J

line 57: call s:initVariable("g:NERDTreeBookmarksFile", expand('$HOME') . '/.NERDTreeBookmarks')[J

calling function <SNR>17_initVariable[J('g:NERDTreeBookmarksFile', '/home/patrick/.NERDTreeBookmarks')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeBookmarksFile = '/home/patrick/.NERDTreeBookmarks'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 58: call s:initVariable("g:NERDTreeBookmarksSort", 1)[J

calling function <SNR>17_initVariable[J('g:NERDTreeBookmarksSort', 1)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeBookmarksSort = '1'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 59: call s:initVariable("g:NERDTreeHighlightCursorline", 1)[J

calling function <SNR>17_initVariable[J('g:NERDTreeHighlightCursorline', 1)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeHighlightCursorline = '1'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 60: call s:initVariable("g:NERDTreeHijackNetrw", 1)[J

calling function <SNR>17_initVariable[J('g:NERDTreeHijackNetrw', 1)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeHijackNetrw = '1'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 61: call s:initVariable('g:NERDTreeMarkBookmarks', 1)[J

calling function <SNR>17_initVariable[J('g:NERDTreeMarkBookmarks', 1)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMarkBookmarks = '1'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 62: call s:initVariable("g:NERDTreeMouseMode", 1)[J

calling function <SNR>17_initVariable[J('g:NERDTreeMouseMode', 1)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMouseMode = '1'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 63: call s:initVariable("g:NERDTreeNotificationThreshold", 100)[J

calling function <SNR>17_initVariable[J('g:NERDTreeNotificationThreshold', 100)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeNotificationThreshold = '100'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 64: call s:initVariable("g:NERDTreeQuitOnOpen", 0)[J

calling function <SNR>17_initVariable[J('g:NERDTreeQuitOnOpen', 0)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeQuitOnOpen = '0'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 65: call s:initVariable("g:NERDTreeRespectWildIgnore", 0)[J

calling function <SNR>17_initVariable[J('g:NERDTreeRespectWildIgnore', 0)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeRespectWildIgnore = '0'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 66: call s:initVariable("g:NERDTreeShowBookmarks", 0)[J

calling function <SNR>17_initVariable[J('g:NERDTreeShowBookmarks', 0)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeShowBookmarks = '0'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 67: call s:initVariable("g:NERDTreeShowFiles", 1)[J

calling function <SNR>17_initVariable[J('g:NERDTreeShowFiles', 1)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeShowFiles = '1'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 68: call s:initVariable("g:NERDTreeShowHidden", 0)[J

calling function <SNR>17_initVariable[J('g:NERDTreeShowHidden', 0)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeShowHidden = '0'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 69: call s:initVariable("g:NERDTreeShowLineNumbers", 0)[J

calling function <SNR>17_initVariable[J('g:NERDTreeShowLineNumbers', 0)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeShowLineNumbers = '0'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 70: call s:initVariable("g:NERDTreeSortDirs", 1)[J

calling function <SNR>17_initVariable[J('g:NERDTreeSortDirs', 1)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeSortDirs = '1'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 71: [J

line 72: if !nerdtree#runningWindows()[J

Searching for "autoload/nerdtree.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vim80/pack/dist/opt/matchit,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/after,/hom[J
Searching for "/home/patrick/.vim/autoload/nerdtree.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/autoload/nerdtree.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/autoload/nerdtree.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/autoload/nerdtree.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/autoload/nerdtree.vim"[J
chdir(/home/patrick/.vim/bundle/nerdtree/autoload)[J
fchdir() to previous dir[J
line 72: sourcing "/home/patrick/.vim/bundle/nerdtree/autoload/nerdtree.vim"[J
line 1: if exists("g:loaded_nerdtree_autoload")[J

line 2:     finish[J

line 3: endif[J

line 4: let g:loaded_nerdtree_autoload = 1[J

line 5: [J

line 6: function! nerdtree#version()[J

line 9: [J

line 10: " SECTION: General Functions {{{1[J

line 11: "============================================================[J

line 12: [J

line 13: "FUNCTION: nerdtree#checkForBrowse(dir) {{{2[J

line 14: "inits a window tree in the current buffer if appropriate[J

line 15: function! nerdtree#checkForBrowse(dir)[J

line 26: [J

line 27: "FUNCTION: s:reuseWin(dir) {{{2[J

line 28: "finds a NERDTree buffer with root of dir, and opens it.[J

line 29: function! s:reuseWin(dir) abort[J

line 48: [J

line 49: " FUNCTION: nerdtree#completeBookmarks(A,L,P) {{{2[J

line 50: " completion function for the bookmark commands[J

line 51: function! nerdtree#completeBookmarks(A,L,P)[J

line 54: [J

line 55: "FUNCTION: nerdtree#compareNodes(dir) {{{2[J

line 56: function! nerdtree#compareNodes(n1, n2)[J

line 59: [J

line 60: "FUNCTION: nerdtree#compareNodesBySortKey(n1, n2) {{{2[J

line 61: function! nerdtree#compareNodesBySortKey(n1, n2)[J

line 94: [J

line 95: " FUNCTION: nerdtree#deprecated(func, [msg]) {{{2[J

line 96: " Issue a deprecation warning for a:func. If a second arg is given, use this[J

line 97: " as the deprecation message[J

line 98: function! nerdtree#deprecated(func, ...)[J

line 109: [J

line 110: " FUNCTION: nerdtree#exec(cmd) {{{2[J

line 111: " Same as :exec cmd but with eventignore set for the duration[J

line 112: " to disable the autocommands used by NERDTree (BufEnter,[J

line 113: " BufLeave and VimEnter)[J

line 114: function! nerdtree#exec(cmd)[J

line 120: [J

line 121: " FUNCTION: nerdtree#has_opt(options, name) {{{2[J

line 122: function! nerdtree#has_opt(options, name)[J

line 125: [J

line 126: " FUNCTION: nerdtree#loadClassFiles() {{{2[J

line 127: function! nerdtree#loadClassFiles()[J

line 143: [J

line 144: " FUNCTION: nerdtree#postSourceActions() {{{2[J

line 145: function! nerdtree#postSourceActions()[J

line 152: [J

line 153: "FUNCTION: nerdtree#runningWindows(dir) {{{2[J

line 154: function! nerdtree#runningWindows()[J

line 157: [J

line 158: " SECTION: View Functions {{{1[J

line 159: "============================================================[J

line 160: [J

line 161: "FUNCTION: nerdtree#echo  {{{2[J

line 162: "A wrapper for :echo. Appends 'NERDTree:' on the front of all messages[J

line 163: "[J

line 164: "Args:[J

line 165: "msg: the message to echo[J

line 166: function! nerdtree#echo(msg)[J

line 170: [J

line 171: "FUNCTION: nerdtree#echoError {{{2[J

line 172: "Wrapper for nerdtree#echo, sets the message type to errormsg for this message[J

line 173: "Args:[J

line 174: "msg: the message to echo[J

line 175: function! nerdtree#echoError(msg)[J

line 180: [J

line 181: "FUNCTION: nerdtree#echoWarning {{{2[J

line 182: "Wrapper for nerdtree#echo, sets the message type to warningmsg for this message[J

line 183: "Args:[J

line 184: "msg: the message to echo[J

line 185: function! nerdtree#echoWarning(msg)[J

line 190: [J

line 191: "FUNCTION: nerdtree#renderView {{{2[J

line 192: function! nerdtree#renderView()[J

line 195: [J

line 196: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /home/patrick/.vim/bundle/nerdtree/autoload/nerdtree.vim[J
continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J
calling function nerdtree#runningWindows[J()

line 1:     return has("win16") || has("win32") || has("win64")[J

function nerdtree#runningWindows returning #0[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 73:     call s:initVariable("g:NERDTreeDirArrowExpandable", "▸")[J

calling function <SNR>17_initVariable[J('g:NERDTreeDirArrowExpandable', '▸')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeDirArrowExpandable = '▸'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 74:     call s:initVariable("g:NERDTreeDirArrowCollapsible", "▾")[J

calling function <SNR>17_initVariable[J('g:NERDTreeDirArrowCollapsible', '▾')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeDirArrowCollapsible = '▾'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 75: else[J

line 76:     call s:initVariable("g:NERDTreeDirArrowExpandable", "+")[J

line 77:     call s:initVariable("g:NERDTreeDirArrowCollapsible", "~")[J

line 78: endif[J

line 79: call s:initVariable("g:NERDTreeCascadeOpenSingleChildDir", 1)[J

calling function <SNR>17_initVariable[J('g:NERDTreeCascadeOpenSingleChildDir', 1)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeCascadeOpenSingleChildDir = '1'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 80: call s:initVariable("g:NERDTreeCascadeSingleChildDir", 1)[J

calling function <SNR>17_initVariable[J('g:NERDTreeCascadeSingleChildDir', 1)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeCascadeSingleChildDir = '1'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 81: [J

line 82: if !exists("g:NERDTreeSortOrder")[J

line 83:     let g:NERDTreeSortOrder = ['\/$', '*', '\.swp$',  '\.bak$', '\~$'][J

line 84: else[J

line 85:     "if there isnt a * in the sort sequence then add one[J

line 86:     if count(g:NERDTreeSortOrder, '*') < 1[J

line 87:         call add(g:NERDTreeSortOrder, '*')[J

line 88:     endif[J

line 89: endif[J

line 90: [J

line 91: call s:initVariable("g:NERDTreeGlyphReadOnly", "RO")[J

calling function <SNR>17_initVariable[J('g:NERDTreeGlyphReadOnly', 'RO')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeGlyphReadOnly = 'RO'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 92: [J

line 93: if !exists('g:NERDTreeStatusline')[J

line 94: [J

line 95:     "the exists() crap here is a hack to stop vim spazzing out when[J

line 96:     "loading a session that was created with an open nerd tree. It spazzes[J

line 97:     "because it doesnt store b:NERDTree(its a b: var, and its a hash)[J

line 98:     let g:NERDTreeStatusline = "%{exists('b:NERDTree')?b:NERDTree.root.path.str():''}"[J

line 99: [J

line 100: endif[J

line 101: call s:initVariable("g:NERDTreeWinPos", "left")[J

calling function <SNR>17_initVariable[J('g:NERDTreeWinPos', 'left')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeWinPos = 'left'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 102: call s:initVariable("g:NERDTreeWinSize", 31)[J

calling function <SNR>17_initVariable[J('g:NERDTreeWinSize', 31)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeWinSize = '31'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 103: [J

line 104: "init the shell commands that will be used to copy nodes, and remove dir trees[J

line 105: "[J

line 106: "Note: the space after the command is important[J

line 107: if nerdtree#runningWindows()[J

calling function nerdtree#runningWindows[J()

line 1:     return has("win16") || has("win32") || has("win64")[J

function nerdtree#runningWindows returning #0[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 108:     call s:initVariable("g:NERDTreeRemoveDirCmd", 'rmdir /s /q ')[J

line 109:     call s:initVariable("g:NERDTreeCopyDirCmd", 'xcopy /s /e /i /y /q ')[J

line 110:     call s:initVariable("g:NERDTreeCopyFileCmd", 'copy /y ')[J

line 111: else[J

line 112:     call s:initVariable("g:NERDTreeRemoveDirCmd", 'rm -rf ')[J

calling function <SNR>17_initVariable[J('g:NERDTreeRemoveDirCmd', 'rm -rf ')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeRemoveDirCmd = 'rm -rf '[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 113:     call s:initVariable("g:NERDTreeCopyCmd", 'cp -r ')[J

calling function <SNR>17_initVariable[J('g:NERDTreeCopyCmd', 'cp -r ')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeCopyCmd = 'cp -r '[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 114: endif[J

line 115: [J

line 116: [J

line 117: "SECTION: Init variable calls for key mappings {{{2[J

line 118: call s:initVariable("g:NERDTreeMapActivateNode", "o")[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapActivateNode', 'o')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapActivateNode = 'o'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 119: call s:initVariable("g:NERDTreeMapChangeRoot", "C")[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapChangeRoot', 'C')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapChangeRoot = 'C'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 120: call s:initVariable("g:NERDTreeMapChdir", "cd")[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapChdir', 'cd')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapChdir = 'cd'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 121: call s:initVariable("g:NERDTreeMapCloseChildren", "X")[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapCloseChildren', 'X')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapCloseChildren = 'X'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 122: call s:initVariable("g:NERDTreeMapCloseDir", "x")[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapCloseDir', 'x')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapCloseDir = 'x'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 123: call s:initVariable("g:NERDTreeMapDeleteBookmark", "D")[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapDeleteBookmark', 'D')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapDeleteBookmark = 'D'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 124: call s:initVariable("g:NERDTreeMapMenu", "m")[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapMenu', 'm')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapMenu = 'm'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 125: call s:initVariable("g:NERDTreeMapHelp", "?")[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapHelp', '?')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapHelp = '?'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 126: call s:initVariable("g:NERDTreeMapJumpFirstChild", "K")[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapJumpFirstChild', 'K')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapJumpFirstChild = 'K'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 127: call s:initVariable("g:NERDTreeMapJumpLastChild", "J")[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapJumpLastChild', 'J')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapJumpLastChild = 'J'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 128: call s:initVariable("g:NERDTreeMapJumpNextSibling", "<C-j>")[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapJumpNextSibling', '<C-j>')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapJumpNextSibling = '<C-j>'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 129: call s:initVariable("g:NERDTreeMapJumpParent", "p")[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapJumpParent', 'p')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapJumpParent = 'p'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 130: call s:initVariable("g:NERDTreeMapJumpPrevSibling", "<C-k>")[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapJumpPrevSibling', '<C-k>')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapJumpPrevSibling = '<C-k>'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 131: call s:initVariable("g:NERDTreeMapJumpRoot", "P")[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapJumpRoot', 'P')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapJumpRoot = 'P'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 132: call s:initVariable("g:NERDTreeMapOpenExpl", "e")[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapOpenExpl', 'e')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapOpenExpl = 'e'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 133: call s:initVariable("g:NERDTreeMapOpenInTab", "t")[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapOpenInTab', 't')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapOpenInTab = 't'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 134: call s:initVariable("g:NERDTreeMapOpenInTabSilent", "T")[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapOpenInTabSilent', 'T')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapOpenInTabSilent = 'T'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 135: call s:initVariable("g:NERDTreeMapOpenRecursively", "O")[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapOpenRecursively', 'O')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapOpenRecursively = 'O'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 136: call s:initVariable("g:NERDTreeMapOpenSplit", "i")[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapOpenSplit', 'i')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapOpenSplit = 'i'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 137: call s:initVariable("g:NERDTreeMapOpenVSplit", "s")[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapOpenVSplit', 's')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapOpenVSplit = 's'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 138: call s:initVariable("g:NERDTreeMapPreview", "g" . NERDTreeMapActivateNode)[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapPreview', 'go')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapPreview = 'go'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 139: call s:initVariable("g:NERDTreeMapPreviewSplit", "g" . NERDTreeMapOpenSplit)[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapPreviewSplit', 'gi')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapPreviewSplit = 'gi'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 140: call s:initVariable("g:NERDTreeMapPreviewVSplit", "g" . NERDTreeMapOpenVSplit)[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapPreviewVSplit', 'gs')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapPreviewVSplit = 'gs'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 141: call s:initVariable("g:NERDTreeMapQuit", "q")[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapQuit', 'q')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapQuit = 'q'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 142: call s:initVariable("g:NERDTreeMapRefresh", "r")[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapRefresh', 'r')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapRefresh = 'r'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 143: call s:initVariable("g:NERDTreeMapRefreshRoot", "R")[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapRefreshRoot', 'R')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapRefreshRoot = 'R'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 144: call s:initVariable("g:NERDTreeMapToggleBookmarks", "B")[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapToggleBookmarks', 'B')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapToggleBookmarks = 'B'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 145: call s:initVariable("g:NERDTreeMapToggleFiles", "F")[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapToggleFiles', 'F')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapToggleFiles = 'F'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 146: call s:initVariable("g:NERDTreeMapToggleFilters", "f")[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapToggleFilters', 'f')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapToggleFilters = 'f'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 147: call s:initVariable("g:NERDTreeMapToggleHidden", "I")[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapToggleHidden', 'I')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapToggleHidden = 'I'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 148: call s:initVariable("g:NERDTreeMapToggleZoom", "A")[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapToggleZoom', 'A')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapToggleZoom = 'A'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 149: call s:initVariable("g:NERDTreeMapUpdir", "u")[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapUpdir', 'u')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapUpdir = 'u'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 150: call s:initVariable("g:NERDTreeMapUpdirKeepOpen", "U")[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapUpdirKeepOpen', 'U')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapUpdirKeepOpen = 'U'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 151: call s:initVariable("g:NERDTreeMapCWD", "CD")[J

calling function <SNR>17_initVariable[J('g:NERDTreeMapCWD', 'CD')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapCWD = 'CD'[J

line 3:         return 1[J

function <SNR>17_initVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 152: [J

line 153: "SECTION: Load class files{{{2[J

line 154: call nerdtree#loadClassFiles()[J

calling function nerdtree#loadClassFiles[J()

line 1:     runtime lib/nerdtree/path.vim[J

Searching for "lib/nerdtree/path.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vim80/pack/dist/opt/matchit,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/after,/hom[J
Searching for "/home/patrick/.vim/lib/nerdtree/path.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/lib/nerdtree/path.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/lib/nerdtree/path.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/lib/nerdtree/path.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/lib/nerdtree/path.vim"[J
chdir(/home/patrick/.vim/bundle/nerdtree/lib/nerdtree)[J
fchdir() to previous dir[J
line 1: sourcing "/home/patrick/.vim/bundle/nerdtree/lib/nerdtree/path.vim"[J
line 1: " ============================================================================[J

line 2: " CLASS: Path[J

line 3: "[J

line 4: " The Path class provides an abstracted representation of a file system[J

line 5: " pathname.  Various operations on pathnames are provided and a number of[J

line 6: " representations of a given path name can be accessed here.[J

line 7: " ============================================================================[J

line 8: [J

line 9: [J

line 10: " This constant is used throughout this script for sorting purposes.[J

line 11: let s:NERDTreeSortStarIndex = index(g:NERDTreeSortOrder, '*')[J

line 12: lockvar s:NERDTreeSortStarIndex[J

line 13: [J

line 14: let s:Path = {}[J

line 15: let g:NERDTreePath = s:Path[J

line 16: [J

line 17: " FUNCTION: Path.AbsolutePathFor(str) {{{1[J

line 18: function! s:Path.AbsolutePathFor(str)[J

line 33: [J

line 34: " FUNCTION: Path.bookmarkNames() {{{1[J

line 35: function! s:Path.bookmarkNames()[J

line 41: [J

line 42: " FUNCTION: Path.cacheDisplayString() {{{1[J

line 43: function! s:Path.cacheDisplayString() abort[J

line 68: [J

line 69: " FUNCTION: Path.changeToDir() {{{1[J

line 70: function! s:Path.changeToDir()[J

line 83: [J

line 84: " FUNCTION: Path.compareTo() {{{1[J

line 85: "[J

line 86: " Compares this Path to the given path and returns 0 if they are equal, -1 if[J

line 87: " this Path is "less than" the given path, or 1 if it is "greater".[J

line 88: "[J

line 89: " Args:[J

line 90: " path: the path object to compare this to[J

line 91: "[J

line 92: " Return:[J

line 93: " 1, -1 or 0[J

line 94: function! s:Path.compareTo(path)[J

line 127: [J

line 128: " FUNCTION: Path.Create(fullpath) {{{1[J

line 129: "[J

line 130: " Factory method.[J

line 131: "[J

line 132: " Creates a path object with the given path. The path is also created on the[J

line 133: " filesystem. If the path already exists, a NERDTree.Path.Exists exception is[J

line 134: " thrown. If any other errors occur, a NERDTree.Path exception is thrown.[J

line 135: "[J

line 136: " Args:[J

line 137: " fullpath: the full filesystem path to the file/dir to create[J

line 138: function! s:Path.Create(fullpath)[J

line 164: [J

line 165: " FUNCTION: Path.copy(dest) {{{1[J

line 166: "[J

line 167: " Copies the file/dir represented by this Path to the given location[J

line 168: "[J

line 169: " Args:[J

line 170: " dest: the location to copy this dir/file to[J

line 171: function! s:Path.copy(dest)[J

line 190: [J

line 191: " FUNCTION: Path.CopyingSupported() {{{1[J

line 192: "[J

line 193: " returns 1 if copying is supported for this OS[J

line 194: function! s:Path.CopyingSupported()[J

line 197: [J

line 198: " FUNCTION: Path.copyingWillOverwrite(dest) {{{1[J

line 199: "[J

line 200: " returns 1 if copy this path to the given location will cause files to[J

line 201: " overwritten[J

line 202: "[J

line 203: " Args:[J

line 204: " dest: the location this path will be copied to[J

line 205: function! s:Path.copyingWillOverwrite(dest)[J

line 217: [J

line 218: " FUNCTION: Path.createParentDirectories(path) {{{1[J

line 219: "[J

line 220: " create parent directories for this path if needed[J

line 221: " without throwing any errors if those directories already exist[J

line 222: "[J

line 223: " Args:[J

line 224: " path: full path of the node whose parent directories may need to be created[J

line 225: function! s:Path.createParentDirectories(path)[J

line 231: [J

line 232: " FUNCTION: Path.delete() {{{1[J

line 233: "[J

line 234: " Deletes the file or directory represented by this path.[J

line 235: "[J

line 236: " Throws NERDTree.Path.Deletion exceptions[J

line 237: function! s:Path.delete()[J

line 259: [J

line 260: " FUNCTION: Path.displayString() {{{1[J

line 261: "[J

line 262: " Returns a string that specifies how the path should be represented as a[J

line 263: " string[J

line 264: function! s:Path.displayString()[J

line 271: [J

line 272: " FUNCTION: Path.edit() {{{1[J

line 273: function! s:Path.edit()[J

line 276: [J

line 277: " FUNCTION: Path.extractDriveLetter(fullpath) {{{1[J

line 278: "[J

line 279: " If running windows, cache the drive letter for this path[J

line 280: function! s:Path.extractDriveLetter(fullpath)[J

line 294: [J

line 295: " FUNCTION: Path.exists() {{{1[J

line 296: " return 1 if this path points to a location that is readable or is a directory[J

line 297: function! s:Path.exists()[J

line 301: [J

line 302: " FUNCTION: Path._escChars() {{{1[J

line 303: function! s:Path._escChars()[J

line 310: [J

line 311: " FUNCTION: Path.getDir() {{{1[J

line 312: "[J

line 313: " Returns this path if it is a directory, else this paths parent.[J

line 314: "[J

line 315: " Return:[J

line 316: " a Path object[J

line 317: function! s:Path.getDir()[J

line 324: [J

line 325: " FUNCTION: Path.getParent() {{{1[J

line 326: "[J

line 327: " Returns a new path object for this paths parent[J

line 328: "[J

line 329: " Return:[J

line 330: " a new Path object[J

line 331: function! s:Path.getParent()[J

line 340: [J

line 341: " FUNCTION: Path.getLastPathComponent(dirSlash) {{{1[J

line 342: "[J

line 343: " Gets the last part of this path.[J

line 344: "[J

line 345: " Args:[J

line 346: " dirSlash: if 1 then a trailing slash will be added to the returned value for[J

line 347: " directory nodes.[J

line 348: function! s:Path.getLastPathComponent(dirSlash)[J

line 358: [J

line 359: " FUNCTION: Path.getSortOrderIndex() {{{1[J

line 360: " returns the index of the pattern in g:NERDTreeSortOrder that this path matches[J

line 361: function! s:Path.getSortOrderIndex()[J

line 371: [J

line 372: " FUNCTION: Path._splitChunks(path) {{{1[J

line 373: " returns a list of path chunks[J

line 374: function! s:Path._splitChunks(path)[J

line 386: [J

line 387: " FUNCTION: Path.getSortKey() {{{1[J

line 388: " returns a key used in compare function for sorting[J

line 389: function! s:Path.getSortKey()[J

line 407: [J

line 408: [J

line 409: " FUNCTION: Path.isUnixHiddenFile() {{{1[J

line 410: " check for unix hidden files[J

line 411: function! s:Path.isUnixHiddenFile()[J

line 414: [J

line 415: " FUNCTION: Path.isUnixHiddenPath() {{{1[J

line 416: " check for unix path with hidden components[J

line 417: function! s:Path.isUnixHiddenPath()[J

line 429: [J

line 430: " FUNCTION: Path.ignore(nerdtree) {{{1[J

line 431: " returns true if this path should be ignored[J

line 432: function! s:Path.ignore(nerdtree)[J

line 459: [J

line 460: " FUNCTION: Path._ignorePatternMatches(pattern) {{{1[J

line 461: " returns true if this path matches the given ignore pattern[J

line 462: function! s:Path._ignorePatternMatches(pattern)[J

line 478: [J

line 479: " FUNCTION: Path.isAncestor(path) {{{1[J

line 480: " return 1 if this path is somewhere above the given path in the filesystem.[J

line 481: "[J

line 482: " a:path should be a dir[J

line 483: function! s:Path.isAncestor(path)[J

line 492: [J

line 493: " FUNCTION: Path.isUnder(path) {{{1[J

line 494: " return 1 if this path is somewhere under the given path in the filesystem.[J

line 495: function! s:Path.isUnder(path)[J

line 504: [J

line 505: " FUNCTION: Path.JoinPathStrings(...) {{{1[J

line 506: function! s:Path.JoinPathStrings(...)[J

line 513: [J

line 514: " FUNCTION: Path.equals() {{{1[J

line 515: "[J

line 516: " Determines whether 2 path objects are "equal".[J

line 517: " They are equal if the paths they represent are the same[J

line 518: "[J

line 519: " Args:[J

line 520: " path: the other path obj to compare this with[J

line 521: function! s:Path.equals(path)[J

line 524: [J

line 525: " FUNCTION: Path.New() {{{1[J

line 526: " The Constructor for the Path object[J

line 527: function! s:Path.New(path)[J

line 537: [J

line 538: " FUNCTION: Path.Slash() {{{1[J

line 539: " Return the path separator used by the underlying file system.  Special[J

line 540: " consideration is taken for the use of the 'shellslash' option on Windows[J

line 541: " systems.[J

line 542: function! s:Path.Slash()[J

line 554: [J

line 555: " FUNCTION: Path.Resolve() {{{1[J

line 556: " Invoke the vim resolve() function and return the result[J

line 557: " This is necessary because in some versions of vim resolve() removes trailing[J

line 558: " slashes while in other versions it doesn't.  This always removes the trailing[J

line 559: " slash[J

line 560: function! s:Path.Resolve(path)[J

line 564: [J

line 565: " FUNCTION: Path.readInfoFromDisk(fullpath) {{{1[J

line 566: "[J

line 567: "[J

line 568: " Throws NERDTree.Path.InvalidArguments exception.[J

line 569: function! s:Path.readInfoFromDisk(fullpath)[J

line 618: [J

line 619: " FUNCTION: Path.refresh(nerdtree) {{{1[J

line 620: function! s:Path.refresh(nerdtree)[J

line 625: [J

line 626: " FUNCTION: Path.refreshFlags(nerdtree) {{{1[J

line 627: function! s:Path.refreshFlags(nerdtree)[J

line 631: [J

line 632: " FUNCTION: Path.rename() {{{1[J

line 633: "[J

line 634: " Renames this node on the filesystem[J

line 635: function! s:Path.rename(newPath)[J

line 652: [J

line 653: " FUNCTION: Path.str() {{{1[J

line 654: " Return a string representation of this Path object.[J

line 655: "[J

line 656: " Args:[J

line 657: " This function takes a single dictionary (optional) with keys and values that[J

line 658: " specify how the returned pathname should be formatted.[J

line 659: "[J

line 660: " The dictionary may have the following keys:[J

line 661: "  'format'[J

line 662: "  'escape'[J

line 663: "  'truncateTo'[J

line 664: "[J

line 665: " The 'format' key may have a value of:[J

line 666: "  'Cd' - a string to be used with ":cd" and similar commands[J

line 667: "  'Edit' - a string to be used with ":edit" and similar commands[J

line 668: "  'UI' - a string to be displayed in the NERDTree user interface[J

line 669: "[J

line 670: " The 'escape' key, if specified, will cause the output to be escaped with[J

line 671: " Vim's internal "shellescape()" function.[J

line 672: "[J

line 673: " The 'truncateTo' key shortens the length of the path to that given by the[J

line 674: " value associated with 'truncateTo'. A '<' is prepended.[J

line 675: function! s:Path.str(...)[J

line 708: [J

line 709: " FUNCTION: Path._strForUI() {{{1[J

line 710: function! s:Path._strForUI()[J

line 717: [J

line 718: " FUNCTION: Path._strForCd() {{{1[J

line 719: " Return a string representation of this Path that is suitable for use as an[J

line 720: " argument to Vim's internal ":cd" command.[J

line 721: function! s:Path._strForCd()[J

line 724: [J

line 725: " FUNCTION: Path._strForEdit() {{{1[J

line 726: " Return a string representation of this Path that is suitable for use as an[J

line 727: " argument to Vim's internal ":edit" command.[J

line 728: function! s:Path._strForEdit()[J

line 747: [J

line 748: " FUNCTION: Path._strForGlob() {{{1[J

line 749: function! s:Path._strForGlob()[J

line 764: [J

line 765: " FUNCTION: Path._str() {{{1[J

line 766: " Return the absolute pathname associated with this Path object.  The pathname[J

line 767: " returned is appropriate for the underlying file system.[J

line 768: function! s:Path._str()[J

line 778: [J

line 779: " FUNCTION: Path.strTrunk() {{{1[J

line 780: " Gets the path without the last segment on the end.[J

line 781: function! s:Path.strTrunk()[J

line 784: [J

line 785: " FUNCTION: Path.tabnr() {{{1[J

line 786: " return the number of the first tab that is displaying this file[J

line 787: "[J

line 788: " return 0 if no tab was found[J

line 789: function! s:Path.tabnr()[J

line 800: [J

line 801: " FUNCTION: Path.WinToUnixPath(pathstr){{{1[J

line 802: " Takes in a windows path and returns the unix equiv[J

line 803: "[J

line 804: " A class level method[J

line 805: "[J

line 806: " Args:[J

line 807: " pathstr: the windows path to convert[J

line 808: function! s:Path.WinToUnixPath(pathstr)[J

line 826: [J

line 827: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /home/patrick/.vim/bundle/nerdtree/lib/nerdtree/path.vim[J
continuing in function nerdtree#loadClassFiles[J
line 2:     runtime lib/nerdtree/menu_controller.vim[J

Searching for "lib/nerdtree/menu_controller.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vim80/pack/dist/opt/matchit,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale[J
Searching for "/home/patrick/.vim/lib/nerdtree/menu_controller.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/lib/nerdtree/menu_controller.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/lib/nerdtree/menu_controller.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/lib/nerdtree/menu_controller.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/lib/nerdtree/menu_controller.vim"[J
chdir(/home/patrick/.vim/bundle/nerdtree/lib/nerdtree)[J
fchdir() to previous dir[J
line 2: sourcing "/home/patrick/.vim/bundle/nerdtree/lib/nerdtree/menu_controller.vim"[J
line 1: "CLASS: MenuController[J

line 2: "============================================================[J

line 3: let s:MenuController = {}[J

line 4: let g:NERDTreeMenuController = s:MenuController[J

line 5: [J

line 6: "FUNCTION: MenuController.New(menuItems) {{{1[J

line 7: "create a new menu controller that operates on the given menu items[J

line 8: function! s:MenuController.New(menuItems)[J

line 17: [J

line 18: "FUNCTION: MenuController.showMenu() {{{1[J

line 19: "start the main loop of the menu and get the user to choose/execute a menu[J

line 20: "item[J

line 21: function! s:MenuController.showMenu()[J

line 43: [J

line 44: "FUNCTION: MenuController._echoPrompt() {{{1[J

line 45: function! s:MenuController._echoPrompt()[J

line 57: [J

line 58: "FUNCTION: MenuController._current(key) {{{1[J

line 59: "get the MenuItem that is currently selected[J

line 60: function! s:MenuController._current()[J

line 63: [J

line 64: "FUNCTION: MenuController._handleKeypress(key) {{{1[J

line 65: "change the selection (if appropriate) and return 1 if the user has made[J

line 66: "their choice, 0 otherwise[J

line 67: function! s:MenuController._handleKeypress(key)[J

line 89: [J

line 90: "FUNCTION: MenuController._allIndexesFor(shortcut) {{{1[J

line 91: "get indexes to all menu items with the given shortcut[J

line 92: function! s:MenuController._allIndexesFor(shortcut)[J

line 103: [J

line 104: "FUNCTION: MenuController._nextIndexFor(shortcut) {{{1[J

line 105: "get the index to the next menu item with the given shortcut, starts from the[J

line 106: "current cursor location and wraps around to the top again if need be[J

line 107: function! s:MenuController._nextIndexFor(shortcut)[J

line 122: [J

line 123: "FUNCTION: MenuController._setCmdheight() {{{1[J

line 124: "sets &cmdheight to whatever is needed to display the menu[J

line 125: function! s:MenuController._setCmdheight()[J

line 128: [J

line 129: "FUNCTION: MenuController._saveOptions() {{{1[J

line 130: "set any vim options that are required to make the menu work (saving their old[J

line 131: "values)[J

line 132: function! s:MenuController._saveOptions()[J

line 138: [J

line 139: "FUNCTION: MenuController._restoreOptions() {{{1[J

line 140: "restore the options we saved in _saveOptions()[J

line 141: function! s:MenuController._restoreOptions()[J

line 145: [J

line 146: "FUNCTION: MenuController._cursorDown() {{{1[J

line 147: "move the cursor to the next menu item, skipping separators[J

line 148: function! s:MenuController._cursorDown()[J

line 162: [J

line 163: "FUNCTION: MenuController._cursorUp() {{{1[J

line 164: "move the cursor to the previous menu item, skipping separators[J

line 165: function! s:MenuController._cursorUp()[J

line 179: [J

line 180: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /home/patrick/.vim/bundle/nerdtree/lib/nerdtree/menu_controller.vim[J
continuing in function nerdtree#loadClassFiles[J
line 3:     runtime lib/nerdtree/menu_item.vim[J

Searching for "lib/nerdtree/menu_item.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vim80/pack/dist/opt/matchit,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/after[J
Searching for "/home/patrick/.vim/lib/nerdtree/menu_item.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/lib/nerdtree/menu_item.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/lib/nerdtree/menu_item.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/lib/nerdtree/menu_item.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/lib/nerdtree/menu_item.vim"[J
chdir(/home/patrick/.vim/bundle/nerdtree/lib/nerdtree)[J
fchdir() to previous dir[J
line 3: sourcing "/home/patrick/.vim/bundle/nerdtree/lib/nerdtree/menu_item.vim"[J
line 1: "CLASS: MenuItem[J

line 2: "============================================================[J

line 3: let s:MenuItem = {}[J

line 4: let g:NERDTreeMenuItem = s:MenuItem[J

line 5: [J

line 6: "FUNCTION: MenuItem.All() {{{1[J

line 7: "get all top level menu items[J

line 8: function! s:MenuItem.All()[J

line 14: [J

line 15: "FUNCTION: MenuItem.AllEnabled() {{{1[J

line 16: "get all top level menu items that are currently enabled[J

line 17: function! s:MenuItem.AllEnabled()[J

line 26: [J

line 27: "FUNCTION: MenuItem.Create(options) {{{1[J

line 28: "make a new menu item and add it to the global list[J

line 29: function! s:MenuItem.Create(options)[J

line 54: [J

line 55: "FUNCTION: MenuItem.CreateSeparator(options) {{{1[J

line 56: "make a new separator menu item and add it to the global list[J

line 57: function! s:MenuItem.CreateSeparator(options)[J

line 65: [J

line 66: "FUNCTION: MenuItem.CreateSubmenu(options) {{{1[J

line 67: "make a new submenu and add it to global list[J

line 68: function! s:MenuItem.CreateSubmenu(options)[J

line 74: [J

line 75: "FUNCTION: MenuItem.enabled() {{{1[J

line 76: "return 1 if this menu item should be displayed[J

line 77: "[J

line 78: "delegates off to the isActiveCallback, and defaults to 1 if no callback was[J

line 79: "specified[J

line 80: function! s:MenuItem.enabled()[J

line 86: [J

line 87: "FUNCTION: MenuItem.execute() {{{1[J

line 88: "perform the action behind this menu item, if this menuitem has children then[J

line 89: "display a new menu for them, otherwise deletegate off to the menuitem's[J

line 90: "callback[J

line 91: function! s:MenuItem.execute()[J

line 101: [J

line 102: "FUNCTION: MenuItem.isSeparator() {{{1[J

line 103: "return 1 if this menuitem is a separator[J

line 104: function! s:MenuItem.isSeparator()[J

line 107: [J

line 108: "FUNCTION: MenuItem.isSubmenu() {{{1[J

line 109: "return 1 if this menuitem is a submenu[J

line 110: function! s:MenuItem.isSubmenu()[J

line 113: [J

line 114: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /home/patrick/.vim/bundle/nerdtree/lib/nerdtree/menu_item.vim[J
continuing in function nerdtree#loadClassFiles[J
line 4:     runtime lib/nerdtree/key_map.vim[J

Searching for "lib/nerdtree/key_map.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vim80/pack/dist/opt/matchit,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/after,/[J
Searching for "/home/patrick/.vim/lib/nerdtree/key_map.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/lib/nerdtree/key_map.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/lib/nerdtree/key_map.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/lib/nerdtree/key_map.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/lib/nerdtree/key_map.vim"[J
chdir(/home/patrick/.vim/bundle/nerdtree/lib/nerdtree)[J
fchdir() to previous dir[J
line 4: sourcing "/home/patrick/.vim/bundle/nerdtree/lib/nerdtree/key_map.vim"[J
line 1: "CLASS: KeyMap[J

line 2: "============================================================[J

line 3: let s:KeyMap = {}[J

line 4: let g:NERDTreeKeyMap = s:KeyMap[J

line 5: [J

line 6: "FUNCTION: KeyMap.All() {{{1[J

line 7: function! s:KeyMap.All()[J

line 13: [J

line 14: "FUNCTION: KeyMap.FindFor(key, scope) {{{1[J

line 15: function! s:KeyMap.FindFor(key, scope)[J

line 23: [J

line 24: "FUNCTION: KeyMap.BindAll() {{{1[J

line 25: function! s:KeyMap.BindAll()[J

line 30: [J

line 31: "FUNCTION: KeyMap.bind() {{{1[J

line 32: function! s:KeyMap.bind()[J

line 49: [J

line 50: "FUNCTION: KeyMap.Remove(key, scope) {{{1[J

line 51: function! s:KeyMap.Remove(key, scope)[J

line 59: [J

line 60: "FUNCTION: KeyMap.invoke() {{{1[J

line 61: "Call the KeyMaps callback function[J

line 62: function! s:KeyMap.invoke(...)[J

line 70: [J

line 71: "FUNCTION: KeyMap.Invoke() {{{1[J

line 72: "Find a keymapping for a:key and the current scope invoke it.[J

line 73: "[J

line 74: "Scope is determined as follows:[J

line 75: "   * if the cursor is on a dir node then "DirNode"[J

line 76: "   * if the cursor is on a file node then "FileNode"[J

line 77: "   * if the cursor is on a bookmark then "Bookmark"[J

line 78: "[J

line 79: "If a keymap has the scope of "all" then it will be called if no other keymap[J

line 80: "is found for a:key and the scope.[J

line 81: function! s:KeyMap.Invoke(key)[J

line 134: [J

line 135: "FUNCTION: KeyMap.Create(options) {{{1[J

line 136: function! s:KeyMap.Create(options)[J

line 152: [J

line 153: "FUNCTION: KeyMap.Add(keymap) {{{1[J

line 154: function! s:KeyMap.Add(keymap)[J

line 158: [J

line 159: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /home/patrick/.vim/bundle/nerdtree/lib/nerdtree/key_map.vim[J
continuing in function nerdtree#loadClassFiles[J
line 5:     runtime lib/nerdtree/bookmark.vim[J

Searching for "lib/nerdtree/bookmark.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vim80/pack/dist/opt/matchit,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/after,[J
Searching for "/home/patrick/.vim/lib/nerdtree/bookmark.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/lib/nerdtree/bookmark.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/lib/nerdtree/bookmark.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/lib/nerdtree/bookmark.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/lib/nerdtree/bookmark.vim"[J
chdir(/home/patrick/.vim/bundle/nerdtree/lib/nerdtree)[J
fchdir() to previous dir[J
line 5: sourcing "/home/patrick/.vim/bundle/nerdtree/lib/nerdtree/bookmark.vim"[J
line 1: " ============================================================================[J

line 2: " CLASS: Bookmark[J

line 3: "[J

line 4: " The Bookmark class serves two purposes:[J

line 5: "   (1) It is the top-level prototype for new, concrete Bookmark objects.[J

line 6: "   (2) It provides an interface for client code to query and manipulate the[J

line 7: "       global list of Bookmark objects within the current Vim session.[J

line 8: " ============================================================================[J

line 9: [J

line 10: [J

line 11: let s:Bookmark = {}[J

line 12: let g:NERDTreeBookmark = s:Bookmark[J

line 13: [J

line 14: " FUNCTION: Bookmark.activate(nerdtree) {{{1[J

line 15: function! s:Bookmark.activate(nerdtree, ...)[J

line 18: [J

line 19: " FUNCTION: Bookmark.AddBookmark(name, path) {{{1[J

line 20: " Class method to add a new bookmark to the list, if a previous bookmark exists[J

line 21: " with the same name, just update the path for that bookmark[J

line 22: function! s:Bookmark.AddBookmark(name, path)[J

line 31: [J

line 32: " FUNCTION: Bookmark.Bookmarks() {{{1[J

line 33: " Class method to get all bookmarks. Lazily initializes the bookmarks global[J

line 34: " variable[J

line 35: function! s:Bookmark.Bookmarks()[J

line 41: [J

line 42: " FUNCTION: Bookmark.BookmarkExistsFor(name) {{{1[J

line 43: " class method that returns 1 if a bookmark with the given name is found, 0[J

line 44: " otherwise[J

line 45: function! s:Bookmark.BookmarkExistsFor(name)[J

line 53: [J

line 54: " FUNCTION: Bookmark.BookmarkFor(name) {{{1[J

line 55: " Class method that returns the Bookmark object having the specified name.[J

line 56: " Throws "NERDTree.BookmarkNotFoundError" if no Bookmark is found.[J

line 57: function! s:Bookmark.BookmarkFor(name)[J

line 70: [J

line 71: " FUNCTION: Bookmark.BookmarkNames() {{{1[J

line 72: " Class method to return an array of all bookmark names[J

line 73: function! s:Bookmark.BookmarkNames()[J

line 80: [J

line 81: " FUNCTION: Bookmark.CacheBookmarks(silent) {{{1[J

line 82: " Class method to read all bookmarks from the bookmarks file initialize[J

line 83: " bookmark objects for each one.[J

line 84: "[J

line 85: " Args:[J

line 86: " silent - dont echo an error msg if invalid bookmarks are found[J

line 87: function! s:Bookmark.CacheBookmarks(silent)[J

line 119: [J

line 120: " FUNCTION: Bookmark.CompareBookmarksByName(firstBookmark, secondBookmark) {{{1[J

line 121: " Class method that indicates the relative position of two bookmarks when[J

line 122: " placed in alphabetical order by name. Case-sensitivity is determined by an[J

line 123: " option. Supports the "s:Bookmark.SortBookmarksList()" method.[J

line 124: function! s:Bookmark.CompareBookmarksByName(firstBookmark, secondBookmark)[J

line 141: [J

line 142: " FUNCTION: Bookmark.ClearAll() {{{1[J

line 143: " Class method to delete all bookmarks.[J

line 144: function! s:Bookmark.ClearAll()[J

line 150: [J

line 151: " FUNCTION: Bookmark.delete() {{{1[J

line 152: " Delete this bookmark. If the node for this bookmark is under the current[J

line 153: " root, then recache bookmarks for its Path object[J

line 154: function! s:Bookmark.delete()[J

line 158: [J

line 159: " FUNCTION: Bookmark.getNode(nerdtree, searchFromAbsoluteRoot) {{{1[J

line 160: " Returns the tree node object associated with this Bookmark.[J

line 161: " Throws "NERDTree.BookmarkedNodeNotFoundError" if the node is not found.[J

line 162: "[J

line 163: " Args:[J

line 164: " searchFromAbsoluteRoot: boolean flag, search from the highest cached node[J

line 165: "   if true and from the current tree root if false[J

line 166: function! s:Bookmark.getNode(nerdtree, searchFromAbsoluteRoot)[J

line 178: [J

line 179: " FUNCTION: Bookmark.GetNodeForName(name, searchFromAbsoluteRoot, nerdtree) {{{1[J

line 180: " Class method that returns the tree node object for the Bookmark with the[J

line 181: " given name. Throws "NERDTree.BookmarkNotFoundError" if a Bookmark with the[J

line 182: " name does not exist. Throws "NERDTree.BookmarkedNodeNotFoundError" if a[J

line 183: " tree node for the named Bookmark could not be found.[J

line 184: function! s:Bookmark.GetNodeForName(name, searchFromAbsoluteRoot, nerdtree)[J

line 188: [J

line 189: " FUNCTION: Bookmark.GetSelected() {{{1[J

line 190: " returns the Bookmark the cursor is over, or {}[J

line 191: function! s:Bookmark.GetSelected()[J

line 203: [J

line 204: " FUNCTION: Bookmark.InvalidBookmarks() {{{1[J

line 205: " Class method to get all invalid bookmark strings read from the bookmarks[J

line 206: " file[J

line 207: function! s:Bookmark.InvalidBookmarks()[J

line 213: [J

line 214: " FUNCTION: Bookmark.mustExist() {{{1[J

line 215: function! s:Bookmark.mustExist()[J

line 222: [J

line 223: " FUNCTION: Bookmark.New(name, path) {{{1[J

line 224: " Create a new bookmark object with the given name and path object[J

line 225: function! s:Bookmark.New(name, path)[J

line 235: [J

line 236: " FUNCTION: Bookmark.open(nerdtree, [options]) {{{1[J

line 237: "Args:[J

line 238: "[J

line 239: "nerdtree: the tree to load open the bookmark in[J

line 240: "[J

line 241: "A dictionary containing the following keys (all optional):[J

line 242: "  'where': Specifies whether the node should be opened in new split/tab or in[J

line 243: "           the previous window. Can be either 'v' (vertical split), 'h'[J

line 244: "           (horizontal split), 't' (new tab) or 'p' (previous window).[J

line 245: "  'reuse': if a window is displaying the file then jump the cursor there[J

line 246: "  'keepopen': dont close the tree window[J

line 247: "  'stay': open the file, but keep the cursor in the tree win[J

line 248: "[J

line 249: function! s:Bookmark.open(nerdtree, ...)[J

line 259: [J

line 260: " FUNCTION: Bookmark.openInNewTab(options) {{{1[J

line 261: " Create a new bookmark object with the given name and path object[J

line 262: function! s:Bookmark.openInNewTab(options)[J

line 266: [J

line 267: " FUNCTION: Bookmark.setPath(path) {{{1[J

line 268: " makes this bookmark point to the given path[J

line 269: function! s:Bookmark.setPath(path)[J

line 272: [J

line 273: " FUNCTION: Bookmark.SortBookmarksList() {{{1[J

line 274: " Class method that sorts the global list of bookmarks alphabetically by name.[J

line 275: " Note that case-sensitivity is determined by a user option.[J

line 276: function! s:Bookmark.SortBookmarksList()[J

line 279: [J

line 280: " FUNCTION: Bookmark.str() {{{1[J

line 281: " Get the string that should be rendered in the view for this bookmark[J

line 282: function! s:Bookmark.str()[J

line 294: [J

line 295: " FUNCTION: Bookmark.toRoot(nerdtree) {{{1[J

line 296: " Set the root of the given NERDTree to the node for this Bookmark. If a node[J

line 297: " for this Bookmark does not exist, a new one is initialized.[J

line 298: function! s:Bookmark.toRoot(nerdtree)[J

line 309: [J

line 310: " FUNCTION: Bookmark.ToRoot(name, nerdtree) {{{1[J

line 311: " Class method that makes the Bookmark with the given name the root of[J

line 312: " specified NERDTree.[J

line 313: function! s:Bookmark.ToRoot(name, nerdtree)[J

line 317: [J

line 318: " FUNCTION: Bookmark.validate() {{{1[J

line 319: function! s:Bookmark.validate()[J

line 328: [J

line 329: " FUNCTION: Bookmark.Write() {{{1[J

line 330: " Class method to write all bookmarks to the bookmarks file[J

line 331: function! s:Bookmark.Write()[J

line 345: [J

line 346: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /home/patrick/.vim/bundle/nerdtree/lib/nerdtree/bookmark.vim[J
continuing in function nerdtree#loadClassFiles[J
line 6:     runtime lib/nerdtree/tree_file_node.vim[J

Searching for "lib/nerdtree/tree_file_node.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vim80/pack/dist/opt/matchit,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/[J
Searching for "/home/patrick/.vim/lib/nerdtree/tree_file_node.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/lib/nerdtree/tree_file_node.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/lib/nerdtree/tree_file_node.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/lib/nerdtree/tree_file_node.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/lib/nerdtree/tree_file_node.vim"[J
chdir(/home/patrick/.vim/bundle/nerdtree/lib/nerdtree)[J
fchdir() to previous dir[J
line 6: sourcing "/home/patrick/.vim/bundle/nerdtree/lib/nerdtree/tree_file_node.vim"[J
line 1: "CLASS: TreeFileNode[J

line 2: "This class is the parent of the TreeDirNode class and is the[J

line 3: "'Component' part of the composite design pattern between the treenode[J

line 4: "classes.[J

line 5: "============================================================[J

line 6: let s:TreeFileNode = {}[J

line 7: let g:NERDTreeFileNode = s:TreeFileNode[J

line 8: [J

line 9: "FUNCTION: TreeFileNode.activate(...) {{{1[J

line 10: function! s:TreeFileNode.activate(...)[J

line 13: [J

line 14: "FUNCTION: TreeFileNode.bookmark(name) {{{1[J

line 15: "bookmark this node with a:name[J

line 16: function! s:TreeFileNode.bookmark(name)[J

line 35: [J

line 36: "FUNCTION: TreeFileNode.cacheParent() {{{1[J

line 37: "initializes self.parent if it isnt already[J

line 38: function! s:TreeFileNode.cacheParent()[J

line 47: [J

line 48: "FUNCTION: TreeFileNode.clearBookmarks() {{{1[J

line 49: function! s:TreeFileNode.clearBookmarks()[J

line 57: [J

line 58: "FUNCTION: TreeFileNode.copy(dest) {{{1[J

line 59: function! s:TreeFileNode.copy(dest)[J

line 70: [J

line 71: "FUNCTION: TreeFileNode.delete {{{1[J

line 72: "Removes this node from the tree and calls the Delete method for its path obj[J

line 73: function! s:TreeFileNode.delete()[J

line 77: [J

line 78: "FUNCTION: TreeFileNode.displayString() {{{1[J

line 79: "[J

line 80: "Returns a string that specifies how the node should be represented as a[J

line 81: "string[J

line 82: "[J

line 83: "Return:[J

line 84: "a string that can be used in the view to represent this node[J

line 85: function! s:TreeFileNode.displayString()[J

line 88: [J

line 89: "FUNCTION: TreeFileNode.equals(treenode) {{{1[J

line 90: "[J

line 91: "Compares this treenode to the input treenode and returns 1 if they are the[J

line 92: "same node.[J

line 93: "[J

line 94: "Use this method instead of ==  because sometimes when the treenodes contain[J

line 95: "many children, vim seg faults when doing ==[J

line 96: "[J

line 97: "Args:[J

line 98: "treenode: the other treenode to compare to[J

line 99: function! s:TreeFileNode.equals(treenode)[J

line 102: [J

line 103: "FUNCTION: TreeFileNode.findNode(path) {{{1[J

line 104: "Returns self if this node.path.Equals the given path.[J

line 105: "Returns {} if not equal.[J

line 106: "[J

line 107: "Args:[J

line 108: "path: the path object to compare against[J

line 109: function! s:TreeFileNode.findNode(path)[J

line 115: [J

line 116: "FUNCTION: TreeFileNode.findOpenDirSiblingWithVisibleChildren(direction) {{{1[J

line 117: "[J

line 118: "Finds the next sibling for this node in the indicated direction. This sibling[J

line 119: "must be a directory and may/may not have children as specified.[J

line 120: "[J

line 121: "Args:[J

line 122: "direction: 0 if you want to find the previous sibling, 1 for the next sibling[J

line 123: "[J

line 124: "Return:[J

line 125: "a treenode object or {} if no appropriate sibling could be found[J

line 126: function! s:TreeFileNode.findOpenDirSiblingWithVisibleChildren(direction)[J

line 141: [J

line 142: "FUNCTION: TreeFileNode.findSibling(direction) {{{1[J

line 143: "[J

line 144: "Finds the next sibling for this node in the indicated direction[J

line 145: "[J

line 146: "Args:[J

line 147: "direction: 0 if you want to find the previous sibling, 1 for the next sibling[J

line 148: "[J

line 149: "Return:[J

line 150: "a treenode object or {} if no sibling could be found[J

line 151: function! s:TreeFileNode.findSibling(direction)[J

line 180: [J

line 181: "FUNCTION: TreeFileNode.getNerdtree(){{{1[J

line 182: function! s:TreeFileNode.getNerdtree()[J

line 185: [J

line 186: "FUNCTION: TreeFileNode.GetRootForTab(){{{1[J

line 187: "get the root node for this tab[J

line 188: function! s:TreeFileNode.GetRootForTab()[J

line 194: [J

line 195: "FUNCTION: TreeFileNode.GetSelected() {{{1[J

line 196: "gets the treenode that the cursor is currently over[J

line 197: function! s:TreeFileNode.GetSelected()[J

line 208: [J

line 209: "FUNCTION: TreeFileNode.isVisible() {{{1[J

line 210: "returns 1 if this node should be visible according to the tree filters and[J

line 211: "hidden file filters (and their on/off status)[J

line 212: function! s:TreeFileNode.isVisible()[J

line 215: [J

line 216: "FUNCTION: TreeFileNode.isRoot() {{{1[J

line 217: function! s:TreeFileNode.isRoot()[J

line 224: [J

line 225: "FUNCTION: TreeFileNode.New(path, nerdtree) {{{1[J

line 226: "Returns a new TreeNode object with the given path and parent[J

line 227: "[J

line 228: "Args:[J

line 229: "path: file/dir that the node represents[J

line 230: "nerdtree: the tree the node belongs to[J

line 231: function! s:TreeFileNode.New(path, nerdtree)[J

line 242: [J

line 243: "FUNCTION: TreeFileNode.open() {{{1[J

line 244: function! s:TreeFileNode.open(...)[J

line 249: [J

line 250: "FUNCTION: TreeFileNode.openSplit() {{{1[J

line 251: "Open this node in a new window[J

line 252: function! s:TreeFileNode.openSplit()[J

line 256: [J

line 257: "FUNCTION: TreeFileNode.openVSplit() {{{1[J

line 258: "Open this node in a new vertical window[J

line 259: function! s:TreeFileNode.openVSplit()[J

line 263: [J

line 264: "FUNCTION: TreeFileNode.openInNewTab(options) {{{1[J

line 265: function! s:TreeFileNode.openInNewTab(options)[J

line 269: [J

line 270: "FUNCTION: TreeFileNode.putCursorHere(isJump, recurseUpward){{{1[J

line 271: "Places the cursor on the line number this node is rendered on[J

line 272: "[J

line 273: "Args:[J

line 274: "isJump: 1 if this cursor movement should be counted as a jump by vim[J

line 275: "recurseUpward: try to put the cursor on the parent if the this node isnt[J

line 276: "visible[J

line 277: function! s:TreeFileNode.putCursorHere(isJump, recurseUpward)[J

line 296: [J

line 297: "FUNCTION: TreeFileNode.refresh() {{{1[J

line 298: function! s:TreeFileNode.refresh()[J

line 301: [J

line 302: "FUNCTION: TreeFileNode.refreshFlags() {{{1[J

line 303: function! s:TreeFileNode.refreshFlags()[J

line 306: [J

line 307: "FUNCTION: TreeFileNode.rename() {{{1[J

line 308: "Calls the rename method for this nodes path obj[J

line 309: function! s:TreeFileNode.rename(newName)[J

line 322: [J

line 323: "FUNCTION: TreeFileNode.renderToString {{{1[J

line 324: "returns a string representation for this tree to be rendered in the view[J

line 325: function! s:TreeFileNode.renderToString()[J

line 328: [J

line 329: "Args:[J

line 330: "depth: the current depth in the tree for this call[J

line 331: "drawText: 1 if we should actually draw the line for this node (if 0 then the[J

line 332: "child nodes are rendered only)[J

line 333: "for each depth in the tree[J

line 334: function! s:TreeFileNode._renderToString(depth, drawText)[J

line 367: [J

line 368: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /home/patrick/.vim/bundle/nerdtree/lib/nerdtree/tree_file_node.vim[J
continuing in function nerdtree#loadClassFiles[J
line 7:     runtime lib/nerdtree/tree_dir_node.vim[J

Searching for "lib/nerdtree/tree_dir_node.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vim80/pack/dist/opt/matchit,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/a[J
Searching for "/home/patrick/.vim/lib/nerdtree/tree_dir_node.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/lib/nerdtree/tree_dir_node.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/lib/nerdtree/tree_dir_node.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/lib/nerdtree/tree_dir_node.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim"[J
chdir(/home/patrick/.vim/bundle/nerdtree/lib/nerdtree)[J
fchdir() to previous dir[J
line 7: sourcing "/home/patrick/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim"[J
line 1: " ============================================================================[J

line 2: " CLASS: TreeDirNode[J

line 3: "[J

line 4: " A subclass of NERDTreeFileNode.[J

line 5: "[J

line 6: " The 'composite' part of the file/dir composite.[J

line 7: " ============================================================================[J

line 8: [J

line 9: [J

line 10: let s:TreeDirNode = copy(g:NERDTreeFileNode)[J

line 11: let g:NERDTreeDirNode = s:TreeDirNode[J

line 12: [J

line 13: " FUNCTION: TreeDirNode.AbsoluteTreeRoot(){{{1[J

line 14: " Class method that returns the highest cached ancestor of the current root.[J

line 15: function! s:TreeDirNode.AbsoluteTreeRoot()[J

line 22: [J

line 23: " FUNCTION: TreeDirNode.activate([options]) {{{1[J

line 24: unlet s:TreeDirNode.activate[J

line 25: function! s:TreeDirNode.activate(...)[J

line 31: [J

line 32: " FUNCTION: TreeDirNode.addChild(treenode, inOrder) {{{1[J

line 33: " Adds the given treenode to the list of children for this node[J

line 34: "[J

line 35: " Args:[J

line 36: " -treenode: the node to add[J

line 37: " -inOrder: 1 if the new node should be inserted in sorted order[J

line 38: function! s:TreeDirNode.addChild(treenode, inOrder)[J

line 46: [J

line 47: " FUNCTION: TreeDirNode.close() {{{1[J

line 48: " Mark this TreeDirNode as closed.[J

line 49: function! s:TreeDirNode.close()[J

line 57: [J

line 58: " FUNCTION: TreeDirNode.closeChildren() {{{1[J

line 59: " Recursively close any directory nodes that are descendants of this node.[J

line 60: function! s:TreeDirNode.closeChildren()[J

line 68: [J

line 69: " FUNCTION: TreeDirNode.createChild(path, inOrder) {{{1[J

line 70: " Instantiates a new child node for this node with the given path. The new[J

line 71: " nodes parent is set to this node.[J

line 72: "[J

line 73: " Args:[J

line 74: " path: a Path object that this node will represent/contain[J

line 75: " inOrder: 1 if the new node should be inserted in sorted order[J

line 76: "[J

line 77: " Returns:[J

line 78: " the newly created node[J

line 79: function! s:TreeDirNode.createChild(path, inOrder)[J

line 84: [J

line 85: " FUNCTION: TreeDirNode.displayString() {{{1[J

line 86: " Assemble and return a string that can represent this TreeDirNode object in[J

line 87: " the NERDTree window.[J

line 88: function! s:TreeDirNode.displayString()[J

line 110: [J

line 111: " FUNCTION: TreeDirNode.findNode(path) {{{1[J

line 112: " Will find one of the children (recursively) that has the given path[J

line 113: "[J

line 114: " Args:[J

line 115: " path: a path object[J

line 116: unlet s:TreeDirNode.findNode[J

line 117: function! s:TreeDirNode.findNode(path)[J

line 135: [J

line 136: " FUNCTION: TreeDirNode.getCascade() {{{1[J

line 137: " Return an array of dir nodes (starting from self) that can be cascade opened.[J

line 138: function! s:TreeDirNode.getCascade()[J

line 148: [J

line 149: " FUNCTION: TreeDirNode.getChildCount() {{{1[J

line 150: " Returns the number of children this node has[J

line 151: function! s:TreeDirNode.getChildCount()[J

line 154: [J

line 155: " FUNCTION: TreeDirNode.getChild(path) {{{1[J

line 156: " Returns child node of this node that has the given path or {} if no such node[J

line 157: " exists.[J

line 158: "[J

line 159: " This function doesnt not recurse into child dir nodes[J

line 160: "[J

line 161: " Args:[J

line 162: " path: a path object[J

line 163: function! s:TreeDirNode.getChild(path)[J

line 176: [J

line 177: " FUNCTION: TreeDirNode.getChildByIndex(indx, visible) {{{1[J

line 178: " returns the child at the given index[J

line 179: "[J

line 180: " Args:[J

line 181: " indx: the index to get the child from[J

line 182: " visible: 1 if only the visible children array should be used, 0 if all the[J

line 183: " children should be searched.[J

line 184: function! s:TreeDirNode.getChildByIndex(indx, visible)[J

line 191: [J

line 192: " FUNCTION: TreeDirNode.getChildIndex(path) {{{1[J

line 193: " Returns the index of the child node of this node that has the given path or[J

line 194: " -1 if no such node exists.[J

line 195: "[J

line 196: " This function doesnt not recurse into child dir nodes[J

line 197: "[J

line 198: " Args:[J

line 199: " path: a path object[J

line 200: function! s:TreeDirNode.getChildIndex(path)[J

line 222: [J

line 223: " FUNCTION: TreeDirNode._glob(pattern, all) {{{1[J

line 224: " Return a list of strings naming the descendants of the directory in this[J

line 225: " TreeDirNode object that match the specified glob pattern.[J

line 226: "[J

line 227: " Args:[J

line 228: " pattern: (string) the glob pattern to apply[J

line 229: " all: (0 or 1) if 1, include "." and ".." if they match "pattern"; if 0,[J

line 230: "      always exclude them[J

line 231: "[J

line 232: " Note: If the pathnames in the result list are below the working directory,[J

line 233: " they are returned as pathnames relative to that directory. This is because[J

line 234: " this function, internally, attempts to obey 'wildignore' rules that use[J

line 235: " relative paths.[J

line 236: function! s:TreeDirNode._glob(pattern, all)[J

line 294: [J

line 295: " FUNCTION: TreeDirNode.GetSelected() {{{1[J

line 296: " Returns the current node if it is a dir node, or else returns the current[J

line 297: " nodes parent[J

line 298: unlet s:TreeDirNode.GetSelected[J

line 299: function! s:TreeDirNode.GetSelected()[J

line 308: [J

line 309: " FUNCTION: TreeDirNode.getVisibleChildCount() {{{1[J

line 310: " Returns the number of visible children this node has[J

line 311: function! s:TreeDirNode.getVisibleChildCount()[J

line 314: [J

line 315: " FUNCTION: TreeDirNode.getVisibleChildren() {{{1[J

line 316: " Returns a list of children to display for this node, in the correct order[J

line 317: "[J

line 318: " Return:[J

line 319: " an array of treenodes[J

line 320: function! s:TreeDirNode.getVisibleChildren()[J

line 329: [J

line 330: " FUNCTION: TreeDirNode.hasVisibleChildren() {{{1[J

line 331: " returns 1 if this node has any childre, 0 otherwise..[J

line 332: function! s:TreeDirNode.hasVisibleChildren()[J

line 335: [J

line 336: " FUNCTION: TreeDirNode.isCascadable() {{{1[J

line 337: " true if this dir has only one visible child - which is also a dir[J

line 338: function! s:TreeDirNode.isCascadable()[J

line 346: [J

line 347: " FUNCTION: TreeDirNode._initChildren() {{{1[J

line 348: " Removes all childen from this node and re-reads them[J

line 349: "[J

line 350: " Args:[J

line 351: " silent: 1 if the function should not echo any "please wait" messages for[J

line 352: " large directories[J

line 353: "[J

line 354: " Return: the number of child nodes read[J

line 355: function! s:TreeDirNode._initChildren(silent)[J

line 387: [J

line 388: " FUNCTION: TreeDirNode.New(path, nerdtree) {{{1[J

line 389: " Return a new TreeDirNode object with the given path and parent.[J

line 390: "[J

line 391: " Args:[J

line 392: " path: dir that the node represents[J

line 393: " nerdtree: the tree the node belongs to[J

line 394: function! s:TreeDirNode.New(path, nerdtree)[J

line 410: [J

line 411: " FUNCTION: TreeDirNode.open([options]) {{{1[J

line 412: " Open this directory node in the current tree or elsewhere if special options[J

line 413: " are provided. Return 0 if options were processed. Otherwise, return the[J

line 414: " number of new cached nodes.[J

line 415: function! s:TreeDirNode.open(...)[J

line 445: [J

line 446: " FUNCTION: TreeDirNode.openAlong([opts]) {{{1[J

line 447: " recursive open the dir if it has only one directory child.[J

line 448: "[J

line 449: " return the level of opened directories.[J

line 450: function! s:TreeDirNode.openAlong(...)[J

line 466: [J

line 467: " FUNCTION: TreeDirNode.openExplorer() {{{1[J

line 468: " Open an explorer window for this node in the previous window. The explorer[J

line 469: " can be a NERDTree window or a netrw window.[J

line 470: function! s:TreeDirNode.openExplorer()[J

line 473: [J

line 474: " FUNCTION: TreeDirNode.openInNewTab(options) {{{1[J

line 475: unlet s:TreeDirNode.openInNewTab[J

line 476: function! s:TreeDirNode.openInNewTab(options)[J

line 480: [J

line 481: " FUNCTION: TreeDirNode._openInNewTab() {{{1[J

line 482: function! s:TreeDirNode._openInNewTab()[J

line 486: [J

line 487: " FUNCTION: TreeDirNode.openRecursively() {{{1[J

line 488: " Open this directory node and any descendant directory nodes whose pathnames[J

line 489: " are not ignored.[J

line 490: function! s:TreeDirNode.openRecursively()[J

line 499: [J

line 500: " FUNCTION: TreeDirNode.refresh() {{{1[J

line 501: function! s:TreeDirNode.refresh()[J

line 538: [J

line 539: " FUNCTION: TreeDirNode.refreshFlags() {{{1[J

line 540: unlet s:TreeDirNode.refreshFlags[J

line 541: function! s:TreeDirNode.refreshFlags()[J

line 547: [J

line 548: " FUNCTION: TreeDirNode.refreshDirFlags() {{{1[J

line 549: function! s:TreeDirNode.refreshDirFlags()[J

line 552: [J

line 553: " FUNCTION: TreeDirNode.reveal(path) {{{1[J

line 554: " reveal the given path, i.e. cache and open all treenodes needed to display it[J

line 555: " in the UI[J

line 556: " Returns the revealed node[J

line 557: function! s:TreeDirNode.reveal(path, ...)[J

line 582: [J

line 583: " FUNCTION: TreeDirNode.removeChild(treenode) {{{1[J

line 584: " Remove the given treenode from "self.children".[J

line 585: " Throws "NERDTree.ChildNotFoundError" if the node is not found.[J

line 586: "[J

line 587: " Args:[J

line 588: " treenode: the node object to remove[J

line 589: function! s:TreeDirNode.removeChild(treenode)[J

line 599: [J

line 600: " FUNCTION: TreeDirNode.sortChildren() {{{1[J

line 601: " Sort "self.children" by alphabetical order and directory priority.[J

line 602: function! s:TreeDirNode.sortChildren()[J

line 606: [J

line 607: " FUNCTION: TreeDirNode.toggleOpen([options]) {{{1[J

line 608: " Opens this directory if it is closed and vice versa[J

line 609: function! s:TreeDirNode.toggleOpen(...)[J

line 621: [J

line 622: " FUNCTION: TreeDirNode.transplantChild(newNode) {{{1[J

line 623: " Replaces the child of this with the given node (where the child node's full[J

line 624: " path matches a:newNode's fullpath). The search for the matching node is[J

line 625: " non-recursive[J

line 626: "[J

line 627: " Arg:[J

line 628: " newNode: the node to graft into the tree[J

line 629: function! s:TreeDirNode.transplantChild(newNode)[J

line 638: [J

line 639: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /home/patrick/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim[J
continuing in function nerdtree#loadClassFiles[J
line 8:     runtime lib/nerdtree/opener.vim[J

Searching for "lib/nerdtree/opener.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vim80/pack/dist/opt/matchit,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/after,/h[J
Searching for "/home/patrick/.vim/lib/nerdtree/opener.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/lib/nerdtree/opener.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/lib/nerdtree/opener.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/lib/nerdtree/opener.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/lib/nerdtree/opener.vim"[J
chdir(/home/patrick/.vim/bundle/nerdtree/lib/nerdtree)[J
fchdir() to previous dir[J
line 8: sourcing "/home/patrick/.vim/bundle/nerdtree/lib/nerdtree/opener.vim"[J
line 1: " ============================================================================[J

line 2: " CLASS: Opener[J

line 3: "[J

line 4: " The Opener class defines an API for "opening" operations.[J

line 5: " ============================================================================[J

line 6: [J

line 7: [J

line 8: let s:Opener = {}[J

line 9: let g:NERDTreeOpener = s:Opener[J

line 10: [J

line 11: " FUNCTION: s:Opener._bufInWindows(bnum) {{{1[J

line 12: " [[STOLEN FROM VTREEEXPLORER.VIM]][J

line 13: " Determine the number of windows open to this buffer number.[J

line 14: " Care of Yegappan Lakshman.  Thanks![J

line 15: "[J

line 16: " Args:[J

line 17: " bnum: the subject buffers buffer number[J

line 18: function! s:Opener._bufInWindows(bnum)[J

line 34: [J

line 35: " FUNCTION: Opener._checkToCloseTree(newtab) {{{1[J

line 36: " Check the class options and global options (i.e. NERDTreeQuitOnOpen) to see[J

line 37: " if the tree should be closed now.[J

line 38: "[J

line 39: " Args:[J

line 40: " a:newtab - boolean. If set, only close the tree now if we are opening the[J

line 41: " target in a new tab. This is needed because we have to close tree before we[J

line 42: " leave the tab[J

line 43: function! s:Opener._checkToCloseTree(newtab)[J

line 52: [J

line 53: " FUNCTION: s:Opener._firstUsableWindow() {{{1[J

line 54: " find the window number of the first normal window[J

line 55: function! s:Opener._firstUsableWindow()[J

line 69: [J

line 70: " FUNCTION: Opener._gotoTargetWin() {{{1[J

line 71: function! s:Opener._gotoTargetWin()[J

line 96: [J

line 97: " FUNCTION: s:Opener._isWindowUsable(winnumber) {{{1[J

line 98: " Returns 0 if opening a file from the tree in the given window requires it to[J

line 99: " be split, 1 otherwise[J

line 100: "[J

line 101: " Args:[J

line 102: " winnumber: the number of the window in question[J

line 103: function! s:Opener._isWindowUsable(winnumber)[J

line 127: [J

line 128: " FUNCTION: Opener.New(path, opts) {{{1[J

line 129: " Args:[J

line 130: "[J

line 131: " a:path: The path object that is to be opened.[J

line 132: "[J

line 133: " a:opts:[J

line 134: "[J

line 135: " A dictionary containing the following keys (all optional):[J

line 136: "   'where': Specifies whether the node should be opened in new split/tab or in[J

line 137: "            the previous window. Can be either 'v' or 'h' or 't' (for open in[J

line 138: "            new tab)[J

line 139: "   'reuse': if a window is displaying the file then jump the cursor there. Can[J

line 140: "            'all', 'currenttab' or empty to not reuse.[J

line 141: "   'keepopen': dont close the tree window[J

line 142: "   'stay': open the file, but keep the cursor in the tree win[J

line 143: function! s:Opener.New(path, opts)[J

line 162: [J

line 163: " FUNCTION: Opener._newSplit() {{{1[J

line 164: function! s:Opener._newSplit()[J

line 222: [J

line 223: " FUNCTION: Opener._newVSplit() {{{1[J

line 224: function! s:Opener._newVSplit()[J

line 242: [J

line 243: " FUNCTION: Opener.open(target) {{{1[J

line 244: function! s:Opener.open(target)[J

line 251: [J

line 252: " FUNCTION: Opener._openFile() {{{1[J

line 253: function! s:Opener._openFile()[J

line 264: [J

line 265: " FUNCTION: Opener._openDirectory(node) {{{1[J

line 266: function! s:Opener._openDirectory(node)[J

line 285: [J

line 286: " FUNCTION: Opener._previousWindow() {{{1[J

line 287: function! s:Opener._previousWindow()[J

line 305: [J

line 306: " FUNCTION: Opener._restoreCursorPos() {{{1[J

line 307: function! s:Opener._restoreCursorPos()[J

line 311: [J

line 312: " FUNCTION: Opener._reuseWindow() {{{1[J

line 313: " put the cursor in the first window we find for this file[J

line 314: "[J

line 315: " return 1 if we were successful[J

line 316: function! s:Opener._reuseWindow()[J

line 345: [J

line 346: " FUNCTION: Opener._saveCursorPos() {{{1[J

line 347: function! s:Opener._saveCursorPos()[J

line 351: [J

line 352: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /home/patrick/.vim/bundle/nerdtree/lib/nerdtree/opener.vim[J
continuing in function nerdtree#loadClassFiles[J
line 9:     runtime lib/nerdtree/creator.vim[J

Searching for "lib/nerdtree/creator.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vim80/pack/dist/opt/matchit,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/after,/[J
Searching for "/home/patrick/.vim/lib/nerdtree/creator.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/lib/nerdtree/creator.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/lib/nerdtree/creator.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/lib/nerdtree/creator.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/lib/nerdtree/creator.vim"[J
chdir(/home/patrick/.vim/bundle/nerdtree/lib/nerdtree)[J
fchdir() to previous dir[J
line 9: sourcing "/home/patrick/.vim/bundle/nerdtree/lib/nerdtree/creator.vim"[J
line 1: "CLASS: Creator[J

line 2: "Creates tab/window/mirror nerdtree windows. Sets up all the window and[J

line 3: "buffer options and key mappings etc.[J

line 4: "============================================================[J

line 5: let s:Creator = {}[J

line 6: let g:NERDTreeCreator = s:Creator[J

line 7: [J

line 8: "FUNCTION: s:Creator._bindMappings() {{{1[J

line 9: function! s:Creator._bindMappings()[J

line 24: [J

line 25: "FUNCTION: s:Creator._broadcastInitEvent() {{{1[J

line 26: function! s:Creator._broadcastInitEvent()[J

line 29: [J

line 30: " FUNCTION: s:Creator.BufNamePrefix() {{{2[J

line 31: function! s:Creator.BufNamePrefix()[J

line 34: [J

line 35: "FUNCTION: s:Creator.CreateTabTree(a:name) {{{1[J

line 36: function! s:Creator.CreateTabTree(name)[J

line 40: [J

line 41: "FUNCTION: s:Creator.createTabTree(a:name) {{{1[J

line 42: "name: the name of a bookmark or a directory[J

line 43: function! s:Creator.createTabTree(name)[J

line 76: [J

line 77: "FUNCTION: s:Creator.CreateWindowTree(dir) {{{1[J

line 78: function! s:Creator.CreateWindowTree(dir)[J

line 82: [J

line 83: "FUNCTION: s:Creator.createWindowTree(dir) {{{1[J

line 84: function! s:Creator.createWindowTree(dir)[J

line 109: [J

line 110: " FUNCTION: s:Creator._createNERDTree(path) {{{1[J

line 111: function! s:Creator._createNERDTree(path, type)[J

line 120: [J

line 121: " FUNCTION: s:Creator.CreateMirror() {{{1[J

line 122: function! s:Creator.CreateMirror()[J

line 126: [J

line 127: " FUNCTION: s:Creator.createMirror() {{{1[J

line 128: function! s:Creator.createMirror()[J

line 179: [J

line 180: "FUNCTION: s:Creator._createTreeWin() {{{1[J

line 181: "Inits the NERD tree window. ie. opens it, sizes it, sets all the local[J

line 182: "options etc[J

line 183: function! s:Creator._createTreeWin()[J

line 200: [J

line 201: "FUNCTION: s:Creator._isBufHidden(nr) {{{1[J

line 202: function! s:Creator._isBufHidden(nr)[J

line 209: [J

line 210: "FUNCTION: s:Creator.New() {{{1[J

line 211: function! s:Creator.New()[J

line 215: [J

line 216: " FUNCTION: s:Creator._nextBufferName() {{{2[J

line 217: " returns the buffer name for the next nerd tree[J

line 218: function! s:Creator._nextBufferName()[J

line 222: [J

line 223: " FUNCTION: s:Creator._nextBufferNumber() {{{2[J

line 224: " the number to add to the nerd tree buffer name to make the buf name unique[J

line 225: function! s:Creator._nextBufferNumber()[J

line 234: [J

line 235: "FUNCTION: s:Creator._pathForString(str) {{{1[J

line 236: "find a bookmark or adirectory for the given string[J

line 237: function! s:Creator._pathForString(str)[J

line 263: [J

line 264: " Function: s:Creator._removeTreeBufForTab()   {{{1[J

line 265: function! s:Creator._removeTreeBufForTab()[J

line 280: [J

line 281: "FUNCTION: s:Creator._setCommonBufOptions() {{{1[J

line 282: function! s:Creator._setCommonBufOptions()[J

line 312: [J

line 313: "FUNCTION: s:Creator._setupStatusline() {{{1[J

line 314: function! s:Creator._setupStatusline()[J

line 319: [J

line 320: " FUNCTION: s:Creator._tabpagevar(tabnr, var) {{{1[J

line 321: function! s:Creator._tabpagevar(tabnr, var)[J

line 337: [J

line 338: "FUNCTION: s:Creator.ToggleTabTree(dir) {{{1[J

line 339: function! s:Creator.ToggleTabTree(dir)[J

line 343: [J

line 344: "FUNCTION: s:Creator.toggleTabTree(dir) {{{1[J

line 345: "Toggles the NERD tree. I.e the NERD tree is open, it is closed, if it is[J

line 346: "closed it is restored or initialized (if it doesnt exist)[J

line 347: "[J

line 348: "Args:[J

line 349: "dir: the full path for the root node (is only used if the NERD tree is being[J

line 350: "initialized.[J

line 351: function! s:Creator.toggleTabTree(dir)[J

line 366: [J

line 367: " Function: s:Creator._uniq(list)   {{{1[J

line 368: " returns a:list without duplicates[J

line 369: function! s:Creator._uniq(list)[J

line 378: [J

line 379: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /home/patrick/.vim/bundle/nerdtree/lib/nerdtree/creator.vim[J
continuing in function nerdtree#loadClassFiles[J
line 10:     runtime lib/nerdtree/flag_set.vim[J

Searching for "lib/nerdtree/flag_set.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vim80/pack/dist/opt/matchit,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/after,[J
Searching for "/home/patrick/.vim/lib/nerdtree/flag_set.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/lib/nerdtree/flag_set.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/lib/nerdtree/flag_set.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/lib/nerdtree/flag_set.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/lib/nerdtree/flag_set.vim"[J
chdir(/home/patrick/.vim/bundle/nerdtree/lib/nerdtree)[J
fchdir() to previous dir[J
line 10: sourcing "/home/patrick/.vim/bundle/nerdtree/lib/nerdtree/flag_set.vim"[J
line 1: "CLASS: FlagSet[J

line 2: "============================================================[J

line 3: let s:FlagSet = {}[J

line 4: let g:NERDTreeFlagSet = s:FlagSet[J

line 5: [J

line 6: "FUNCTION: FlagSet.addFlag(scope, flag) {{{1[J

line 7: function! s:FlagSet.addFlag(scope, flag)[J

line 13: [J

line 14: "FUNCTION: FlagSet.clearFlags(scope) {{{1[J

line 15: function! s:FlagSet.clearFlags(scope)[J

line 18: [J

line 19: "FUNCTION: FlagSet._flagsForScope(scope) {{{1[J

line 20: function! s:FlagSet._flagsForScope(scope)[J

line 26: [J

line 27: "FUNCTION: FlagSet.New() {{{1[J

line 28: function! s:FlagSet.New()[J

line 33: [J

line 34: "FUNCTION: FlagSet.removeFlag(scope, flag) {{{1[J

line 35: function! s:FlagSet.removeFlag(scope, flag)[J

line 43: [J

line 44: "FUNCTION: FlagSet.renderToString() {{{1[J

line 45: function! s:FlagSet.renderToString()[J

finished sourcing /home/patrick/.vim/bundle/nerdtree/lib/nerdtree/flag_set.vim[J
continuing in function nerdtree#loadClassFiles[J
line 11:     runtime lib/nerdtree/nerdtree.vim[J

Searching for "lib/nerdtree/nerdtree.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vim80/pack/dist/opt/matchit,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/after,[J
Searching for "/home/patrick/.vim/lib/nerdtree/nerdtree.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/lib/nerdtree/nerdtree.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/lib/nerdtree/nerdtree.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/lib/nerdtree/nerdtree.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/lib/nerdtree/nerdtree.vim"[J
chdir(/home/patrick/.vim/bundle/nerdtree/lib/nerdtree)[J
fchdir() to previous dir[J
line 11: sourcing "/home/patrick/.vim/bundle/nerdtree/lib/nerdtree/nerdtree.vim"[J
line 1: "CLASS: NERDTree[J

line 2: "============================================================[J

line 3: let s:NERDTree = {}[J

line 4: let g:NERDTree = s:NERDTree[J

line 5: [J

line 6: "FUNCTION: s:NERDTree.AddPathFilter() {{{1[J

line 7: function! s:NERDTree.AddPathFilter(callback)[J

line 10: [J

line 11: "FUNCTION: s:NERDTree.changeRoot(node) {{{1[J

line 12: function! s:NERDTree.changeRoot(node)[J

line 32: [J

line 33: "FUNCTION: s:NERDTree.Close() {{{1[J

line 34: "Closes the tab tree window for this tab[J

line 35: function! s:NERDTree.Close()[J

line 56: [J

line 57: "FUNCTION: s:NERDTree.CloseIfQuitOnOpen() {{{1[J

line 58: "Closes the NERD tree window if the close on open option is set[J

line 59: function! s:NERDTree.CloseIfQuitOnOpen()[J

line 64: [J

line 65: "FUNCTION: s:NERDTree.CursorToBookmarkTable(){{{1[J

line 66: "Places the cursor at the top of the bookmarks table[J

line 67: function! s:NERDTree.CursorToBookmarkTable()[J

line 87: [J

line 88: "FUNCTION: s:NERDTree.CursorToTreeWin(){{{1[J

line 89: "Places the cursor in the nerd tree window[J

line 90: function! s:NERDTree.CursorToTreeWin()[J

line 94: [J

line 95: " Function: s:NERDTree.ExistsForBuffer()   {{{1[J

line 96: " Returns 1 if a nerd tree root exists in the current buffer[J

line 97: function! s:NERDTree.ExistsForBuf()[J

line 100: [J

line 101: " Function: s:NERDTree.ExistsForTab()   {{{1[J

line 102: " Returns 1 if a nerd tree root exists in the current tab[J

line 103: function! s:NERDTree.ExistsForTab()[J

line 111: [J

line 112: function! s:NERDTree.ForCurrentBuf()[J

line 119: [J

line 120: "FUNCTION: s:NERDTree.ForCurrentTab() {{{1[J

line 121: function! s:NERDTree.ForCurrentTab()[J

line 129: [J

line 130: "FUNCTION: s:NERDTree.getRoot() {{{1[J

line 131: function! s:NERDTree.getRoot()[J

line 134: [J

line 135: "FUNCTION: s:NERDTree.GetWinNum() {{{1[J

line 136: "gets the nerd tree window number for this tab[J

line 137: function! s:NERDTree.GetWinNum()[J

line 144: [J

line 145: "FUNCTION: s:NERDTree.IsOpen() {{{1[J

line 146: function! s:NERDTree.IsOpen()[J

line 149: [J

line 150: "FUNCTION: s:NERDTree.isTabTree() {{{1[J

line 151: function! s:NERDTree.isTabTree()[J

line 154: [J

line 155: "FUNCTION: s:NERDTree.isWinTree() {{{1[J

line 156: function! s:NERDTree.isWinTree()[J

line 159: [J

line 160: "FUNCTION: s:NERDTree.MustBeOpen() {{{1[J

line 161: function! s:NERDTree.MustBeOpen()[J

line 166: [J

line 167: "FUNCTION: s:NERDTree.New() {{{1[J

line 168: function! s:NERDTree.New(path, type)[J

line 175: [J

line 176: "FUNCTION: s:NERDTree.PathFilters() {{{1[J

line 177: function! s:NERDTree.PathFilters()[J

line 183: [J

line 184: "FUNCTION: s:NERDTree.previousBuf() {{{1[J

line 185: function! s:NERDTree.previousBuf()[J

line 188: [J

line 189: function! s:NERDTree.setPreviousBuf(bnum)[J

line 192: [J

line 193: "FUNCTION: s:NERDTree.render() {{{1[J

line 194: "A convenience function - since this is called often[J

line 195: function! s:NERDTree.render()[J

finished sourcing /home/patrick/.vim/bundle/nerdtree/lib/nerdtree/nerdtree.vim[J
continuing in function nerdtree#loadClassFiles[J
line 12:     runtime lib/nerdtree/ui.vim[J

Searching for "lib/nerdtree/ui.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vim80/pack/dist/opt/matchit,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/after,/home/[J
Searching for "/home/patrick/.vim/lib/nerdtree/ui.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/lib/nerdtree/ui.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/lib/nerdtree/ui.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/lib/nerdtree/ui.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/lib/nerdtree/ui.vim"[J
chdir(/home/patrick/.vim/bundle/nerdtree/lib/nerdtree)[J
fchdir() to previous dir[J
line 12: sourcing "/home/patrick/.vim/bundle/nerdtree/lib/nerdtree/ui.vim"[J
line 1: "CLASS: UI[J

line 2: "============================================================[J

line 3: let s:UI = {}[J

line 4: let g:NERDTreeUI = s:UI[J

line 5: [J

line 6: "FUNCTION: s:UI.centerView() {{{2[J

line 7: "centers the nerd tree window around the cursor (provided the nerd tree[J

line 8: "options permit)[J

line 9: function! s:UI.centerView()[J

line 19: [J

line 20: "FUNCTION: s:UI._dumpHelp  {{{1[J

line 21: "prints out the quick help[J

line 22: function! s:UI._dumpHelp()[J

line 123: [J

line 124: [J

line 125: "FUNCTION: s:UI.new(nerdtree) {{{1[J

line 126: function! s:UI.New(nerdtree)[J

line 137: [J

line 138: "FUNCTION: s:UI.getPath(ln) {{{1[J

line 139: "Gets the full path to the node that is rendered on the given line number[J

line 140: "[J

line 141: "Args:[J

line 142: "ln: the line number to get the path for[J

line 143: "[J

line 144: "Return:[J

line 145: "A path if a node was selected, {} if nothing is selected.[J

line 146: "If the 'up a dir' line was selected then the path to the parent of the[J

line 147: "current root is returned[J

line 148: function! s:UI.getPath(ln)[J

line 199: [J

line 200: "FUNCTION: s:UI.getLineNum(file_node){{{1[J

line 201: "returns the line number this node is rendered on, or -1 if it isnt rendered[J

line 202: function! s:UI.getLineNum(file_node)[J

line 247: [J

line 248: "FUNCTION: s:UI.getRootLineNum(){{{1[J

line 249: "gets the line number of the root node[J

line 250: function! s:UI.getRootLineNum()[J

line 257: [J

line 258: "FUNCTION: s:UI.getShowBookmarks() {{{1[J

line 259: function! s:UI.getShowBookmarks()[J

line 262: [J

line 263: "FUNCTION: s:UI.getShowFiles() {{{1[J

line 264: function! s:UI.getShowFiles()[J

line 267: [J

line 268: "FUNCTION: s:UI.getShowHelp() {{{1[J

line 269: function! s:UI.getShowHelp()[J

line 272: [J

line 273: "FUNCTION: s:UI.getShowHidden() {{{1[J

line 274: function! s:UI.getShowHidden()[J

line 277: [J

line 278: "FUNCTION: s:UI._indentLevelFor(line) {{{1[J

line 279: function! s:UI._indentLevelFor(line)[J

line 287: [J

line 288: "FUNCTION: s:UI.IndentWid() {{{1[J

line 289: function! s:UI.IndentWid()[J

line 292: [J

line 293: "FUNCTION: s:UI.isIgnoreFilterEnabled() {{{1[J

line 294: function! s:UI.isIgnoreFilterEnabled()[J

line 297: [J

line 298: "FUNCTION: s:UI.isMinimal() {{{1[J

line 299: function! s:UI.isMinimal()[J

line 302: [J

line 303: "FUNCTION: s:UI.MarkupReg() {{{1[J

line 304: function! s:UI.MarkupReg()[J

line 307: [J

line 308: "FUNCTION: s:UI._renderBookmarks {{{1[J

line 309: function! s:UI._renderBookmarks()[J

line 328: [J

line 329: "FUNCTION: s:UI.restoreScreenState() {{{1[J

line 330: "[J

line 331: "Sets the screen state back to what it was when nerdtree#saveScreenState was last[J

line 332: "called.[J

line 333: "[J

line 334: "Assumes the cursor is in the NERDTree window[J

line 335: function! s:UI.restoreScreenState()[J

line 348: [J

line 349: "FUNCTION: s:UI.saveScreenState() {{{1[J

line 350: "Saves the current cursor position in the current buffer and the window[J

line 351: "scroll position[J

line 352: function! s:UI.saveScreenState()[J

line 361: [J

line 362: "FUNCTION: s:UI.setShowHidden(val) {{{1[J

line 363: function! s:UI.setShowHidden(val)[J

line 366: [J

line 367: "FUNCTION: s:UI._stripMarkup(line, removeLeadingSpaces){{{1[J

line 368: "returns the given line with all the tree parts stripped off[J

line 369: "[J

line 370: "Args:[J

line 371: "line: the subject line[J

line 372: "removeLeadingSpaces: 1 if leading spaces are to be removed (leading spaces =[J

line 373: "any spaces before the actual text of the node)[J

line 374: function! s:UI._stripMarkup(line, removeLeadingSpaces)[J

line 406: [J

line 407: "FUNCTION: s:UI.render() {{{1[J

line 408: function! s:UI.render()[J

line 459: [J

line 460: [J

line 461: "FUNCTION: UI.renderViewSavingPosition {{{1[J

line 462: "Renders the tree and ensures the cursor stays on the current node or the[J

line 463: "current nodes parent if it is no longer available upon re-rendering[J

line 464: function! s:UI.renderViewSavingPosition()[J

line 479: [J

line 480: "FUNCTION: s:UI.toggleHelp() {{{1[J

line 481: function! s:UI.toggleHelp()[J

line 484: [J

line 485: " FUNCTION: s:UI.toggleIgnoreFilter() {{{1[J

line 486: " toggles the use of the NERDTreeIgnore option[J

line 487: function! s:UI.toggleIgnoreFilter()[J

line 492: [J

line 493: " FUNCTION: s:UI.toggleShowBookmarks() {{{1[J

line 494: " toggles the display of bookmarks[J

line 495: function! s:UI.toggleShowBookmarks()[J

line 505: [J

line 506: " FUNCTION: s:UI.toggleShowFiles() {{{1[J

line 507: " toggles the display of hidden files[J

line 508: function! s:UI.toggleShowFiles()[J

line 513: [J

line 514: " FUNCTION: s:UI.toggleShowHidden() {{{1[J

line 515: " toggles the display of hidden files[J

line 516: function! s:UI.toggleShowHidden()[J

line 521: [J

line 522: " FUNCTION: s:UI.toggleZoom() {{{1[J

line 523: " zoom (maximize/minimize) the NERDTree window[J

line 524: function! s:UI.toggleZoom()[J

line 534: [J

line 535: "FUNCTION: s:UI.UpDirLine() {{{1[J

line 536: function! s:UI.UpDirLine()[J

finished sourcing /home/patrick/.vim/bundle/nerdtree/lib/nerdtree/ui.vim[J
continuing in function nerdtree#loadClassFiles[J
line 13:     runtime lib/nerdtree/event.vim[J

Searching for "lib/nerdtree/event.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vim80/pack/dist/opt/matchit,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/after,/ho[J
Searching for "/home/patrick/.vim/lib/nerdtree/event.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/lib/nerdtree/event.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/lib/nerdtree/event.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/lib/nerdtree/event.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/lib/nerdtree/event.vim"[J
chdir(/home/patrick/.vim/bundle/nerdtree/lib/nerdtree)[J
fchdir() to previous dir[J
line 13: sourcing "/home/patrick/.vim/bundle/nerdtree/lib/nerdtree/event.vim"[J
line 1: "CLASS: Event[J

line 2: "============================================================[J

line 3: let s:Event = {}[J

line 4: let g:NERDTreeEvent = s:Event[J

line 5: [J

line 6: function! s:Event.New(nerdtree, subject, action, params) abort[J

finished sourcing /home/patrick/.vim/bundle/nerdtree/lib/nerdtree/event.vim[J
continuing in function nerdtree#loadClassFiles[J
line 14:     runtime lib/nerdtree/notifier.vim[J

Searching for "lib/nerdtree/notifier.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vim80/pack/dist/opt/matchit,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/after,[J
Searching for "/home/patrick/.vim/lib/nerdtree/notifier.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/lib/nerdtree/notifier.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/lib/nerdtree/notifier.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/lib/nerdtree/notifier.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/lib/nerdtree/notifier.vim"[J
chdir(/home/patrick/.vim/bundle/nerdtree/lib/nerdtree)[J
fchdir() to previous dir[J
line 14: sourcing "/home/patrick/.vim/bundle/nerdtree/lib/nerdtree/notifier.vim"[J
line 1: "CLASS: Notifier[J

line 2: "============================================================[J

line 3: let s:Notifier = {}[J

line 4: [J

line 5: function! s:Notifier.AddListener(event, funcname)[J

line 13: [J

line 14: function! s:Notifier.NotifyListeners(event, path, nerdtree, params)[J

line 21: [J

line 22: function! s:Notifier.GetListenersMap()[J

line 28: [J

line 29: function! s:Notifier.GetListenersForEvent(name)[J

line 33: [J

line 34: let g:NERDTreePathNotifier = deepcopy(s:Notifier)[J

line 35: [J

finished sourcing /home/patrick/.vim/bundle/nerdtree/lib/nerdtree/notifier.vim[J
continuing in function nerdtree#loadClassFiles[J
function nerdtree#loadClassFiles returning #0[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 155: [J

line 156: " SECTION: Commands {{{1[J

line 157: "============================================================[J

line 158: call nerdtree#ui_glue#setupCommands()[J

Searching for "autoload/nerdtree/ui_glue.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vim80/pack/dist/opt/matchit,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/af[J
Searching for "/home/patrick/.vim/autoload/nerdtree/ui_glue.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/autoload/nerdtree/ui_glue.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/autoload/nerdtree/ui_glue.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/autoload/nerdtree/ui_glue.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/autoload/nerdtree/ui_glue.vim"[J
chdir(/home/patrick/.vim/bundle/nerdtree/autoload/nerdtree)[J
fchdir() to previous dir[J
line 158: sourcing "/home/patrick/.vim/bundle/nerdtree/autoload/nerdtree/ui_glue.vim"[J
line 1: if exists("g:loaded_nerdtree_ui_glue_autoload")[J

line 2:     finish[J

line 3: endif[J

line 4: let g:loaded_nerdtree_ui_glue_autoload = 1[J

line 5: [J

line 6: " FUNCTION: nerdtree#ui_glue#createDefaultBindings() {{{1[J

line 7: function! nerdtree#ui_glue#createDefaultBindings()[J

line 80: [J

line 81: [J

line 82: "SECTION: Interface bindings {{{1[J

line 83: "============================================================[J

line 84: [J

line 85: "FUNCTION: s:activateAll() {{{1[J

line 86: "handle the user activating the updir line[J

line 87: function! s:activateAll()[J

line 92: [J

line 93: "FUNCTION: s:activateDirNode() {{{1[J

line 94: "handle the user activating a tree node[J

line 95: function! s:activateDirNode(node)[J

line 98: [J

line 99: "FUNCTION: s:activateFileNode() {{{1[J

line 100: "handle the user activating a tree node[J

line 101: function! s:activateFileNode(node)[J

line 104: [J

line 105: "FUNCTION: s:activateBookmark() {{{1[J

line 106: "handle the user activating a bookmark[J

line 107: function! s:activateBookmark(bm)[J

line 110: [J

line 111: " FUNCTION: nerdtree#ui_glue#bookmarkNode(name) {{{1[J

line 112: " Associate the current node with the given name[J

line 113: function! nerdtree#ui_glue#bookmarkNode(...)[J

line 130: [J

line 131: " FUNCTION: s:chCwd(node) {{{1[J

line 132: function! s:chCwd(node)[J

line 139: [J

line 140: " FUNCTION: s:chRoot(node) {{{1[J

line 141: " changes the current root to the selected one[J

line 142: function! s:chRoot(node)[J

line 145: [J

line 146: " FUNCTION: s:nerdtree#ui_glue#chRootCwd() {{{1[J

line 147: " changes the current root to CWD[J

line 148: function! nerdtree#ui_glue#chRootCwd()[J

line 160: [J

line 161: " FUNCTION: nnerdtree#ui_glue#clearBookmarks(bookmarks) {{{1[J

line 162: function! nerdtree#ui_glue#clearBookmarks(bookmarks)[J

line 177: [J

line 178: " FUNCTION: s:closeChildren(node) {{{1[J

line 179: " closes all childnodes of the current node[J

line 180: function! s:closeChildren(node)[J

line 185: [J

line 186: " FUNCTION: s:closeCurrentDir(node) {{{1[J

line 187: " closes the parent dir of the current node[J

line 188: function! s:closeCurrentDir(node)[J

line 206: [J

line 207: " FUNCTION: s:closeTreeWindow() {{{1[J

line 208: " close the tree window[J

line 209: function! s:closeTreeWindow()[J

line 220: [J

line 221: " FUNCTION: s:deleteBookmark(bm) {{{1[J

line 222: " if the cursor is on a bookmark, prompt to delete[J

line 223: function! s:deleteBookmark(bm)[J

line 240: [J

line 241: " FUNCTION: s:displayHelp() {{{1[J

line 242: " toggles the help display[J

line 243: function! s:displayHelp()[J

line 248: [J

line 249: " FUNCTION: s:findAndRevealPath() {{{1[J

line 250: function! s:findAndRevealPath()[J

line 300: [J

line 301: "FUNCTION: s:handleLeftClick() {{{1[J

line 302: "Checks if the click should open the current node[J

line 303: function! s:handleLeftClick()[J

line 336: [J

line 337: " FUNCTION: s:handleMiddleMouse() {{{1[J

line 338: function! s:handleMiddleMouse()[J

line 357: [J

line 358: " FUNCTION: s:jumpToChild(direction) {{{2[J

line 359: " Args:[J

line 360: " direction: 0 if going to first child, 1 if going to last[J

line 361: function! s:jumpToChild(currentNode, direction)[J

line 385: [J

line 386: [J

line 387: " FUNCTION: nerdtree#ui_glue#invokeKeyMap(key) {{{1[J

line 388: "this is needed since I cant figure out how to invoke dict functions from a[J

line 389: "key map[J

line 390: function! nerdtree#ui_glue#invokeKeyMap(key)[J

line 393: [J

line 394: " FUNCTION: s:jumpToFirstChild() {{{1[J

line 395: " wrapper for the jump to child method[J

line 396: function! s:jumpToFirstChild(node)[J

line 399: [J

line 400: " FUNCTION: s:jumpToLastChild() {{{1[J

line 401: " wrapper for the jump to child method[J

line 402: function! s:jumpToLastChild(node)[J

line 405: [J

line 406: " FUNCTION: s:jumpToParent(node) {{{1[J

line 407: " Move the cursor to the parent of the specified node. For a cascade, move to[J

line 408: " the parent of the cascade's highest node. At the root, do nothing.[J

line 409: function! s:jumpToParent(node)[J

line 430: [J

line 431: " FUNCTION: s:jumpToRoot() {{{1[J

line 432: " moves the cursor to the root node[J

line 433: function! s:jumpToRoot()[J

line 437: [J

line 438: " FUNCTION: s:jumpToNextSibling(node) {{{1[J

line 439: function! s:jumpToNextSibling(node)[J

line 442: [J

line 443: " FUNCTION: s:jumpToPrevSibling(node) {{{1[J

line 444: function! s:jumpToPrevSibling(node)[J

line 447: [J

line 448: " FUNCTION: s:jumpToSibling(currentNode, forward) {{{2[J

line 449: " moves the cursor to the sibling of the current node in the given direction[J

line 450: "[J

line 451: " Args:[J

line 452: " forward: 1 if the cursor should move to the next sibling, 0 if it should[J

line 453: " move back to the previous sibling[J

line 454: function! s:jumpToSibling(currentNode, forward)[J

line 462: [J

line 463: " FUNCTION: nerdtree#ui_glue#openBookmark(name) {{{1[J

line 464: " Open the Bookmark that has the specified name. This function provides the[J

line 465: " implementation for the ":OpenBookmark" command.[J

line 466: function! nerdtree#ui_glue#openBookmark(name)[J

line 479: [J

line 480: " FUNCTION: s:openHSplit(target) {{{1[J

line 481: function! s:openHSplit(target)[J

line 484: [J

line 485: " FUNCTION: s:openVSplit(target) {{{1[J

line 486: function! s:openVSplit(target)[J

line 489: [J

line 490: " FUNCTION: s:openExplorer(node) {{{1[J

line 491: function! s:openExplorer(node)[J

line 494: [J

line 495: " FUNCTION: s:openInNewTab(target) {{{1[J

line 496: function! s:openInNewTab(target)[J

line 499: [J

line 500: " FUNCTION: s:openInNewTabSilent(target) {{{1[J

line 501: function! s:openInNewTabSilent(target)[J

line 504: [J

line 505: " FUNCTION: s:openNodeRecursively(node) {{{1[J

line 506: function! s:openNodeRecursively(node)[J

line 513: [J

line 514: "FUNCTION: s:previewNodeCurrent(node) {{{1[J

line 515: function! s:previewNodeCurrent(node)[J

line 518: [J

line 519: "FUNCTION: s:previewNodeHSplit(node) {{{1[J

line 520: function! s:previewNodeHSplit(node)[J

line 523: [J

line 524: "FUNCTION: s:previewNodeVSplit(node) {{{1[J

line 525: function! s:previewNodeVSplit(node)[J

line 528: [J

line 529: " FUNCTION: nerdtree#ui_glue#revealBookmark(name) {{{1[J

line 530: " put the cursor on the node associate with the given name[J

line 531: function! nerdtree#ui_glue#revealBookmark(name)[J

line 539: [J

line 540: " FUNCTION: s:refreshRoot() {{{1[J

line 541: " Reloads the current root. All nodes below this will be lost and the root dir[J

line 542: " will be reloaded.[J

line 543: function! s:refreshRoot()[J

line 550: [J

line 551: " FUNCTION: s:refreshCurrent(node) {{{1[J

line 552: " refreshes the root for the current node[J

line 553: function! s:refreshCurrent(node)[J

line 565: [J

line 566: " FUNCTION: nerdtree#ui_glue#setupCommands() {{{1[J

line 567: function! nerdtree#ui_glue#setupCommands()[J

line 577: [J

line 578: " Function: s:SID()   {{{1[J

line 579: function s:SID()[J

line 585: [J

line 586: " FUNCTION: s:showMenu(node) {{{1[J

line 587: function! s:showMenu(node)[J

line 591: [J

line 592: " FUNCTION: s:toggleIgnoreFilter() {{{1[J

line 593: function! s:toggleIgnoreFilter()[J

line 596: [J

line 597: " FUNCTION: s:toggleShowBookmarks() {{{1[J

line 598: function! s:toggleShowBookmarks()[J

line 601: [J

line 602: " FUNCTION: s:toggleShowFiles() {{{1[J

line 603: function! s:toggleShowFiles()[J

line 606: [J

line 607: " FUNCTION: s:toggleShowHidden() {{{1[J

line 608: " toggles the display of hidden files[J

line 609: function! s:toggleShowHidden()[J

line 612: [J

line 613: " FUNCTION: s:toggleZoom() {{{1[J

line 614: function! s:toggleZoom()[J

line 617: [J

line 618: "FUNCTION: nerdtree#ui_glue#upDir(keepState) {{{1[J

line 619: "moves the tree up a level[J

line 620: "[J

line 621: "Args:[J

line 622: "keepState: 1 if the current root should be left open when the tree is[J

line 623: "re-rendered[J

line 624: function! nerdtree#ui_glue#upDir(keepState)[J

line 653: [J

line 654: " FUNCTION: s:upDirCurrentRootOpen() {{{1[J

line 655: function! s:upDirCurrentRootOpen()[J

line 658: [J

line 659: " FUNCTION: s:upDirCurrentRootClosed() {{{1[J

line 660: function! s:upDirCurrentRootClosed()[J

line 663: [J

line 664: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /home/patrick/.vim/bundle/nerdtree/autoload/nerdtree/ui_glue.vim[J
continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J
calling function nerdtree#ui_glue#setupCommands[J()

line 1:     command! -n=? -complete=dir -bar NERDTree :call g:NERDTreeCreator.CreateTabTree('<args>')[J

line 2:     command! -n=? -complete=dir -bar NERDTreeToggle :call g:NERDTreeCreator.ToggleTabTree('<args>')[J

line 3:     command! -n=0 -bar NERDTreeClose :call g:NERDTree.Close()[J

line 4:     command! -n=1 -complete=customlist,nerdtree#completeBookmarks -bar NERDTreeFromBookmark call g:NERDTreeCreator.CreateTabTree('<args>')[J

line 5:     command! -n=0 -bar NERDTreeMirror call g:NERDTreeCreator.CreateMirror()[J

line 6:     command! -n=0 -bar NERDTreeFind call s:findAndRevealPath()[J

line 7:     command! -n=0 -bar NERDTreeFocus call NERDTreeFocus()[J

line 8:     command! -n=0 -bar NERDTreeCWD call NERDTreeCWD()[J

function nerdtree#ui_glue#setupCommands returning #0[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 159: [J

line 160: " SECTION: Auto commands {{{1[J

line 161: "============================================================[J

line 162: augroup NERDTree[J

line 163:     "Save the cursor position whenever we close the nerd tree[J

line 164:     exec "autocmd BufLeave ". g:NERDTreeCreator.BufNamePrefix() ."* if g:NERDTree.IsOpen() | call b:NERDTree.ui.saveScreenState() | endif"[J

calling function 183[J()

line 1:     return 'NERD_tree_'[J

function 183 returning 'NERD_tree_'[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 164: autocmd BufLeave NERD_tree_* if g:NERDTree.IsOpen() | call b:NERDTree.ui.saveScreenState() | endif[J

line 165: [J

line 166:     "disallow insert mode in the NERDTree[J

line 167:     exec "autocmd BufEnter ". g:NERDTreeCreator.BufNamePrefix() ."* stopinsert"[J

calling function 183[J()

line 1:     return 'NERD_tree_'[J

function 183 returning 'NERD_tree_'[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 167: autocmd BufEnter NERD_tree_* stopinsert[J

line 168: augroup END[J

line 169: [J

line 170: if g:NERDTreeHijackNetrw[J

line 171:     augroup NERDTreeHijackNetrw[J

line 172:         autocmd VimEnter * silent! autocmd! FileExplorer[J

line 173:         au BufEnter,VimEnter * call nerdtree#checkForBrowse(expand("<amatch>"))[J

line 174:     augroup END[J

line 175: endif[J

line 176: [J

line 177: " SECTION: Public API {{{1[J

line 178: "============================================================[J

line 179: function! NERDTreeAddMenuItem(options)[J

line 182: [J

line 183: function! NERDTreeAddMenuSeparator(...)[J

line 187: [J

line 188: function! NERDTreeAddSubmenu(options)[J

line 191: [J

line 192: function! NERDTreeAddKeyMap(options)[J

line 195: [J

line 196: function! NERDTreeRender()[J

line 199: [J

line 200: function! NERDTreeFocus()[J

line 207: [J

line 208: function! NERDTreeCWD()[J

line 212: [J

line 213: function! NERDTreeAddPathFilter(callback)[J

line 216: [J

line 217: " SECTION: Post Source Actions {{{1[J

line 218: call nerdtree#postSourceActions()[J

calling function nerdtree#postSourceActions[J()

line 1:     call g:NERDTreeBookmark.CacheBookmarks(1)[J

calling function nerdtree#postSourceActions[1]..85[J(1)

line 1:     if filereadable(g:NERDTreeBookmarksFile)[J

line 2:         let g:NERDTreeBookmarks = [][J

line 3:         let g:NERDTreeInvalidBookmarks = [][J

line 4:         let bookmarkStrings = readfile(g:NERDTreeBookmarksFile)[J

line 5:         let invalidBookmarksFound = 0[J

line 6:         for i in bookmarkStrings[J

line 7: [J

line 8:             "ignore blank lines[J

line 9:             if i != ''[J

line 10: [J

line 11:                 let name = substitute(i, '^\(.\{-}\) .*$', '\1', '')[J

line 12:                 let path = substitute(i, '^.\{-} \(.*\)$', '\1', '')[J

line 13:                 let path = fnamemodify(path, ':p')[J

line 14: [J

line 15:                 try[J

line 16:                     let bookmark = s:Bookmark.New(name, g:NERDTreePath.New(path))[J

line 17:                     call add(g:NERDTreeBookmarks, bookmark)[J

line 18:                 catch /^NERDTree.InvalidArgumentsError/[J

line 19:                     call add(g:NERDTreeInvalidBookmarks, i)[J

line 20:                     let invalidBookmarksFound += 1[J

line 21:                 endtry[J

line 22:             endif[J

line 23:         endfor[J

line 24:         if invalidBookmarksFound[J

line 25:             call s:Bookmark.Write()[J

line 26:             if !a:silent[J

line 27:                 call nerdtree#echo(invalidBookmarksFound . " invalid bookmarks were read. See :help NERDTreeInvalidBookmarks for info.")[J

line 28:             endif[J

line 29:         endif[J

line 30:     endif[J

function nerdtree#postSourceActions[1]..85 returning #0[J

continuing in function nerdtree#postSourceActions[J

line 2:     call nerdtree#ui_glue#createDefaultBindings()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J()

line 1:     let s = '<SNR>' . s:SID() . '_'[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[1]..<SNR>33_SID[J()

line 1:     if !exists("s:sid")[J

line 2:         let s:sid = matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$')[J

line 3:     endif[J

line 4:     return s:sid[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[1]..<SNR>33_SID returning '33'[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 2: [J

line 3:     call NERDTreeAddKeyMap({ 'key': '<MiddleMouse>', 'scope': 'all', 'callback': s . 'handleMiddleMouse' })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[J({'key': '<MiddleMouse>', 'scope': 'all...callback': '<SNR>33_handleMiddleMouse'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..77[J({'key': '<MiddleMouse>', 'scope': 'all...callback': '<SNR>33_handleMiddleMouse'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..77[4]..71[J('<MiddleMouse>', 'all')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...leMiddleMouse', 'key': '<MiddleMouse>'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('<MiddleMouse>', 'all')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 4:     call NERDTreeAddKeyMap({ 'key': '<LeftRelease>', 'scope': "all", 'callback': s."handleLeftClick" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[J({'key': '<LeftRelease>', 'scope': 'all', 'callback': '<SNR>33_handleLeftClick'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..77[J({'key': '<LeftRelease>', 'scope': 'all', 'callback': '<SNR>33_handleLeftClick'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..77[4]..71[J('<LeftRelease>', 'all')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...eMiddleMouse', 'key': '<MiddleMouse>'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...ndleLeftClick', 'key': '<LeftRelease>'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('<LeftRelease>', 'all')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...eMiddleMouse', 'key': '<MiddleMouse>'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...eMiddleMouse', 'key': '<MiddleMouse>'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 5:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "DirNode", 'callback': s."activateDirNode" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[J({'key': '<2-LeftMouse>', 'scope': 'Dir... 'callback': '<SNR>33_activateDirNode'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..77[J({'key': '<2-LeftMouse>', 'scope': 'Dir... 'callback': '<SNR>33_activateDirNode'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..77[4]..71[J('<2-LeftMouse>', 'DirNode')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...dleLeftClick', 'key': '<LeftRelease>'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...tivateDirNode', 'key': '<2-LeftMouse>'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('<2-LeftMouse>', 'DirNode')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...dleLeftClick', 'key': '<LeftRelease>'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...dleLeftClick', 'key': '<LeftRelease>'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 6:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "FileNode", 'callback': s."activateFileNode" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[J({'key': '<2-LeftMouse>', 'scope': 'Fil...'callback': '<SNR>33_activateFileNode'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..77[J({'key': '<2-LeftMouse>', 'scope': 'Fil...'callback': '<SNR>33_activateFileNode'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..77[4]..71[J('<2-LeftMouse>', 'FileNode')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...ivateDirNode', 'key': '<2-LeftMouse>'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...ivateFileNode', 'key': '<2-LeftMouse>'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('<2-LeftMouse>', 'FileNode')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...ivateDirNode', 'key': '<2-LeftMouse>'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...ivateDirNode', 'key': '<2-LeftMouse>'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 7:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "Bookmark", 'callback': s."activateBookmark" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[J({'key': '<2-LeftMouse>', 'scope': 'Boo...'callback': '<SNR>33_activateBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..77[J({'key': '<2-LeftMouse>', 'scope': 'Boo...'callback': '<SNR>33_activateBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..77[4]..71[J('<2-LeftMouse>', 'Bookmark')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...vateFileNode', 'key': '<2-LeftMouse>'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...ivateBookmark', 'key': '<2-LeftMouse>'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('<2-LeftMouse>', 'Bookmark')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...vateFileNode', 'key': '<2-LeftMouse>'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...vateFileNode', 'key': '<2-LeftMouse>'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 8:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "all", 'callback': s."activateAll" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[J({'key': '<2-LeftMouse>', 'scope': 'all', 'callback': '<SNR>33_activateAll'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..77[J({'key': '<2-LeftMouse>', 'scope': 'all', 'callback': '<SNR>33_activateAll'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..77[4]..71[J('<2-LeftMouse>', 'all')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...vateBookmark', 'key': '<2-LeftMouse>'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...3_activateAll', 'key': '<2-LeftMouse>'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('<2-LeftMouse>', 'all')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...vateBookmark', 'key': '<2-LeftMouse>'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...vateBookmark', 'key': '<2-LeftMouse>'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 9: [J

line 10: [J

line 11:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "DirNode", 'callback': s."activateDirNode" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[J({'key': 'o', 'scope': 'DirNode', 'callback': '<SNR>33_activateDirNode'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..77[J({'key': 'o', 'scope': 'DirNode', 'callback': '<SNR>33_activateDirNode'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..77[4]..71[J('o', 'DirNode')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu..._activateAll', 'key': '<2-LeftMouse>'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun... '<SNR>33_activateDirNode', 'key': 'o'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('o', 'DirNode')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu..._activateAll', 'key': '<2-LeftMouse>'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu..._activateAll', 'key': '<2-LeftMouse>'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 12:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "FileNode", 'callback': s."activateFileNode" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[J({'key': 'o', 'scope': 'FileNode', 'callback': '<SNR>33_activateFileNode'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..77[J({'key': 'o', 'scope': 'FileNode', 'callback': '<SNR>33_activateFileNode'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..77[4]..71[J('o', 'FileNode')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...'<SNR>33_activateDirNode', 'key': 'o'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...'<SNR>33_activateFileNode', 'key': 'o'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('o', 'FileNode')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...'<SNR>33_activateDirNode', 'key': 'o'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...'<SNR>33_activateDirNode', 'key': 'o'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 13:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "Bookmark", 'callback': s."activateBookmark" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[J({'key': 'o', 'scope': 'Bookmark', 'callback': '<SNR>33_activateBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..77[J({'key': 'o', 'scope': 'Bookmark', 'callback': '<SNR>33_activateBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..77[4]..71[J('o', 'Bookmark')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...<SNR>33_activateFileNode', 'key': 'o'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...'<SNR>33_activateBookmark', 'key': 'o'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('o', 'Bookmark')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...<SNR>33_activateFileNode', 'key': 'o'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...<SNR>33_activateFileNode', 'key': 'o'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 14:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "all", 'callback': s."activateAll" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[J({'key': 'o', 'scope': 'all', 'callback': '<SNR>33_activateAll'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..77[J({'key': 'o', 'scope': 'all', 'callback': '<SNR>33_activateAll'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..77[4]..71[J('o', 'all')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...<SNR>33_activateBookmark', 'key': 'o'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...ck': '<SNR>33_activateAll', 'key': 'o'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('o', 'all')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...<SNR>33_activateBookmark', 'key': 'o'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...<SNR>33_activateBookmark', 'key': 'o'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 15: [J

line 16:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenSplit, 'scope': "Node", 'callback': s."openHSplit" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[J({'key': 'i', 'scope': 'Node', 'callback': '<SNR>33_openHSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..77[J({'key': 'i', 'scope': 'Node', 'callback': '<SNR>33_openHSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..77[4]..71[J('i', 'Node')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...k': '<SNR>33_activateAll', 'key': 'o'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...ack': '<SNR>33_openHSplit', 'key': 'i'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('i', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...k': '<SNR>33_activateAll', 'key': 'o'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...k': '<SNR>33_activateAll', 'key': 'o'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 17:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenVSplit, 'scope': "Node", 'callback': s."openVSplit" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[J({'key': 's', 'scope': 'Node', 'callback': '<SNR>33_openVSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..77[J({'key': 's', 'scope': 'Node', 'callback': '<SNR>33_openVSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..77[4]..71[J('s', 'Node')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...ck': '<SNR>33_openHSplit', 'key': 'i'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...ack': '<SNR>33_openVSplit', 'key': 's'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('s', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...ck': '<SNR>33_openHSplit', 'key': 'i'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...ck': '<SNR>33_openHSplit', 'key': 'i'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 18: [J

line 19:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenSplit, 'scope': "Bookmark", 'callback': s."openHSplit" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[J({'key': 'i', 'scope': 'Bookmark', 'callback': '<SNR>33_openHSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..77[J({'key': 'i', 'scope': 'Bookmark', 'callback': '<SNR>33_openHSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..77[4]..71[J('i', 'Bookmark')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...ck': '<SNR>33_openVSplit', 'key': 's'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...ack': '<SNR>33_openHSplit', 'key': 'i'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('i', 'Bookmark')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...ck': '<SNR>33_openVSplit', 'key': 's'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...ck': '<SNR>33_openVSplit', 'key': 's'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 20:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenVSplit, 'scope': "Bookmark", 'callback': s."openVSplit" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[J({'key': 's', 'scope': 'Bookmark', 'callback': '<SNR>33_openVSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..77[J({'key': 's', 'scope': 'Bookmark', 'callback': '<SNR>33_openVSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..77[4]..71[J('s', 'Bookmark')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...ck': '<SNR>33_openHSplit', 'key': 'i'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...ack': '<SNR>33_openVSplit', 'key': 's'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('s', 'Bookmark')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...ck': '<SNR>33_openHSplit', 'key': 'i'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...ck': '<SNR>33_openHSplit', 'key': 'i'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 21: [J

line 22:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreview, 'scope': "Node", 'callback': s."previewNodeCurrent" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[J({'key': 'go', 'scope': 'Node', 'callback': '<SNR>33_previewNodeCurrent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..77[J({'key': 'go', 'scope': 'Node', 'callback': '<SNR>33_previewNodeCurrent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..77[4]..71[J('go', 'Node')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...ck': '<SNR>33_openVSplit', 'key': 's'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...NR>33_previewNodeCurrent', 'key': 'go'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('go', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...ck': '<SNR>33_openVSplit', 'key': 's'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...ck': '<SNR>33_openVSplit', 'key': 's'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 23:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewVSplit, 'scope': "Node", 'callback': s."previewNodeVSplit" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[J({'key': 'gs', 'scope': 'Node', 'callback': '<SNR>33_previewNodeVSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..77[J({'key': 'gs', 'scope': 'Node', 'callback': '<SNR>33_previewNodeVSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..77[4]..71[J('gs', 'Node')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...R>33_previewNodeCurrent', 'key': 'go'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...SNR>33_previewNodeVSplit', 'key': 'gs'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('gs', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...R>33_previewNodeCurrent', 'key': 'go'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...R>33_previewNodeCurrent', 'key': 'go'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 24:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewSplit, 'scope': "Node", 'callback': s."previewNodeHSplit" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[J({'key': 'gi', 'scope': 'Node', 'callback': '<SNR>33_previewNodeHSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..77[J({'key': 'gi', 'scope': 'Node', 'callback': '<SNR>33_previewNodeHSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..77[4]..71[J('gi', 'Node')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...NR>33_previewNodeVSplit', 'key': 'gs'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...SNR>33_previewNodeHSplit', 'key': 'gi'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('gi', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...NR>33_previewNodeVSplit', 'key': 'gs'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...NR>33_previewNodeVSplit', 'key': 'gs'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 25: [J

line 26:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreview, 'scope': "Bookmark", 'callback': s."previewNodeCurrent" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[J({'key': 'go', 'scope': 'Bookmark', 'callback': '<SNR>33_previewNodeCurrent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..77[J({'key': 'go', 'scope': 'Bookmark', 'callback': '<SNR>33_previewNodeCurrent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..77[4]..71[J('go', 'Bookmark')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...NR>33_previewNodeHSplit', 'key': 'gi'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...NR>33_previewNodeCurrent', 'key': 'go'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('go', 'Bookmark')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...NR>33_previewNodeHSplit', 'key': 'gi'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...NR>33_previewNodeHSplit', 'key': 'gi'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 27:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewVSplit, 'scope': "Bookmark", 'callback': s."previewNodeVSplit" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[J({'key': 'gs', 'scope': 'Bookmark', 'callback': '<SNR>33_previewNodeVSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..77[J({'key': 'gs', 'scope': 'Bookmark', 'callback': '<SNR>33_previewNodeVSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..77[4]..71[J('gs', 'Bookmark')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...R>33_previewNodeCurrent', 'key': 'go'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...SNR>33_previewNodeVSplit', 'key': 'gs'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('gs', 'Bookmark')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...R>33_previewNodeCurrent', 'key': 'go'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...R>33_previewNodeCurrent', 'key': 'go'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 28:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewSplit, 'scope': "Bookmark", 'callback': s."previewNodeHSplit" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[J({'key': 'gi', 'scope': 'Bookmark', 'callback': '<SNR>33_previewNodeHSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..77[J({'key': 'gi', 'scope': 'Bookmark', 'callback': '<SNR>33_previewNodeHSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..77[4]..71[J('gi', 'Bookmark')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...NR>33_previewNodeVSplit', 'key': 'gs'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...SNR>33_previewNodeHSplit', 'key': 'gi'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('gi', 'Bookmark')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...NR>33_previewNodeVSplit', 'key': 'gs'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...NR>33_previewNodeVSplit', 'key': 'gs'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 29: [J

line 30:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenRecursively, 'scope': "DirNode", 'callback': s."openNodeRecursively" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[J({'key': 'O', 'scope': 'DirNode', 'callback': '<SNR>33_openNodeRecursively'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..77[J({'key': 'O', 'scope': 'DirNode', 'callback': '<SNR>33_openNodeRecursively'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..77[4]..71[J('O', 'DirNode')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...NR>33_previewNodeHSplit', 'key': 'gi'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...NR>33_openNodeRecursively', 'key': 'O'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('O', 'DirNode')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...NR>33_previewNodeHSplit', 'key': 'gi'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...NR>33_previewNodeHSplit', 'key': 'gi'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 31: [J

line 32:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdir, 'scope': "all", 'callback': s."upDirCurrentRootClosed" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[J({'key': 'u', 'scope': 'all', 'callback': '<SNR>33_upDirCurrentRootClosed'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..77[J({'key': 'u', 'scope': 'all', 'callback': '<SNR>33_upDirCurrentRootClosed'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..77[4]..71[J('u', 'all')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...R>33_openNodeRecursively', 'key': 'O'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...33_upDirCurrentRootClosed', 'key': 'u'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('u', 'all')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...R>33_openNodeRecursively', 'key': 'O'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...R>33_openNodeRecursively', 'key': 'O'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 33:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdirKeepOpen, 'scope': "all", 'callback': s."upDirCurrentRootOpen" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[J({'key': 'U', 'scope': 'all', 'callback': '<SNR>33_upDirCurrentRootOpen'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..77[J({'key': 'U', 'scope': 'all', 'callback': '<SNR>33_upDirCurrentRootOpen'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..77[4]..71[J('U', 'all')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...3_upDirCurrentRootClosed', 'key': 'u'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...R>33_upDirCurrentRootOpen', 'key': 'U'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('U', 'all')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...3_upDirCurrentRootClosed', 'key': 'u'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...3_upDirCurrentRootClosed', 'key': 'u'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 34:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapChangeRoot, 'scope': "Node", 'callback': s."chRoot" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[J({'key': 'C', 'scope': 'Node', 'callback': '<SNR>33_chRoot'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..77[J({'key': 'C', 'scope': 'Node', 'callback': '<SNR>33_chRoot'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..77[4]..71[J('C', 'Node')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...>33_upDirCurrentRootOpen', 'key': 'U'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...allback': '<SNR>33_chRoot', 'key': 'C'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('C', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...>33_upDirCurrentRootOpen', 'key': 'U'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...>33_upDirCurrentRootOpen', 'key': 'U'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 35: [J

line 36:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapChdir, 'scope': "Node", 'callback': s."chCwd" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[J({'key': 'cd', 'scope': 'Node', 'callback': '<SNR>33_chCwd'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..77[J({'key': 'cd', 'scope': 'Node', 'callback': '<SNR>33_chCwd'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..77[4]..71[J('cd', 'Node')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...llback': '<SNR>33_chRoot', 'key': 'C'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...allback': '<SNR>33_chCwd', 'key': 'cd'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('cd', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...llback': '<SNR>33_chRoot', 'key': 'C'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...llback': '<SNR>33_chRoot', 'key': 'C'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 37: [J

line 38:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapQuit, 'scope': "all", 'callback': s."closeTreeWindow" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[J({'key': 'q', 'scope': 'all', 'callback': '<SNR>33_closeTreeWindow'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..77[J({'key': 'q', 'scope': 'all', 'callback': '<SNR>33_closeTreeWindow'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..77[4]..71[J('q', 'all')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...llback': '<SNR>33_chCwd', 'key': 'cd'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun... '<SNR>33_closeTreeWindow', 'key': 'q'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('q', 'all')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...llback': '<SNR>33_chCwd', 'key': 'cd'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...llback': '<SNR>33_chCwd', 'key': 'cd'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 39: [J

line 40:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCWD, 'scope': "all", 'callback': "nerdtree#ui_glue#chRootCwd" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[J({'key': 'CD', 'scope': 'all', 'callback': 'nerdtree#ui_glue#chRootCwd'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..77[J({'key': 'CD', 'scope': 'all', 'callback': 'nerdtree#ui_glue#chRootCwd'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..77[4]..71[J('CD', 'all')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...'<SNR>33_closeTreeWindow', 'key': 'q'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...rdtree#ui_glue#chRootCwd', 'key': 'CD'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('CD', 'all')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...'<SNR>33_closeTreeWindow', 'key': 'q'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...'<SNR>33_closeTreeWindow', 'key': 'q'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 41: [J

line 42:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapRefreshRoot, 'scope': "all", 'callback': s."refreshRoot" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[J({'key': 'R', 'scope': 'all', 'callback': '<SNR>33_refreshRoot'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..77[J({'key': 'R', 'scope': 'all', 'callback': '<SNR>33_refreshRoot'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..77[4]..71[J('R', 'all')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...dtree#ui_glue#chRootCwd', 'key': 'CD'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...ck': '<SNR>33_refreshRoot', 'key': 'R'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('R', 'all')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...dtree#ui_glue#chRootCwd', 'key': 'CD'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...dtree#ui_glue#chRootCwd', 'key': 'CD'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 43:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapRefresh, 'scope': "Node", 'callback': s."refreshCurrent" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[J({'key': 'r', 'scope': 'Node', 'callback': '<SNR>33_refreshCurrent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..77[J({'key': 'r', 'scope': 'Node', 'callback': '<SNR>33_refreshCurrent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..77[4]..71[J('r', 'Node')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...k': '<SNR>33_refreshRoot', 'key': 'R'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...: '<SNR>33_refreshCurrent', 'key': 'r'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('r', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...k': '<SNR>33_refreshRoot', 'key': 'R'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...k': '<SNR>33_refreshRoot', 'key': 'R'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 44: [J

line 45:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapHelp, 'scope': "all", 'callback': s."displayHelp" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[J({'key': '?', 'scope': 'all', 'callback': '<SNR>33_displayHelp'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..77[J({'key': '?', 'scope': 'all', 'callback': '<SNR>33_displayHelp'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..77[4]..71[J('?', 'all')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu... '<SNR>33_refreshCurrent', 'key': 'r'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...ck': '<SNR>33_displayHelp', 'key': '?'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('?', 'all')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu... '<SNR>33_refreshCurrent', 'key': 'r'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu... '<SNR>33_refreshCurrent', 'key': 'r'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 46:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleZoom, 'scope': "all", 'callback': s."toggleZoom" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[J({'key': 'A', 'scope': 'all', 'callback': '<SNR>33_toggleZoom'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..77[J({'key': 'A', 'scope': 'all', 'callback': '<SNR>33_toggleZoom'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..77[4]..71[J('A', 'all')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...k': '<SNR>33_displayHelp', 'key': '?'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...ack': '<SNR>33_toggleZoom', 'key': 'A'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('A', 'all')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...k': '<SNR>33_displayHelp', 'key': '?'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...k': '<SNR>33_displayHelp', 'key': '?'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 47:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleHidden, 'scope': "all", 'callback': s."toggleShowHidden" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[J({'key': 'I', 'scope': 'all', 'callback': '<SNR>33_toggleShowHidden'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..77[J({'key': 'I', 'scope': 'all', 'callback': '<SNR>33_toggleShowHidden'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..77[4]..71[J('I', 'all')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...ck': '<SNR>33_toggleZoom', 'key': 'A'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...'<SNR>33_toggleShowHidden', 'key': 'I'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('I', 'all')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...ck': '<SNR>33_toggleZoom', 'key': 'A'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...ck': '<SNR>33_toggleZoom', 'key': 'A'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 48:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleFilters, 'scope': "all", 'callback': s."toggleIgnoreFilter" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[J({'key': 'f', 'scope': 'all', 'callback': '<SNR>33_toggleIgnoreFilter'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..77[J({'key': 'f', 'scope': 'all', 'callback': '<SNR>33_toggleIgnoreFilter'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..77[4]..71[J('f', 'all')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...<SNR>33_toggleShowHidden', 'key': 'I'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...SNR>33_toggleIgnoreFilter', 'key': 'f'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('f', 'all')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...<SNR>33_toggleShowHidden', 'key': 'I'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...<SNR>33_toggleShowHidden', 'key': 'I'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 49:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleFiles, 'scope': "all", 'callback': s."toggleShowFiles" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[J({'key': 'F', 'scope': 'all', 'callback': '<SNR>33_toggleShowFiles'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..77[J({'key': 'F', 'scope': 'all', 'callback': '<SNR>33_toggleShowFiles'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..77[4]..71[J('F', 'all')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...NR>33_toggleIgnoreFilter', 'key': 'f'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun... '<SNR>33_toggleShowFiles', 'key': 'F'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('F', 'all')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...NR>33_toggleIgnoreFilter', 'key': 'f'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...NR>33_toggleIgnoreFilter', 'key': 'f'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 50:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleBookmarks, 'scope': "all", 'callback': s."toggleShowBookmarks" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[J({'key': 'B', 'scope': 'all', 'callback': '<SNR>33_toggleShowBookmarks'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..77[J({'key': 'B', 'scope': 'all', 'callback': '<SNR>33_toggleShowBookmarks'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..77[4]..71[J('B', 'all')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...'<SNR>33_toggleShowFiles', 'key': 'F'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...NR>33_toggleShowBookmarks', 'key': 'B'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('B', 'all')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...'<SNR>33_toggleShowFiles', 'key': 'F'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...'<SNR>33_toggleShowFiles', 'key': 'F'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 51: [J

line 52:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseDir, 'scope': "Node", 'callback': s."closeCurrentDir" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[J({'key': 'x', 'scope': 'Node', 'callback': '<SNR>33_closeCurrentDir'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..77[J({'key': 'x', 'scope': 'Node', 'callback': '<SNR>33_closeCurrentDir'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..77[4]..71[J('x', 'Node')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...R>33_toggleShowBookmarks', 'key': 'B'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun... '<SNR>33_closeCurrentDir', 'key': 'x'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('x', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...R>33_toggleShowBookmarks', 'key': 'B'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...R>33_toggleShowBookmarks', 'key': 'B'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 53:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseChildren, 'scope': "DirNode", 'callback': s."closeChildren" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[J({'key': 'X', 'scope': 'DirNode', 'callback': '<SNR>33_closeChildren'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..77[J({'key': 'X', 'scope': 'DirNode', 'callback': '<SNR>33_closeChildren'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..77[4]..71[J('X', 'DirNode')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...'<SNR>33_closeCurrentDir', 'key': 'x'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...': '<SNR>33_closeChildren', 'key': 'X'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('X', 'DirNode')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...'<SNR>33_closeCurrentDir', 'key': 'x'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...'<SNR>33_closeCurrentDir', 'key': 'x'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 54: [J

line 55:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapMenu, 'scope': "Node", 'callback': s."showMenu" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[J({'key': 'm', 'scope': 'Node', 'callback': '<SNR>33_showMenu'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..77[J({'key': 'm', 'scope': 'Node', 'callback': '<SNR>33_showMenu'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..77[4]..71[J('m', 'Node')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...: '<SNR>33_closeChildren', 'key': 'X'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...lback': '<SNR>33_showMenu', 'key': 'm'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('m', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...: '<SNR>33_closeChildren', 'key': 'X'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...: '<SNR>33_closeChildren', 'key': 'X'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 56: [J

line 57:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpParent, 'scope': "Node", 'callback': s."jumpToParent" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[J({'key': 'p', 'scope': 'Node', 'callback': '<SNR>33_jumpToParent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..77[J({'key': 'p', 'scope': 'Node', 'callback': '<SNR>33_jumpToParent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..77[4]..71[J('p', 'Node')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...back': '<SNR>33_showMenu', 'key': 'm'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...k': '<SNR>33_jumpToParent', 'key': 'p'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('p', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...back': '<SNR>33_showMenu', 'key': 'm'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...back': '<SNR>33_showMenu', 'key': 'm'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 58:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpFirstChild, 'scope': "Node", 'callback': s."jumpToFirstChild" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[J({'key': 'K', 'scope': 'Node', 'callback': '<SNR>33_jumpToFirstChild'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..77[J({'key': 'K', 'scope': 'Node', 'callback': '<SNR>33_jumpToFirstChild'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..77[4]..71[J('K', 'Node')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...': '<SNR>33_jumpToParent', 'key': 'p'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...'<SNR>33_jumpToFirstChild', 'key': 'K'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('K', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...': '<SNR>33_jumpToParent', 'key': 'p'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...': '<SNR>33_jumpToParent', 'key': 'p'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 59:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpLastChild, 'scope': "Node", 'callback': s."jumpToLastChild" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[J({'key': 'J', 'scope': 'Node', 'callback': '<SNR>33_jumpToLastChild'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..77[J({'key': 'J', 'scope': 'Node', 'callback': '<SNR>33_jumpToLastChild'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..77[4]..71[J('J', 'Node')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...<SNR>33_jumpToFirstChild', 'key': 'K'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun... '<SNR>33_jumpToLastChild', 'key': 'J'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('J', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...<SNR>33_jumpToFirstChild', 'key': 'K'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...<SNR>33_jumpToFirstChild', 'key': 'K'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 60:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpRoot, 'scope': "all", 'callback': s."jumpToRoot" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[J({'key': 'P', 'scope': 'all', 'callback': '<SNR>33_jumpToRoot'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..77[J({'key': 'P', 'scope': 'all', 'callback': '<SNR>33_jumpToRoot'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..77[4]..71[J('P', 'all')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...'<SNR>33_jumpToLastChild', 'key': 'J'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...ack': '<SNR>33_jumpToRoot', 'key': 'P'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('P', 'all')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...'<SNR>33_jumpToLastChild', 'key': 'J'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...'<SNR>33_jumpToLastChild', 'key': 'J'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 61:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpNextSibling, 'scope': "Node", 'callback': s."jumpToNextSibling" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[J({'key': '<C-j>', 'scope': 'Node', 'callback': '<SNR>33_jumpToNextSibling'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..77[J({'key': '<C-j>', 'scope': 'Node', 'callback': '<SNR>33_jumpToNextSibling'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..77[4]..71[J('<C-j>', 'Node')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...ck': '<SNR>33_jumpToRoot', 'key': 'P'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...>33_jumpToNextSibling', 'key': '<C-j>'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('<C-j>', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...ck': '<SNR>33_jumpToRoot', 'key': 'P'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...ck': '<SNR>33_jumpToRoot', 'key': 'P'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 62:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpPrevSibling, 'scope': "Node", 'callback': s."jumpToPrevSibling" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[J({'key': '<C-k>', 'scope': 'Node', 'callback': '<SNR>33_jumpToPrevSibling'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..77[J({'key': '<C-k>', 'scope': 'Node', 'callback': '<SNR>33_jumpToPrevSibling'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..77[4]..71[J('<C-k>', 'Node')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...33_jumpToNextSibling', 'key': '<C-j>'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...>33_jumpToPrevSibling', 'key': '<C-k>'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('<C-k>', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...33_jumpToNextSibling', 'key': '<C-j>'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...33_jumpToNextSibling', 'key': '<C-j>'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 63: [J

line 64:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTab, 'scope': "Node", 'callback': s."openInNewTab" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[J({'key': 't', 'scope': 'Node', 'callback': '<SNR>33_openInNewTab'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..77[J({'key': 't', 'scope': 'Node', 'callback': '<SNR>33_openInNewTab'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..77[4]..71[J('t', 'Node')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...33_jumpToPrevSibling', 'key': '<C-k>'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...k': '<SNR>33_openInNewTab', 'key': 't'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('t', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...33_jumpToPrevSibling', 'key': '<C-k>'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...33_jumpToPrevSibling', 'key': '<C-k>'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 65:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTabSilent, 'scope': "Node", 'callback': s."openInNewTabSilent" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[J({'key': 'T', 'scope': 'Node', 'callback': '<SNR>33_openInNewTabSilent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..77[J({'key': 'T', 'scope': 'Node', 'callback': '<SNR>33_openInNewTabSilent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..77[4]..71[J('T', 'Node')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...': '<SNR>33_openInNewTab', 'key': 't'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...SNR>33_openInNewTabSilent', 'key': 'T'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('T', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...': '<SNR>33_openInNewTab', 'key': 't'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...': '<SNR>33_openInNewTab', 'key': 't'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 66:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTab, 'scope': "Bookmark", 'callback': s."openInNewTab" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[J({'key': 't', 'scope': 'Bookmark', 'callback': '<SNR>33_openInNewTab'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..77[J({'key': 't', 'scope': 'Bookmark', 'callback': '<SNR>33_openInNewTab'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..77[4]..71[J('t', 'Bookmark')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...NR>33_openInNewTabSilent', 'key': 'T'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...k': '<SNR>33_openInNewTab', 'key': 't'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('t', 'Bookmark')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...NR>33_openInNewTabSilent', 'key': 'T'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...NR>33_openInNewTabSilent', 'key': 'T'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 67:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTabSilent, 'scope': "Bookmark", 'callback': s."openInNewTabSilent" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[J({'key': 'T', 'scope': 'Bookmark', 'callback': '<SNR>33_openInNewTabSilent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..77[J({'key': 'T', 'scope': 'Bookmark', 'callback': '<SNR>33_openInNewTabSilent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..77[4]..71[J('T', 'Bookmark')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...': '<SNR>33_openInNewTab', 'key': 't'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...SNR>33_openInNewTabSilent', 'key': 'T'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('T', 'Bookmark')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...': '<SNR>33_openInNewTab', 'key': 't'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...': '<SNR>33_openInNewTab', 'key': 't'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 68: [J

line 69:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenExpl, 'scope': "DirNode", 'callback': s."openExplorer" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[J({'key': 'e', 'scope': 'DirNode', 'callback': '<SNR>33_openExplorer'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..77[J({'key': 'e', 'scope': 'DirNode', 'callback': '<SNR>33_openExplorer'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..77[4]..71[J('e', 'DirNode')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...NR>33_openInNewTabSilent', 'key': 'T'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...k': '<SNR>33_openExplorer', 'key': 'e'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('e', 'DirNode')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...NR>33_openInNewTabSilent', 'key': 'T'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...NR>33_openInNewTabSilent', 'key': 'T'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

line 70: [J

line 71:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapDeleteBookmark, 'scope': "Bookmark", 'callback': s."deleteBookmark" })[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[J({'key': 'D', 'scope': 'Bookmark', 'callback': '<SNR>33_deleteBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..77[J({'key': 'D', 'scope': 'Bookmark', 'callback': '<SNR>33_deleteBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..77[4]..71[J('D', 'Bookmark')

line 1:     for i in s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...': '<SNR>33_openExplorer', 'key': 'e'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun...: '<SNR>33_deleteBookmark', 'key': 'D'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('D', 'Bookmark')

line 1:     let maps = s:KeyMap.All()[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...': '<SNR>33_openExplorer', 'key': 'e'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...': '<SNR>33_openExplorer', 'key': 'e'}][J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..77[14]..78[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..77[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap returning #0[J

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[J

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings returning #0[J

continuing in function nerdtree#postSourceActions[J

line 3: [J

line 4:     "load all nerdtree plugins[J

line 5:     runtime! nerdtree_plugin/**/*.vim[J

Searching for "nerdtree_plugin/**/*.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vim80/pack/dist/opt/matchit,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/after,/[J
Searching for "/home/patrick/.vim/nerdtree_plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/nerdtree_plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/nerdtree_plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/nerdtree_plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/nerdtree_plugin/**/*.vim"[J
chdir(/home/patrick/.vim/bundle/nerdtree/nerdtree_plugin)[J
fchdir() to previous dir[J
line 5: sourcing "/home/patrick/.vim/bundle/nerdtree/nerdtree_plugin/exec_menuitem.vim"[J
line 1: " ============================================================================[J

line 2: " File:        exec_menuitem.vim[J

line 3: " Description: plugin for NERD Tree that provides an execute file menu item[J

line 4: " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>[J

line 5: " License:     This program is free software. It comes without any warranty,[J

line 6: "              to the extent permitted by applicable law. You can redistribute[J

line 7: "              it and/or modify it under the terms of the Do What The Fuck You[J

line 8: "              Want To Public License, Version 2, as published by Sam Hocevar.[J

line 9: "              See http://sam.zoy.org/wtfpl/COPYING for more details.[J

line 10: "[J

line 11: " ============================================================================[J

line 12: if exists("g:loaded_nerdtree_exec_menuitem")[J

line 13:     finish[J

line 14: endif[J

line 15: let g:loaded_nerdtree_exec_menuitem = 1[J

line 16: [J

line 21: call NERDTreeAddMenuItem({ 'text': '(!)Execute file', 'shortcut': '!', 'callback': 'NERDTreeExecFile', 'isActiveCallback': 'NERDTreeExecFileActive' })[J

calling function NERDTreeAddMenuItem[J({'callback': 'NERDTreeExecFile', 'shor...iveCallback': 'NERDTreeExecFileActive'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)[J

calling function NERDTreeAddMenuItem[1]..63[J({'callback': 'NERDTreeExecFile', 'shor...iveCallback': 'NERDTreeExecFileActive'})

line 1:     let newMenuItem = copy(self)[J

line 2: [J

line 3:     let newMenuItem.text = a:options['text'][J

line 4:     let newMenuItem.shortcut = a:options['shortcut'][J

line 5:     let newMenuItem.children = [][J

line 6: [J

line 7:     let newMenuItem.isActiveCallback = -1[J

line 8:     if has_key(a:options, 'isActiveCallback')[J

line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback'][J

line 10:     endif[J

line 11: [J

line 12:     let newMenuItem.callback = -1[J

line 13:     if has_key(a:options, 'callback')[J

line 14:         let newMenuItem.callback = a:options['callback'][J

line 15:     endif[J

line 16: [J

line 17:     if has_key(a:options, 'parent')[J

line 18:         call add(a:options['parent'].children, newMenuItem)[J

line 19:     else[J

line 20:         call add(s:MenuItem.All(), newMenuItem)[J

calling function NERDTreeAddMenuItem[1]..63[20]..61[J()

line 1:     if !exists("s:menuItems")[J

line 2:         let s:menuItems = [][J

line 3:     endif[J

line 4:     return s:menuItems[J

function NERDTreeAddMenuItem[1]..63[20]..61 returning [][J

continuing in function NERDTreeAddMenuItem[1]..63[J

line 21:     endif[J

line 22: [J

line 23:     return newMenuItem[J

function NERDTreeAddMenuItem[1]..63 returning {'All': function('61'), 'isActiveCallb...reeExecFile', 'Create': function('63')}[J

continuing in function NERDTreeAddMenuItem[J

function NERDTreeAddMenuItem returning #0[J

continuing in /home/patrick/.vim/bundle/nerdtree/nerdtree_plugin/exec_menuitem.vim[J

line 22: [J

line 23: function! NERDTreeExecFileActive()[J

line 27: [J

line 28: function! NERDTreeExecFile()[J

finished sourcing /home/patrick/.vim/bundle/nerdtree/nerdtree_plugin/exec_menuitem.vim[J
continuing in function nerdtree#postSourceActions[J
chdir(/home/patrick/.vim/bundle/nerdtree/nerdtree_plugin)[J
fchdir() to previous dir[J
line 5: sourcing "/home/patrick/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim"[J
line 1: " ============================================================================[J

line 2: " File:        fs_menu.vim[J

line 3: " Description: plugin for the NERD Tree that provides a file system menu[J

line 4: " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>[J

line 5: " License:     This program is free software. It comes without any warranty,[J

line 6: "              to the extent permitted by applicable law. You can redistribute[J

line 7: "              it and/or modify it under the terms of the Do What The Fuck You[J

line 8: "              Want To Public License, Version 2, as published by Sam Hocevar.[J

line 9: "              See http://sam.zoy.org/wtfpl/COPYING for more details.[J

line 10: "[J

line 11: " ============================================================================[J

line 12: if exists("g:loaded_nerdtree_fs_menu")[J

line 13:     finish[J

line 14: endif[J

line 15: let g:loaded_nerdtree_fs_menu = 1[J

line 16: [J

line 17: "Automatically delete the buffer after deleting or renaming a file[J

line 18: if !exists("g:NERDTreeAutoDeleteBuffer")[J

line 19:     let g:NERDTreeAutoDeleteBuffer = 0[J

line 20: endif[J

line 21: [J

line 22: call NERDTreeAddMenuItem({'text': '(a)dd a childnode', 'shortcut': 'a', 'callback': 'NERDTreeAddNode'})[J

calling function NERDTreeAddMenuItem[J({'callback': 'NERDTreeAddNode', 'shortcut': 'a', 'text': '(a)dd a childnode'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)[J

calling function NERDTreeAddMenuItem[1]..63[J({'callback': 'NERDTreeAddNode', 'shortcut': 'a', 'text': '(a)dd a childnode'})

line 1:     let newMenuItem = copy(self)[J

line 2: [J

line 3:     let newMenuItem.text = a:options['text'][J

line 4:     let newMenuItem.shortcut = a:options['shortcut'][J

line 5:     let newMenuItem.children = [][J

line 6: [J

line 7:     let newMenuItem.isActiveCallback = -1[J

line 8:     if has_key(a:options, 'isActiveCallback')[J

line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback'][J

line 10:     endif[J

line 11: [J

line 12:     let newMenuItem.callback = -1[J

line 13:     if has_key(a:options, 'callback')[J

line 14:         let newMenuItem.callback = a:options['callback'][J

line 15:     endif[J

line 16: [J

line 17:     if has_key(a:options, 'parent')[J

line 18:         call add(a:options['parent'].children, newMenuItem)[J

line 19:     else[J

line 20:         call add(s:MenuItem.All(), newMenuItem)[J

calling function NERDTreeAddMenuItem[1]..63[20]..61[J()

line 1:     if !exists("s:menuItems")[J

line 2:         let s:menuItems = [][J

line 3:     endif[J

line 4:     return s:menuItems[J

function NERDTreeAddMenuItem[1]..63[20]..61 returning [{'All': function('61'), 'isActiveCall...eeExecFile', 'Create': function('63')}][J

continuing in function NERDTreeAddMenuItem[1]..63[J

line 21:     endif[J

line 22: [J

line 23:     return newMenuItem[J

function NERDTreeAddMenuItem[1]..63 returning {'All': function('61'), 'isActiveCallb...TreeAddNode', 'Create': function('63')}[J

continuing in function NERDTreeAddMenuItem[J

function NERDTreeAddMenuItem returning #0[J

continuing in /home/patrick/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim[J

line 23: call NERDTreeAddMenuItem({'text': '(m)ove the current node', 'shortcut': 'm', 'callback': 'NERDTreeMoveNode'})[J

calling function NERDTreeAddMenuItem[J({'callback': 'NERDTreeMoveNode', 'shor...'m', 'text': '(m)ove the current node'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)[J

calling function NERDTreeAddMenuItem[1]..63[J({'callback': 'NERDTreeMoveNode', 'shor...'m', 'text': '(m)ove the current node'})

line 1:     let newMenuItem = copy(self)[J

line 2: [J

line 3:     let newMenuItem.text = a:options['text'][J

line 4:     let newMenuItem.shortcut = a:options['shortcut'][J

line 5:     let newMenuItem.children = [][J

line 6: [J

line 7:     let newMenuItem.isActiveCallback = -1[J

line 8:     if has_key(a:options, 'isActiveCallback')[J

line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback'][J

line 10:     endif[J

line 11: [J

line 12:     let newMenuItem.callback = -1[J

line 13:     if has_key(a:options, 'callback')[J

line 14:         let newMenuItem.callback = a:options['callback'][J

line 15:     endif[J

line 16: [J

line 17:     if has_key(a:options, 'parent')[J

line 18:         call add(a:options['parent'].children, newMenuItem)[J

line 19:     else[J

line 20:         call add(s:MenuItem.All(), newMenuItem)[J

calling function NERDTreeAddMenuItem[1]..63[20]..61[J()

line 1:     if !exists("s:menuItems")[J

line 2:         let s:menuItems = [][J

line 3:     endif[J

line 4:     return s:menuItems[J

function NERDTreeAddMenuItem[1]..63[20]..61 returning [{'All': function('61'), 'isActiveCall...reeAddNode', 'Create': function('63')}][J

continuing in function NERDTreeAddMenuItem[1]..63[J

line 21:     endif[J

line 22: [J

line 23:     return newMenuItem[J

function NERDTreeAddMenuItem[1]..63 returning {'All': function('61'), 'isActiveCallb...reeMoveNode', 'Create': function('63')}[J

continuing in function NERDTreeAddMenuItem[J

function NERDTreeAddMenuItem returning #0[J

continuing in /home/patrick/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim[J

line 24: call NERDTreeAddMenuItem({'text': '(d)elete the current node', 'shortcut': 'd', 'callback': 'NERDTreeDeleteNode'})[J

calling function NERDTreeAddMenuItem[J({'callback': 'NERDTreeDeleteNode', 'sh...', 'text': '(d)elete the current node'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)[J

calling function NERDTreeAddMenuItem[1]..63[J({'callback': 'NERDTreeDeleteNode', 'sh...', 'text': '(d)elete the current node'})

line 1:     let newMenuItem = copy(self)[J

line 2: [J

line 3:     let newMenuItem.text = a:options['text'][J

line 4:     let newMenuItem.shortcut = a:options['shortcut'][J

line 5:     let newMenuItem.children = [][J

line 6: [J

line 7:     let newMenuItem.isActiveCallback = -1[J

line 8:     if has_key(a:options, 'isActiveCallback')[J

line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback'][J

line 10:     endif[J

line 11: [J

line 12:     let newMenuItem.callback = -1[J

line 13:     if has_key(a:options, 'callback')[J

line 14:         let newMenuItem.callback = a:options['callback'][J

line 15:     endif[J

line 16: [J

line 17:     if has_key(a:options, 'parent')[J

line 18:         call add(a:options['parent'].children, newMenuItem)[J

line 19:     else[J

line 20:         call add(s:MenuItem.All(), newMenuItem)[J

calling function NERDTreeAddMenuItem[1]..63[20]..61[J()

line 1:     if !exists("s:menuItems")[J

line 2:         let s:menuItems = [][J

line 3:     endif[J

line 4:     return s:menuItems[J

function NERDTreeAddMenuItem[1]..63[20]..61 returning [{'All': function('61'), 'isActiveCall...eeMoveNode', 'Create': function('63')}][J

continuing in function NERDTreeAddMenuItem[1]..63[J

line 21:     endif[J

line 22: [J

line 23:     return newMenuItem[J

function NERDTreeAddMenuItem[1]..63 returning {'All': function('61'), 'isActiveCallb...eDeleteNode', 'Create': function('63')}[J

continuing in function NERDTreeAddMenuItem[J

function NERDTreeAddMenuItem returning #0[J

continuing in /home/patrick/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim[J

line 25: [J

line 26: if has("gui_mac") || has("gui_macvim") || has("mac")[J

line 27:     call NERDTreeAddMenuItem({'text': '(r)eveal in Finder the current node', 'shortcut': 'r', 'callback': 'NERDTreeRevealInFinder'})[J

line 28:     call NERDTreeAddMenuItem({'text': '(o)pen the current node with system editor', 'shortcut': 'o', 'callback': 'NERDTreeExecuteFile'})[J

line 29:     call NERDTreeAddMenuItem({'text': '(q)uicklook the current node', 'shortcut': 'q', 'callback': 'NERDTreeQuickLook'})[J

line 30: endif[J

line 31: [J

line 32: if g:NERDTreePath.CopyingSupported()[J

calling function 10[J()

line 1:     return exists('g:NERDTreeCopyCmd') || (exists('g:NERDTreeCopyDirCmd') && exists('g:NERDTreeCopyFileCmd'))[J

function 10 returning #1[J

continuing in /home/patrick/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim[J

line 33:     call NERDTreeAddMenuItem({'text': '(c)opy the current node', 'shortcut': 'c', 'callback': 'NERDTreeCopyNode'})[J

calling function NERDTreeAddMenuItem[J({'callback': 'NERDTreeCopyNode', 'shor...'c', 'text': '(c)opy the current node'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)[J

calling function NERDTreeAddMenuItem[1]..63[J({'callback': 'NERDTreeCopyNode', 'shor...'c', 'text': '(c)opy the current node'})

line 1:     let newMenuItem = copy(self)[J

line 2: [J

line 3:     let newMenuItem.text = a:options['text'][J

line 4:     let newMenuItem.shortcut = a:options['shortcut'][J

line 5:     let newMenuItem.children = [][J

line 6: [J

line 7:     let newMenuItem.isActiveCallback = -1[J

line 8:     if has_key(a:options, 'isActiveCallback')[J

line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback'][J

line 10:     endif[J

line 11: [J

line 12:     let newMenuItem.callback = -1[J

line 13:     if has_key(a:options, 'callback')[J

line 14:         let newMenuItem.callback = a:options['callback'][J

line 15:     endif[J

line 16: [J

line 17:     if has_key(a:options, 'parent')[J

line 18:         call add(a:options['parent'].children, newMenuItem)[J

line 19:     else[J

line 20:         call add(s:MenuItem.All(), newMenuItem)[J

calling function NERDTreeAddMenuItem[1]..63[20]..61[J()

line 1:     if !exists("s:menuItems")[J

line 2:         let s:menuItems = [][J

line 3:     endif[J

line 4:     return s:menuItems[J

function NERDTreeAddMenuItem[1]..63[20]..61 returning [{'All': function('61'), 'isActiveCall...DeleteNode', 'Create': function('63')}][J

continuing in function NERDTreeAddMenuItem[1]..63[J

line 21:     endif[J

line 22: [J

line 23:     return newMenuItem[J

function NERDTreeAddMenuItem[1]..63 returning {'All': function('61'), 'isActiveCallb...reeCopyNode', 'Create': function('63')}[J

continuing in function NERDTreeAddMenuItem[J

function NERDTreeAddMenuItem returning #0[J

continuing in /home/patrick/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim[J

line 34: endif[J

line 35: [J

line 36: if has("unix") || has("osx")[J

line 37:     call NERDTreeAddMenuItem({'text': '(l)ist the current node', 'shortcut': 'l', 'callback': 'NERDTreeListNode'})[J

calling function NERDTreeAddMenuItem[J({'callback': 'NERDTreeListNode', 'shor...'l', 'text': '(l)ist the current node'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)[J

calling function NERDTreeAddMenuItem[1]..63[J({'callback': 'NERDTreeListNode', 'shor...'l', 'text': '(l)ist the current node'})

line 1:     let newMenuItem = copy(self)[J

line 2: [J

line 3:     let newMenuItem.text = a:options['text'][J

line 4:     let newMenuItem.shortcut = a:options['shortcut'][J

line 5:     let newMenuItem.children = [][J

line 6: [J

line 7:     let newMenuItem.isActiveCallback = -1[J

line 8:     if has_key(a:options, 'isActiveCallback')[J

line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback'][J

line 10:     endif[J

line 11: [J

line 12:     let newMenuItem.callback = -1[J

line 13:     if has_key(a:options, 'callback')[J

line 14:         let newMenuItem.callback = a:options['callback'][J

line 15:     endif[J

line 16: [J

line 17:     if has_key(a:options, 'parent')[J

line 18:         call add(a:options['parent'].children, newMenuItem)[J

line 19:     else[J

line 20:         call add(s:MenuItem.All(), newMenuItem)[J

calling function NERDTreeAddMenuItem[1]..63[20]..61[J()

line 1:     if !exists("s:menuItems")[J

line 2:         let s:menuItems = [][J

line 3:     endif[J

line 4:     return s:menuItems[J

function NERDTreeAddMenuItem[1]..63[20]..61 returning [{'All': function('61'), 'isActiveCall...eeCopyNode', 'Create': function('63')}][J

continuing in function NERDTreeAddMenuItem[1]..63[J

line 21:     endif[J

line 22: [J

line 23:     return newMenuItem[J

function NERDTreeAddMenuItem[1]..63 returning {'All': function('61'), 'isActiveCallb...reeListNode', 'Create': function('63')}[J

continuing in function NERDTreeAddMenuItem[J

function NERDTreeAddMenuItem returning #0[J

continuing in /home/patrick/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim[J

line 38: else[J

line 39:     call NERDTreeAddMenuItem({'text': '(l)ist the current node', 'shortcut': 'l', 'callback': 'NERDTreeListNodeWin32'})[J

line 40: endif[J

line 41: [J

line 42: "FUNCTION: s:promptToDelBuffer(bufnum, msg){{{1[J

line 43: "prints out the given msg and, if the user responds by pushing 'y' then the[J

line 44: "buffer with the given bufnum is deleted[J

line 45: "[J

line 46: "Args:[J

line 47: "bufnum: the buffer that may be deleted[J

line 48: "msg: a message that will be echoed to the user asking them if they wish to[J

line 49: "     del the buffer[J

line 50: function! s:promptToDelBuffer(bufnum, msg)[J

line 65: [J

line 66: "FUNCTION: s:promptToRenameBuffer(bufnum, msg){{{1[J

line 67: "prints out the given msg and, if the user responds by pushing 'y' then the[J

line 68: "buffer with the given bufnum is replaced with a new one[J

line 69: "[J

line 70: "Args:[J

line 71: "bufnum: the buffer that may be deleted[J

line 72: "msg: a message that will be echoed to the user asking them if they wish to[J

line 73: "     del the buffer[J

line 74: function! s:promptToRenameBuffer(bufnum, msg, newFileName)[J

line 92: "FUNCTION: NERDTreeAddNode(){{{1[J

line 93: function! NERDTreeAddNode()[J

line 123: [J

line 124: "FUNCTION: NERDTreeMoveNode(){{{1[J

line 125: function! NERDTreeMoveNode()[J

line 157: [J

line 158: " FUNCTION: NERDTreeDeleteNode() {{{1[J

line 159: function! NERDTreeDeleteNode()[J

line 201: [J

line 202: " FUNCTION: NERDTreeListNode() {{{1[J

line 203: function! NERDTreeListNode()[J

line 212: [J

line 213: " FUNCTION: NERDTreeListNodeWin32() {{{1[J

line 214: function! NERDTreeListNodeWin32()[J

line 250: [J

line 251: " FUNCTION: NERDTreeCopyNode() {{{1[J

line 252: function! NERDTreeCopyNode()[J

line 289: [J

line 290: " FUNCTION: NERDTreeQuickLook() {{{1[J

line 291: function! NERDTreeQuickLook()[J

line 297: [J

line 298: " FUNCTION: NERDTreeRevealInFinder() {{{1[J

line 299: function! NERDTreeRevealInFinder()[J

line 305: [J

line 306: " FUNCTION: NERDTreeExecuteFile() {{{1[J

line 307: function! NERDTreeExecuteFile()[J

line 313: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /home/patrick/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim[J
continuing in function nerdtree#postSourceActions[J
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/nerdtree_plugin/**/*.vim"[J
chdir(/home/patrick/.vim/bundle/nerdtree-git-plugin/nerdtree_plugin)[J
fchdir() to previous dir[J
line 5: sourcing "/home/patrick/.vim/bundle/nerdtree-git-plugin/nerdtree_plugin/git_status.vim"[J
line 1: " ============================================================================[J

line 2: " File:        git_status.vim[J

line 3: " Description: plugin for NERD Tree that provides git status support[J

line 4: " Maintainer:  Xuyuan Pang <xuyuanp at gmail dot com>[J

line 5: " Last Change: 4 Apr 2014[J

line 6: " License:     This program is free software. It comes without any warranty,[J

line 7: "              to the extent permitted by applicable law. You can redistribute[J

line 8: "              it and/or modify it under the terms of the Do What The Fuck You[J

line 9: "              Want To Public License, Version 2, as published by Sam Hocevar.[J

line 10: "              See http://sam.zoy.org/wtfpl/COPYING for more details.[J

line 11: " ============================================================================[J

line 12: if exists('g:loaded_nerdtree_git_status')[J

line 13:     finish[J

line 14: endif[J

line 15: let g:loaded_nerdtree_git_status = 1[J

line 16: [J

line 17: if !exists('g:NERDTreeShowGitStatus')[J

line 18:     let g:NERDTreeShowGitStatus = 1[J

line 19: endif[J

line 20: [J

line 21: if g:NERDTreeShowGitStatus == 0[J

line 22:     finish[J

line 23: endif[J

line 24: [J

line 25: if !exists('g:NERDTreeMapNextHunk')[J

line 26:     let g:NERDTreeMapNextHunk = ']c'[J

line 27: endif[J

line 28: [J

line 29: if !exists('g:NERDTreeMapPrevHunk')[J

line 30:     let g:NERDTreeMapPrevHunk = '[c'[J

line 31: endif[J

line 32: [J

line 33: if !exists('g:NERDTreeUpdateOnWrite')[J

line 34:     let g:NERDTreeUpdateOnWrite = 1[J

line 35: endif[J

line 36: [J

line 37: if !exists('g:NERDTreeUpdateOnCursorHold')[J

line 38:     let g:NERDTreeUpdateOnCursorHold = 1[J

line 39: endif[J

line 40: [J

line 41: if !exists('g:NERDTreeShowIgnoredStatus')[J

line 42:     let g:NERDTreeShowIgnoredStatus = 0[J

line 43: endif[J

line 44: [J

line 45: if !exists('s:NERDTreeIndicatorMap')[J

line 57:     let s:NERDTreeIndicatorMap = { 'Modified'  : '✹', 'Staged'    : '✚', 'Untracked' : '✭', 'Renamed'   : '➜', 'Unmerged'  : '═', 'Deleted'   : '✖', 'Dirty'     : '✗', 'Clean'     : '✔︎', 'Ignored'   : '☒', 'Unknown'   : '?' }[J

line 58: endif[J

line 59: [J

line 60: [J

line 61: function! NERDTreeGitStatusRefreshListener(event)[J

line 72: [J

line 73: " FUNCTION: g:NERDTreeGitStatusRefresh() {{{2[J

line 74: " refresh cached git status[J

line 75: function! g:NERDTreeGitStatusRefresh()[J

line 125: [J

line 126: function! s:NERDTreeCacheDirtyDir(pathStr)[J

line 138: [J

line 139: function! s:NERDTreeTrimDoubleQuotes(pathStr)[J

line 144: [J

line 145: " FUNCTION: g:NERDTreeGetGitStatusPrefix(path) {{{2[J

line 146: " return the indicator of the path[J

line 147: " Args: path[J

line 148: let s:GitStatusCacheTimeExpiry = 2[J

line 149: let s:GitStatusCacheTime = 0[J

line 150: function! g:NERDTreeGetGitStatusPrefix(path)[J

line 170: [J

line 171: " FUNCTION: s:NERDTreeGetCWDGitStatus() {{{2[J

line 172: " return the indicator of cwd[J

line 173: function! g:NERDTreeGetCWDGitStatus()[J

line 181: [J

line 182: function! s:NERDTreeGetIndicator(statusKey)[J

line 195: [J

line 196: function! s:NERDTreeGetFileGitStatusKey(us, them)[J

line 215: [J

line 216: " FUNCTION: s:jumpToNextHunk(node) {{{2[J

line 217: function! s:jumpToNextHunk(node)[J

line 223: [J

line 224: " FUNCTION: s:jumpToPrevHunk(node) {{{2[J

line 225: function! s:jumpToPrevHunk(node)[J

line 231: [J

line 232: " Function: s:SID()   {{{2[J

line 233: function s:SID()[J

line 239: [J

line 240: " FUNCTION: s:NERDTreeGitStatusKeyMapping {{{2[J

line 241: function! s:NERDTreeGitStatusKeyMapping()[J

line 257: [J

line 258: augroup nerdtreegitplugin[J

line 259:     autocmd CursorHold * silent! call s:CursorHoldUpdate()[J

line 260: augroup END[J

line 261: " FUNCTION: s:CursorHoldUpdate() {{{2[J

line 262: function! s:CursorHoldUpdate()[J

line 286: [J

line 287: augroup nerdtreegitplugin[J

line 288:     autocmd BufWritePost * call s:FileUpdate(expand('%:p'))[J

line 289: augroup END[J

line 290: " FUNCTION: s:FileUpdate(fname) {{{2[J

line 291: function! s:FileUpdate(fname)[J

line 320: [J

line 321: augroup AddHighlighting[J

line 322:     autocmd FileType nerdtree call s:AddHighlighting()[J

line 323: augroup END[J

line 324: function! s:AddHighlighting()[J

line 349: [J

line 350: function! s:SetupListeners()[J

line 355: [J

line 356: if g:NERDTreeShowGitStatus && executable('git')[J

line 357:     call s:NERDTreeGitStatusKeyMapping()[J

calling function <SNR>36_NERDTreeGitStatusKeyMapping[J()

line 1:     let l:s = '<SNR>' . s:SID() . '_'[J

calling function <SNR>36_NERDTreeGitStatusKeyMapping[1]..<SNR>36_SID[J()

line 1:     if !exists('s:sid')[J

line 2:         let s:sid = matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$')[J

line 3:     endif[J

line 4:     return s:sid[J

function <SNR>36_NERDTreeGitStatusKeyMapping[1]..<SNR>36_SID returning '36'[J

continuing in function <SNR>36_NERDTreeGitStatusKeyMapping[J

line 2: [J

line 3:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapNextHunk, 'scope': 'Node', 'callback': l:s.'jumpToNextHunk', 'quickhelpText': 'Jump to next git hunk' })[J

calling function <SNR>36_NERDTreeGitStatusKeyMapping[3]..NERDTreeAddKeyMap[J({'key': ']c', 'scope': 'Node', 'quickh..., 'callback': '<SNR>36_jumpToNextHunk'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function <SNR>36_NERDTreeGitStatusKeyMapping[3]..NERDTreeAddKeyMap[1]..77[J({'key': ']c', 'scope': 'Node', 'quickh..., 'callback': '<SNR>36_jumpToNextHunk'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function <SNR>36_NERDTreeGitStatusKeyMapping[3]..NERDTreeAddKeyMap[1]..77[4]..71[J(']c', 'Node')

line 1:     for i in s:KeyMap.All()[J

calling function <SNR>36_NERDTreeGitStatusKeyMapping[3]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>36_NERDTreeGitStatusKeyMapping[3]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu... '<SNR>33_deleteBookmark', 'key': 'D'}][J

continuing in function <SNR>36_NERDTreeGitStatusKeyMapping[3]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function <SNR>36_NERDTreeGitStatusKeyMapping[3]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function <SNR>36_NERDTreeGitStatusKeyMapping[3]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>36_NERDTreeGitStatusKeyMapping[3]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun... '<SNR>36_jumpToNextHunk', 'key': ']c'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>36_NERDTreeGitStatusKeyMapping[3]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J(']c', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>36_NERDTreeGitStatusKeyMapping[3]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>36_NERDTreeGitStatusKeyMapping[3]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu... '<SNR>33_deleteBookmark', 'key': 'D'}][J

continuing in function <SNR>36_NERDTreeGitStatusKeyMapping[3]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>36_NERDTreeGitStatusKeyMapping[3]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function <SNR>36_NERDTreeGitStatusKeyMapping[3]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>36_NERDTreeGitStatusKeyMapping[3]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>36_NERDTreeGitStatusKeyMapping[3]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu... '<SNR>33_deleteBookmark', 'key': 'D'}][J

continuing in function <SNR>36_NERDTreeGitStatusKeyMapping[3]..NERDTreeAddKeyMap[1]..77[14]..78[J

function <SNR>36_NERDTreeGitStatusKeyMapping[3]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function <SNR>36_NERDTreeGitStatusKeyMapping[3]..NERDTreeAddKeyMap[1]..77[J

function <SNR>36_NERDTreeGitStatusKeyMapping[3]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function <SNR>36_NERDTreeGitStatusKeyMapping[3]..NERDTreeAddKeyMap[J

function <SNR>36_NERDTreeGitStatusKeyMapping[3]..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>36_NERDTreeGitStatusKeyMapping[J

line 8: [J

line 9:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPrevHunk, 'scope': 'Node', 'callback': l:s.'jumpToPrevHunk', 'quickhelpText': 'Jump to prev git hunk' })[J

calling function <SNR>36_NERDTreeGitStatusKeyMapping[9]..NERDTreeAddKeyMap[J({'key': '[c', 'scope': 'Node', 'quickh..., 'callback': '<SNR>36_jumpToPrevHunk'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling function <SNR>36_NERDTreeGitStatusKeyMapping[9]..NERDTreeAddKeyMap[1]..77[J({'key': '[c', 'scope': 'Node', 'quickh..., 'callback': '<SNR>36_jumpToPrevHunk'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling function <SNR>36_NERDTreeGitStatusKeyMapping[9]..NERDTreeAddKeyMap[1]..77[4]..71[J('[c', 'Node')

line 1:     for i in s:KeyMap.All()[J

calling function <SNR>36_NERDTreeGitStatusKeyMapping[9]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>36_NERDTreeGitStatusKeyMapping[9]..NERDTreeAddKeyMap[1]..77[4]..71[1]..70 returning [{'All': function('70'), 'BindAll': fu...'<SNR>36_jumpToNextHunk', 'key': ']c'}][J

continuing in function <SNR>36_NERDTreeGitStatusKeyMapping[9]..NERDTreeAddKeyMap[1]..77[4]..71[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 1:     for i in s:KeyMap.All()[J

line 2:          if i.key ==# a:key && i.scope ==# a:scope[J

line 3:             return i[J

line 4:         endif[J

line 5:     endfor[J

line 6:     return {}[J

function <SNR>36_NERDTreeGitStatusKeyMapping[9]..NERDTreeAddKeyMap[1]..77[4]..71 returning {}[J

continuing in function <SNR>36_NERDTreeGitStatusKeyMapping[9]..NERDTreeAddKeyMap[1]..77[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>36_NERDTreeGitStatusKeyMapping[9]..NERDTreeAddKeyMap[1]..77[14]..78[J({'All': function('70'), 'BindAll': fun... '<SNR>36_jumpToPrevHunk', 'key': '[c'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>36_NERDTreeGitStatusKeyMapping[9]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J('[c', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>36_NERDTreeGitStatusKeyMapping[9]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>36_NERDTreeGitStatusKeyMapping[9]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[1]..70 returning [{'All': function('70'), 'BindAll': fu...'<SNR>36_jumpToNextHunk', 'key': ']c'}][J

continuing in function <SNR>36_NERDTreeGitStatusKeyMapping[9]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>36_NERDTreeGitStatusKeyMapping[9]..NERDTreeAddKeyMap[1]..77[14]..78[1]..74 returning #0[J

continuing in function <SNR>36_NERDTreeGitStatusKeyMapping[9]..NERDTreeAddKeyMap[1]..77[14]..78[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>36_NERDTreeGitStatusKeyMapping[9]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>36_NERDTreeGitStatusKeyMapping[9]..NERDTreeAddKeyMap[1]..77[14]..78[2]..70 returning [{'All': function('70'), 'BindAll': fu...'<SNR>36_jumpToNextHunk', 'key': ']c'}][J

continuing in function <SNR>36_NERDTreeGitStatusKeyMapping[9]..NERDTreeAddKeyMap[1]..77[14]..78[J

function <SNR>36_NERDTreeGitStatusKeyMapping[9]..NERDTreeAddKeyMap[1]..77[14]..78 returning #0[J

continuing in function <SNR>36_NERDTreeGitStatusKeyMapping[9]..NERDTreeAddKeyMap[1]..77[J

function <SNR>36_NERDTreeGitStatusKeyMapping[9]..NERDTreeAddKeyMap[1]..77 returning #0[J

continuing in function <SNR>36_NERDTreeGitStatusKeyMapping[9]..NERDTreeAddKeyMap[J

function <SNR>36_NERDTreeGitStatusKeyMapping[9]..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>36_NERDTreeGitStatusKeyMapping[J

line 14: [J

function <SNR>36_NERDTreeGitStatusKeyMapping returning #0[J

continuing in /home/patrick/.vim/bundle/nerdtree-git-plugin/nerdtree_plugin/git_status.vim[J

line 358:     call s:SetupListeners()[J

calling function <SNR>36_SetupListeners[J()

line 1:     call g:NERDTreePathNotifier.AddListener('init', 'NERDTreeGitStatusRefreshListener')[J

calling function <SNR>36_SetupListeners[1]..261[J('init', 'NERDTreeGitStatusRefreshListener')

line 1:     let listeners = s:Notifier.GetListenersForEvent(a:event)[J

calling function <SNR>36_SetupListeners[1]..261[1]..264[J('init')

line 1:     let listenersMap = s:Notifier.GetListenersMap()[J

calling function <SNR>36_SetupListeners[1]..261[1]..264[1]..263[J()

line 1:     if !exists("s:refreshListenersMap")[J

line 2:         let s:refreshListenersMap = {}[J

line 3:     endif[J

line 4:     return s:refreshListenersMap[J

function <SNR>36_SetupListeners[1]..261[1]..264[1]..263 returning {}[J

continuing in function <SNR>36_SetupListeners[1]..261[1]..264[J

line 2:     return get(listenersMap, a:name, [])[J

function <SNR>36_SetupListeners[1]..261[1]..264 returning [][J

continuing in function <SNR>36_SetupListeners[1]..261[J

line 2:     if listeners == [][J

line 3:         let listenersMap = s:Notifier.GetListenersMap()[J

calling function <SNR>36_SetupListeners[1]..261[3]..263[J()

line 1:     if !exists("s:refreshListenersMap")[J

line 2:         let s:refreshListenersMap = {}[J

line 3:     endif[J

line 4:     return s:refreshListenersMap[J

function <SNR>36_SetupListeners[1]..261[3]..263 returning {}[J

continuing in function <SNR>36_SetupListeners[1]..261[J

line 4:         let listenersMap[a:event] = listeners[J

line 5:     endif[J

line 6:     call add(listeners, a:funcname)[J

function <SNR>36_SetupListeners[1]..261 returning #0[J

continuing in function <SNR>36_SetupListeners[J

line 2:     call g:NERDTreePathNotifier.AddListener('refresh', 'NERDTreeGitStatusRefreshListener')[J

calling function <SNR>36_SetupListeners[2]..261[J('refresh', 'NERDTreeGitStatusRefreshListener')

line 1:     let listeners = s:Notifier.GetListenersForEvent(a:event)[J

calling function <SNR>36_SetupListeners[2]..261[1]..264[J('refresh')

line 1:     let listenersMap = s:Notifier.GetListenersMap()[J

calling function <SNR>36_SetupListeners[2]..261[1]..264[1]..263[J()

line 1:     if !exists("s:refreshListenersMap")[J

line 2:         let s:refreshListenersMap = {}[J

line 3:     endif[J

line 4:     return s:refreshListenersMap[J

function <SNR>36_SetupListeners[2]..261[1]..264[1]..263 returning {'init': ['NERDTreeGitStatusRefreshListener']}[J

continuing in function <SNR>36_SetupListeners[2]..261[1]..264[J

line 2:     return get(listenersMap, a:name, [])[J

function <SNR>36_SetupListeners[2]..261[1]..264 returning [][J

continuing in function <SNR>36_SetupListeners[2]..261[J

line 2:     if listeners == [][J

line 3:         let listenersMap = s:Notifier.GetListenersMap()[J

calling function <SNR>36_SetupListeners[2]..261[3]..263[J()

line 1:     if !exists("s:refreshListenersMap")[J

line 2:         let s:refreshListenersMap = {}[J

line 3:     endif[J

line 4:     return s:refreshListenersMap[J

function <SNR>36_SetupListeners[2]..261[3]..263 returning {'init': ['NERDTreeGitStatusRefreshListener']}[J

continuing in function <SNR>36_SetupListeners[2]..261[J

line 4:         let listenersMap[a:event] = listeners[J

line 5:     endif[J

line 6:     call add(listeners, a:funcname)[J

function <SNR>36_SetupListeners[2]..261 returning #0[J

continuing in function <SNR>36_SetupListeners[J

line 3:     call g:NERDTreePathNotifier.AddListener('refreshFlags', 'NERDTreeGitStatusRefreshListener')[J

calling function <SNR>36_SetupListeners[3]..261[J('refreshFlags', 'NERDTreeGitStatusRefreshListener')

line 1:     let listeners = s:Notifier.GetListenersForEvent(a:event)[J

calling function <SNR>36_SetupListeners[3]..261[1]..264[J('refreshFlags')

line 1:     let listenersMap = s:Notifier.GetListenersMap()[J

calling function <SNR>36_SetupListeners[3]..261[1]..264[1]..263[J()

line 1:     if !exists("s:refreshListenersMap")[J

line 2:         let s:refreshListenersMap = {}[J

line 3:     endif[J

line 4:     return s:refreshListenersMap[J

function <SNR>36_SetupListeners[3]..261[1]..264[1]..263 returning {'init': ['NERDTreeGitStatusRefreshLis...: ['NERDTreeGitStatusRefreshListener']}[J

continuing in function <SNR>36_SetupListeners[3]..261[1]..264[J

line 2:     return get(listenersMap, a:name, [])[J

function <SNR>36_SetupListeners[3]..261[1]..264 returning [][J

continuing in function <SNR>36_SetupListeners[3]..261[J

line 2:     if listeners == [][J

line 3:         let listenersMap = s:Notifier.GetListenersMap()[J

calling function <SNR>36_SetupListeners[3]..261[3]..263[J()

line 1:     if !exists("s:refreshListenersMap")[J

line 2:         let s:refreshListenersMap = {}[J

line 3:     endif[J

line 4:     return s:refreshListenersMap[J

function <SNR>36_SetupListeners[3]..261[3]..263 returning {'init': ['NERDTreeGitStatusRefreshLis...: ['NERDTreeGitStatusRefreshListener']}[J

continuing in function <SNR>36_SetupListeners[3]..261[J

line 4:         let listenersMap[a:event] = listeners[J

line 5:     endif[J

line 6:     call add(listeners, a:funcname)[J

function <SNR>36_SetupListeners[3]..261 returning #0[J

continuing in function <SNR>36_SetupListeners[J

function <SNR>36_SetupListeners returning #0[J

continuing in /home/patrick/.vim/bundle/nerdtree-git-plugin/nerdtree_plugin/git_status.vim[J

line 359: endif[J

finished sourcing /home/patrick/.vim/bundle/nerdtree-git-plugin/nerdtree_plugin/git_status.vim[J
continuing in function nerdtree#postSourceActions[J
Searching for "/home/patrick/.vim/bundle/nerdcommenter/nerdtree_plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-fugitive/nerdtree_plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/bundle/ale/nerdtree_plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/bundle/tabular/nerdtree_plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-table-mode/nerdtree_plugin/**/*.vim"[J
Searching for "/var/lib/vim/addons/nerdtree_plugin/**/*.vim"[J
Searching for "/usr/share/vim/vimfiles/nerdtree_plugin/**/*.vim"[J
Searching for "/usr/share/vim/vim80/nerdtree_plugin/**/*.vim"[J
Searching for "/usr/share/vim/vim80/pack/dist/opt/matchit/nerdtree_plugin/**/*.vim"[J
Searching for "/usr/share/vim/vimfiles/after/nerdtree_plugin/**/*.vim"[J
Searching for "/var/lib/vim/addons/after/nerdtree_plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/after/nerdtree_plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/nerdtree_plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/after/nerdtree_plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/after/nerdtree_plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/after/nerdtree_plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/after/nerdtree_plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/after/nerdtree_plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdcommenter/after/nerdtree_plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-fugitive/after/nerdtree_plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/bundle/ale/after/nerdtree_plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/bundle/tabular/after/nerdtree_plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-table-mode/after/nerdtree_plugin/**/*.vim"[J
function nerdtree#postSourceActions returning #0[J

continuing in /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 219: [J

line 220: "reset &cpo back to users setting[J

line 221: let &cpo = s:old_cpo[J

line 222: [J

line 223: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /home/patrick/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdcommenter/plugin/**/*.vim"[J
chdir(/home/patrick/.vim/bundle/nerdcommenter/plugin)[J
fchdir() to previous dir[J
sourcing "/home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim"[J
line 1: " ============================================================================[J

line 2: " File:        NERD_commenter.vim[J

line 3: " Description: vim global plugin that provides easy code commenting[J

line 4: " Author:      Martin Grenfell <martin.grenfell at gmail dot com>[J

line 5: " Maintainer:  Caleb Maclennan <caleb@alerque.com>[J

line 6: " Version:     2.4.0[J

line 7: " Last Change: Tue May 24 14:03:29 EEST 2016[J

line 8: " License:     This program is free software. It comes without any warranty,[J

line 9: "              to the extent permitted by applicable law. You can redistribute[J

line 10: "              it and/or modify it under the terms of the Do What The Fuck You[J

line 11: "              Want To Public License, Version 2, as published by Sam Hocevar.[J

line 12: "              See http://sam.zoy.org/wtfpl/COPYING for more details.[J

line 13: "[J

line 14: " ============================================================================[J

line 15: [J

line 16: " Section: script init stuff {{{1[J

line 17: if exists("loaded_nerd_comments")[J

line 18:     finish[J

line 19: endif[J

line 20: if v:version < 700[J

line 21:     echoerr "NERDCommenter: this plugin requires vim >= 7. DOWNLOAD IT! You'll thank me later!"[J

line 22:     finish[J

line 23: endif[J

line 24: let loaded_nerd_comments = 1[J

line 25: [J

line 26: " Function: s:InitVariable() function {{{2[J

line 27: " This function is used to initialise a given variable to a given value. The[J

line 28: " variable is only initialised if it does not exist prior[J

line 29: "[J

line 30: " Args:[J

line 31: "   -var: the name of the var to be initialised[J

line 32: "   -value: the value to initialise var to[J

line 33: "[J

line 34: " Returns:[J

line 35: "   1 if the var is set, 0 otherwise[J

line 36: function s:InitVariable(var, value)[J

line 43: [J

line 44: " Section: space string init{{{2[J

line 45: " When putting spaces after the left delimiter and before the right we use[J

line 46: " s:spaceStr for the space char. This way we can make it add anything after[J

line 47: " the left and before the right by modifying this variable[J

line 48: let s:spaceStr = ' '[J

line 49: let s:lenSpaceStr = strlen(s:spaceStr)[J

line 50: [J

line 51: " Section: variable initialization {{{2[J

line 52: call s:InitVariable("g:NERDAllowAnyVisualDelims", 1)[J

calling function <SNR>37_InitVariable[J('g:NERDAllowAnyVisualDelims', 1)

line 1:     if !exists(a:var)[J

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDAllowAnyVisualDelims = '1'[J

line 3:         return 1[J

function <SNR>37_InitVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 53: call s:InitVariable("g:NERDBlockComIgnoreEmpty", 0)[J

calling function <SNR>37_InitVariable[J('g:NERDBlockComIgnoreEmpty', 0)

line 1:     if !exists(a:var)[J

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDBlockComIgnoreEmpty = '0'[J

line 3:         return 1[J

function <SNR>37_InitVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 54: call s:InitVariable("g:NERDCommentWholeLinesInVMode", 0)[J

calling function <SNR>37_InitVariable[J('g:NERDCommentWholeLinesInVMode', 0)

line 1:     if !exists(a:var)[J

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDCommentWholeLinesInVMode = '0'[J

line 3:         return 1[J

function <SNR>37_InitVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 55: call s:InitVariable("g:NERDCommentEmptyLines", 0)[J

calling function <SNR>37_InitVariable[J('g:NERDCommentEmptyLines', 0)

line 1:     if !exists(a:var)[J

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDCommentEmptyLines = '0'[J

line 3:         return 1[J

function <SNR>37_InitVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 56: call s:InitVariable("g:NERDCompactSexyComs", 0)[J

calling function <SNR>37_InitVariable[J('g:NERDCompactSexyComs', 0)

line 1:     if !exists(a:var)[J

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDCompactSexyComs = '0'[J

line 3:         return 1[J

function <SNR>37_InitVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 57: call s:InitVariable("g:NERDCreateDefaultMappings", 1)[J

calling function <SNR>37_InitVariable[J('g:NERDCreateDefaultMappings', 1)

line 1:     if !exists(a:var)[J

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDCreateDefaultMappings = '1'[J

line 3:         return 1[J

function <SNR>37_InitVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 58: call s:InitVariable("g:NERDDefaultNesting", 1)[J

calling function <SNR>37_InitVariable[J('g:NERDDefaultNesting', 1)

line 1:     if !exists(a:var)[J

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDDefaultNesting = '1'[J

line 3:         return 1[J

function <SNR>37_InitVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 59: call s:InitVariable("g:NERDMenuMode", 3)[J

calling function <SNR>37_InitVariable[J('g:NERDMenuMode', 3)

line 1:     if !exists(a:var)[J

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDMenuMode = '3'[J

line 3:         return 1[J

function <SNR>37_InitVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 60: call s:InitVariable("g:NERDLPlace", "[>")[J

calling function <SNR>37_InitVariable[J('g:NERDLPlace', '[>')

line 1:     if !exists(a:var)[J

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDLPlace = '[>'[J

line 3:         return 1[J

function <SNR>37_InitVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 61: call s:InitVariable("g:NERDUsePlaceHolders", 1)[J

calling function <SNR>37_InitVariable[J('g:NERDUsePlaceHolders', 1)

line 1:     if !exists(a:var)[J

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDUsePlaceHolders = '1'[J

line 3:         return 1[J

function <SNR>37_InitVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 62: call s:InitVariable("g:NERDRemoveAltComs", 1)[J

calling function <SNR>37_InitVariable[J('g:NERDRemoveAltComs', 1)

line 1:     if !exists(a:var)[J

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDRemoveAltComs = '1'[J

line 3:         return 1[J

function <SNR>37_InitVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 63: call s:InitVariable("g:NERDRemoveExtraSpaces", 0)[J

calling function <SNR>37_InitVariable[J('g:NERDRemoveExtraSpaces', 0)

line 1:     if !exists(a:var)[J

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDRemoveExtraSpaces = '0'[J

line 3:         return 1[J

function <SNR>37_InitVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 64: call s:InitVariable("g:NERDRPlace", "<]")[J

calling function <SNR>37_InitVariable[J('g:NERDRPlace', '<]')

line 1:     if !exists(a:var)[J

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDRPlace = '<]'[J

line 3:         return 1[J

function <SNR>37_InitVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 65: call s:InitVariable("g:NERDSpaceDelims", 0)[J

calling function <SNR>37_InitVariable[J('g:NERDSpaceDelims', 0)

line 1:     if !exists(a:var)[J

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDSpaceDelims = '0'[J

line 3:         return 1[J

function <SNR>37_InitVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 66: call s:InitVariable("g:NERDDefaultAlign", "none")[J

calling function <SNR>37_InitVariable[J('g:NERDDefaultAlign', 'none')

line 1:     if !exists(a:var)[J

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDDefaultAlign = 'none'[J

line 3:         return 1[J

function <SNR>37_InitVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 67: call s:InitVariable("g:NERDTrimTrailingWhitespace", 0)[J

calling function <SNR>37_InitVariable[J('g:NERDTrimTrailingWhitespace', 0)

line 1:     if !exists(a:var)[J

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTrimTrailingWhitespace = '0'[J

line 3:         return 1[J

function <SNR>37_InitVariable returning #1[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 68: [J

line 69: let s:NERDFileNameEscape="[]#*$%'\" ?`!&();<>\\"[J

line 70: [J

line 468: let s:delimiterMap = { 'aap': { 'left': '#' }, 'abc': { 'left': '%' }, 'acedb': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' }, 'actionscript': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' }, 'ada': { 'left': '--', 'leftAlt': '--  ' }, 'ahdl': { 'left': '--' }, 'ahk': { 'left': ';', 'leftAlt': '/*', 'rightAlt': '*/' }, 'amiga': { 'left': ';' }, 'aml': { 'left': '/*' }, 'ampl': { 'left': '#' }, 'ansible': { 'left': '#' }, 'apache': { 'left': '#' }, 'apachestyle': { 'left': '#' }, 'applescript': { 'left': '--', 'leftAlt': '(*', 'rightAlt': '*)' }, 'armasm': { 'left': ';' }, 'asciidoc': { 'left': '//' }, 'asm': { 'left': ';', 'leftAlt': '#' }, 'asm68k': { 'left': ';' }, 'asn': { 'left': '--' }, 'asp': { 'left': '%', 'leftAlt': '%*', 'rightAlt': '*%' }, 'aspvbs': { 'left': '''', 'leftAlt': '<!--', 'rightAlt': '-->' }, 'asterisk': { 'left': ';' }, 'asy': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' }, 'atlas': { 'left': 'C', 'right': '$' }, 'augeas': { 'left': '(*', 'right': '*)' }, 'autoh[J

line 469: [J

line 470: let g:NERDDelimiterMap = s:delimiterMap[J

line 471: [J

line 472: if exists("g:NERDCustomDelimiters")[J

line 473:     call extend(s:delimiterMap, g:NERDCustomDelimiters)[J

line 474: endif[J

line 475: [J

line 476: " Section: Comment mapping functions, autocommands and commands {{{1[J

line 477: " ============================================================================[J

line 478: " Section: Comment enabler autocommands {{{2[J

line 479: " ============================================================================[J

line 480: [J

line 481: augroup NERDCommenter[J

line 482: [J

line 483:     "if the user enters a buffer or reads a buffer then we gotta set up[J

line 484:     "the comment delimiters for that new filetype[J

line 485:     autocmd BufEnter,BufRead * :call s:SetUpForNewFiletype(&filetype, 0)[J

line 486: [J

line 487:     "if the filetype of a buffer changes, force the script to reset the[J

line 488:     "delimiters for the buffer[J

line 489:     autocmd Filetype * :call s:SetUpForNewFiletype(&filetype, 1)[J

line 490: augroup END[J

line 491: [J

line 492: [J

line 493: " Function: s:SetUpForNewFiletype(filetype) function {{{2[J

line 494: " This function is responsible for setting up buffer scoped variables for the[J

line 495: " given filetype.[J

line 496: "[J

line 497: " Args:[J

line 498: "   -filetype: the filetype to set delimiters for[J

line 499: "   -forceReset: 1 if the delimiters should be reset if they have already be[J

line 500: "    set for this buffer.[J

line 501: "[J

line 502: function s:SetUpForNewFiletype(filetype, forceReset)[J

line 542: [J

line 543: function s:CreateDelimMapFromCms()[J

line 561: [J

line 562: " Function: s:SwitchToAlternativeDelimiters(printMsgs) function {{{2[J

line 563: " This function is used to swap the delimiters that are being used to the[J

line 564: " alternative delimiters for that filetype. For example, if a c++ file is[J

line 565: " being edited and // comments are being used, after this function is called[J

line 566: " /**/ comments will be used.[J

line 567: "[J

line 568: " Args:[J

line 569: "   -printMsgs: if this is 1 then a message is echoed to the user telling them[J

line 570: "    if this function changed the delimiters or not[J

line 571: function s:SwitchToAlternativeDelimiters(printMsgs)[J

line 611: [J

line 612: " Section: Comment delimiter add/removal functions {{{1[J

line 613: " ============================================================================[J

line 614: " Function: s:AppendCommentToLine(){{{2[J

line 615: " This function appends comment delimiters at the EOL and places the cursor in[J

line 616: " position to start typing the comment[J

line 617: function s:AppendCommentToLine()[J

line 641: [J

line 642: " Function: s:CommentBlock(top, bottom, lSide, rSide, forceNested ) {{{2[J

line 643: " This function is used to comment out a region of code. This region is[J

line 644: " specified as a bounding box by arguments to the function.[J

line 645: "[J

line 646: " Args:[J

line 647: "   -top: the line number for the top line of code in the region[J

line 648: "   -bottom: the line number for the bottom line of code in the region[J

line 649: "   -lSide: the column number for the left most column in the region[J

line 650: "   -rSide: the column number for the right most column in the region[J

line 651: "   -forceNested: a flag indicating whether comments should be nested[J

line 652: function s:CommentBlock(top, bottom, lSide, rSide, forceNested )[J

line 775: [J

line 776: " Function: s:CommentLines(forceNested, alignLeft, alignRight, firstLine, lastLine) {{{2[J

line 777: " This function comments a range of lines.[J

line 778: "[J

line 779: " Args:[J

line 780: "   -forceNested: a flag indicating whether the called is requesting the comment[J

line 781: "    to be nested if need be[J

line 782: "   -align: should be "left", "start", "both" or "none"[J

line 783: "   -firstLine/lastLine: the top and bottom lines to comment[J

line 784: function s:CommentLines(forceNested, align, firstLine, lastLine)[J

line 844: [J

line 845: " Function: s:CommentLinesMinimal(firstLine, lastLine) {{{2[J

line 846: " This function comments a range of lines in a minimal style. I[J

line 847: "[J

line 848: " Args:[J

line 849: "   -firstLine/lastLine: the top and bottom lines to comment[J

line 850: function s:CommentLinesMinimal(firstLine, lastLine)[J

line 905: [J

line 906: " Function: s:CommentLinesSexy(topline, bottomline) function {{{2[J

line 907: " This function is used to comment lines in the 'Sexy' style. E.g., in c:[J

line 908: " /*[J

line 909: "  * This is a sexy comment[J

line 910: "  */[J

line 911: " Args:[J

line 912: "   -topline: the line number of the top line in the sexy comment[J

line 913: "   -bottomline: the line number of the bottom line in the sexy comment[J

line 914: function s:CommentLinesSexy(topline, bottomline)[J

line 1032: [J

line 1033: " Function: s:CommentLinesToggle(forceNested, firstLine, lastLine) {{{2[J

line 1034: " Applies "toggle" commenting to the given range of lines[J

line 1035: "[J

line 1036: " Args:[J

line 1037: "   -forceNested: a flag indicating whether the called is requesting the comment[J

line 1038: "    to be nested if need be[J

line 1039: "   -firstLine/lastLine: the top and bottom lines to comment[J

line 1040: function s:CommentLinesToggle(forceNested, firstLine, lastLine)[J

line 1089: [J

line 1090: " Function: s:CommentRegion(topline, topCol, bottomLine, bottomCol) function {{{2[J

line 1091: " This function comments chunks of text selected in visual mode.[J

line 1092: " It will comment exactly the text that they have selected.[J

line 1093: " Args:[J

line 1094: "   -topLine: the line number of the top line in the sexy comment[J

line 1095: "   -topCol: top left column for this comment[J

line 1096: "   -bottomline: the line number of the bottom line in the sexy comment[J

line 1097: "   -bottomCol: the bottom right column for this comment[J

line 1098: "   -forceNested: whether the caller wants comments to be nested if the[J

line 1099: "    line(s) are already commented[J

line 1100: function s:CommentRegion(topLine, topCol, bottomLine, bottomCol, forceNested)[J

line 1141: [J

line 1142: " Function: s:InvertComment(firstLine, lastLine) function {{{2[J

line 1143: " Inverts the comments on the lines between and including the given line[J

line 1144: " numbers i.e all commented lines are uncommented and vice versa[J

line 1145: " Args:[J

line 1146: "   -firstLine: the top of the range of lines to be inverted[J

line 1147: "   -lastLine: the bottom of the range of lines to be inverted[J

line 1148: function s:InvertComment(firstLine, lastLine)[J

line 1179: [J

line 1180: function! NERDCommentIsLineCommented(lineNo)[J

line 1184: [J

line 1185: " Function: NERDComment(mode, type) function {{{2[J

line 1186: " This function is a Wrapper for the main commenting functions[J

line 1187: "[J

line 1188: " Args:[J

line 1189: "   -mode: a character indicating the mode in which the comment is requested:[J

line 1190: "   'n' for Normal mode, 'x' for Visual mode[J

line 1191: "   -type: the type of commenting requested. Can be 'Sexy', 'Invert',[J

line 1192: "    'Minimal', 'Toggle', 'AlignLeft', 'AlignBoth', 'Comment',[J

line 1193: "    'Nested', 'ToEOL', 'Append', 'Insert', 'Uncomment', 'Yank'[J

line 1194: function! NERDComment(mode, type) range[J

line 1309: [J

line 1310: " Function: s:PlaceDelimitersAndInsBetween() function {{{2[J

line 1311: " This is function is called to place comment delimiters down and place the[J

line 1312: " cursor between them[J

line 1313: function s:PlaceDelimitersAndInsBetween()[J

line 1360: [J

line 1361: " Function: s:RemoveDelimiters(left, right, line) {{{2[J

line 1362: " this function is called to remove the first left comment delimiter and the[J

line 1363: " last right delimiter of the given line.[J

line 1364: "[J

line 1365: " The arguments left and right must be strings. If there is no right delimiter (as[J

line 1366: " is the case for e.g vim file comments) them the argument right should be ""[J

line 1367: "[J

line 1368: " Args:[J

line 1369: "   -left: the left comment delimiter[J

line 1370: "   -right: the right comment delimiter[J

line 1371: "   -line: the line to remove the delimiters from[J

line 1372: function s:RemoveDelimiters(left, right, line)[J

line 1409: [J

line 1410: " Function: s:SetupStateBeforeLineComment(topLine, bottomLine) {{{2[J

line 1411: " Changes ignorecase and foldmethod options before commenting lines and saves[J

line 1412: " their original values in a dict, which is returned as a result[J

line 1413: "[J

line 1414: " Args:[J

line 1415: " topLine: the top line of the visual selection to uncomment[J

line 1416: " bottomLine: the bottom line of the visual selection to uncomment[J

line 1417: "[J

line 1418: " Return: a dict with the state prior to configuration changes[J

line 1419: "[J

line 1420: function s:SetupStateBeforeLineComment(topLine, bottomLine)[J

line 1438: [J

line 1439: " Function: s:RecoverStateAfterLineComment(state) {{{2[J

line 1440: " Receives the state returned by s:SetupStateBeforeLineComment and restores[J

line 1441: " the state accordingly[J

line 1442: "[J

line 1443: " Args:[J

line 1444: " state: the top line of the visual selection to uncomment[J

line 1445: " bottomLine: the bottom line of the visual selection to uncomment[J

line 1446: function s:RecoverStateAfterLineComment(state)[J

line 1454: [J

line 1455: " Function: s:TrimTrailingWhitespace(line) {{{2[J

line 1456: " This function removes all the trailing whitespace[J

line 1457: " Args:[J

line 1458: "   -line: the target line[J

line 1459: function s:TrimTrailingWhitespace(line)[J

line 1463: [J

line 1464: " Function: s:UncommentLines(topLine, bottomLine) {{{2[J

line 1465: " This function uncomments the given lines[J

line 1466: "[J

line 1467: " Args:[J

line 1468: " topLine: the top line of the visual selection to uncomment[J

line 1469: " bottomLine: the bottom line of the visual selection to uncomment[J

line 1470: function s:UncommentLines(topLine, bottomLine)[J

line 1509: [J

line 1510: " Function: s:UncommentLinesSexy(topline, bottomline) {{{2[J

line 1511: " This function removes all the comment characters associated with the sexy[J

line 1512: " comment spanning the given lines[J

line 1513: " Args:[J

line 1514: "   -topline/bottomline: the top/bottom lines of the sexy comment[J

line 1515: function s:UncommentLinesSexy(topline, bottomline)[J

line 1640: [J

line 1641: " Function: s:UncommentLineNormal(line) {{{2[J

line 1642: " uncomments the given line and returns the result[J

line 1643: " Args:[J

line 1644: "   -line: the line to uncomment[J

line 1645: function s:UncommentLineNormal(line)[J

line 1717: [J

line 1718: " Function: s:UncommentLinesNormal(topline, bottomline) {{{2[J

line 1719: " This function is called to uncomment lines that aren't a sexy comment[J

line 1720: " Args:[J

line 1721: "   -topline/bottomline: the top/bottom line numbers of the comment[J

line 1722: function s:UncommentLinesNormal(topline, bottomline)[J

line 1730: [J

line 1731: [J

line 1732: " Section: Other helper functions {{{1[J

line 1733: " ============================================================================[J

line 1734: [J

line 1735: " Function: s:AddLeftDelim(delim, theLine) {{{2[J

line 1736: " Args:[J

line 1737: function s:AddLeftDelim(delim, theLine)[J

line 1740: [J

line 1741: " Function: s:AddLeftDelimAligned(delim, theLine) {{{2[J

line 1742: " Args:[J

line 1743: function s:AddLeftDelimAligned(delim, theLine, alignIndx)[J

line 1754: [J

line 1755: " Function: s:AddRightDelim(delim, theLine) {{{2[J

line 1756: " Args:[J

line 1757: function s:AddRightDelim(delim, theLine)[J

line 1764: [J

line 1765: " Function: s:AddRightDelimAligned(delim, theLine, alignIndx) {{{2[J

line 1766: " Args:[J

line 1767: function s:AddRightDelimAligned(delim, theLine, alignIndx)[J

line 1782: [J

line 1783: " Function: s:AltMultipart() {{{2[J

line 1784: " returns 1 if the alternative delimiters are multipart[J

line 1785: function s:AltMultipart()[J

line 1788: [J

line 1789: " Function: s:AltNested() {{{2[J

line 1790: " returns 1 if the alternate multipart (if any) delimiters allow nesting[J

line 1791: function s:AltNested()[J

line 1794: [J

line 1795: " Function: s:CanCommentLine(forceNested, line) {{{2[J

line 1796: "This function is used to determine whether the given line can be commented.[J

line 1797: "It returns 1 if it can be and 0 otherwise[J

line 1798: "[J

line 1799: " Args:[J

line 1800: "   -forceNested: a flag indicating whether the caller wants comments to be nested[J

line 1801: "    if the current line is already commented[J

line 1802: "   -lineNum: the line number of the line to check for commentability[J

line 1803: function s:CanCommentLine(forceNested, lineNum)[J

line 1831: [J

line 1832: " Function: s:CanPlaceCursor(line, col) {{{2[J

line 1833: " returns 1 if the cursor can be placed exactly in the given position[J

line 1834: function s:CanPlaceCursor(line, col)[J

line 1842: [J

line 1843: " Function: s:CanSexyCommentLines(topline, bottomline) {{{2[J

line 1844: " Return: 1 if the given lines can be commented sexually, 0 otherwise[J

line 1845: function s:CanSexyCommentLines(topline, bottomline)[J

line 1861: " Function: s:CanToggleCommentLine(forceNested, line) {{{2[J

line 1862: "This function is used to determine whether the given line can be toggle commented.[J

line 1863: "It returns 1 if it can be and 0 otherwise[J

line 1864: "[J

line 1865: " Args:[J

line 1866: "   -lineNum: the line number of the line to check for commentability[J

line 1867: function s:CanToggleCommentLine(forceNested, lineNum)[J

line 1886: [J

line 1887: " Function: s:ConvertLeadingSpacesToTabs(line) {{{2[J

line 1888: " This function takes a line and converts all leading tabs on that line into[J

line 1889: " spaces[J

line 1890: "[J

line 1891: " Args:[J

line 1892: "   -line: the line whose leading tabs will be converted[J

line 1893: function s:ConvertLeadingSpacesToTabs(line)[J

line 1901: [J

line 1902: [J

line 1903: " Function: s:ConvertLeadingTabsToSpaces(line) {{{2[J

line 1904: " This function takes a line and converts all leading spaces on that line into[J

line 1905: " tabs[J

line 1906: "[J

line 1907: " Args:[J

line 1908: "   -line: the line whose leading spaces will be converted[J

line 1909: function s:ConvertLeadingTabsToSpaces(line)[J

line 1917: [J

line 1918: " Function: s:ConvertLeadingWhiteSpace(line) {{{2[J

line 1919: " Converts the leading white space to tabs/spaces depending on &ts[J

line 1920: "[J

line 1921: " Args:[J

line 1922: "   -line: the line to convert[J

line 1923: function s:ConvertLeadingWhiteSpace(line)[J

line 1935: [J

line 1936: [J

line 1937: " Function: s:CountNonESCedOccurances(str, searchstr, escChar) {{{2[J

line 1938: " This function counts the number of substrings contained in another string.[J

line 1939: " These substrings are only counted if they are not escaped with escChar[J

line 1940: " Args:[J

line 1941: "   -str: the string to look for searchstr in[J

line 1942: "   -searchstr: the substring to search for in str[J

line 1943: "   -escChar: the escape character which, when preceding an instance of[J

line 1944: "    searchstr, will cause it not to be counted[J

line 1945: function s:CountNonESCedOccurances(str, searchstr, escChar)[J

line 1964: " Function: s:DoesBlockHaveDelim(delim, top, bottom) {{{2[J

line 1965: " Returns 1 if the given block of lines has a delimiter (a:delim) in it[J

line 1966: " Args:[J

line 1967: "   -delim: the comment delimiter to check the block for[J

line 1968: "   -top: the top line number of the block[J

line 1969: "   -bottom: the bottom line number of the block[J

line 1970: function s:DoesBlockHaveDelim(delim, top, bottom)[J

line 1981: [J

line 1982: " Function: s:DoesBlockHaveMultipartDelim(top, bottom) {{{2[J

line 1983: " Returns 1 if the given block has a >= 1 multipart delimiter in it[J

line 1984: " Args:[J

line 1985: "   -top: the top line number of the block[J

line 1986: "   -bottom: the bottom line number of the block[J

line 1987: function s:DoesBlockHaveMultipartDelim(top, bottom)[J

line 1997: [J

line 1998: [J

line 1999: " Function: s:Esc(str) {{{2[J

line 2000: " Escapes all the tricky chars in the given string[J

line 2001: function s:Esc(str)[J

line 2005: [J

line 2006: " Function: s:FindDelimiterIndex(delimiter, line) {{{2[J

line 2007: " This function is used to get the string index of the input comment delimiter[J

line 2008: " on the input line. If no valid comment delimiter is found in the line then[J

line 2009: " -1 is returned[J

line 2010: " Args:[J

line 2011: "   -delimiter: the delimiter we are looking to find the index of[J

line 2012: "   -line: the line we are looking for delimiter on[J

line 2013: function s:FindDelimiterIndex(delimiter, line)[J

line 2058: [J

line 2059: " Function: s:FindBoundingLinesOfSexyCom(lineNum) {{{2[J

line 2060: " This function takes in a line number and tests whether this line number is[J

line 2061: " the top/bottom/middle line of a sexy comment. If it is then the top/bottom[J

line 2062: " lines of the sexy comment are returned[J

line 2063: " Args:[J

line 2064: "   -lineNum: the line number that is to be tested whether it is the[J

line 2065: "    top/bottom/middle line of a sexy com[J

line 2066: " Returns:[J

line 2067: "   A string that has the top/bottom lines of the sexy comment encoded in it.[J

line 2068: "   The format is 'topline,bottomline'. If a:lineNum turns out not to be the[J

line 2069: "   top/bottom/middle of a sexy comment then -1 is returned[J

line 2070: function s:FindBoundingLinesOfSexyCom(lineNum)[J

line 2132: [J

line 2133: [J

line 2134: " Function: s:GetSexyComMarker() {{{2[J

line 2135: " Returns the sexy comment marker for the current filetype.[J

line 2136: "[J

line 2137: " C style sexy comments are assumed if possible. If not then the sexy comment[J

line 2138: " marker is the last char of the delimiter pair that has both left and right[J

line 2139: " delimiters and has the longest left delimiter[J

line 2140: "[J

line 2141: " Args:[J

line 2142: "   -space: specifies whether the marker is to have a space string after it[J

line 2143: "    (the space string will only be added if NERDSpaceDelims is set)[J

line 2144: "   -esc: specifies whether the tricky chars in the marker are to be ESCed[J

line 2145: function s:GetSexyComMarker(space, esc)[J

line 2185: [J

line 2186: " Function: s:SexyNested() {{{2[J

line 2187: " Returns 1 if the sexy delimeters allow nesting[J

line 2188: " TODO this is ugly copy&paste from the GetSexyComLeft/Right functions,[J

line 2189: " these could all be cleaned up[J

line 2190: function s:SexyNested()[J

line 2208: [J

line 2209: " Function: s:GetSexyComLeft(space, esc) {{{2[J

line 2210: " Returns the left delimiter for sexy comments for this filetype or -1 if[J

line 2211: " there is none. C style sexy comments are used if possible[J

line 2212: " Args:[J

line 2213: "   -space: specifies if the delimiter has a space string on the end[J

line 2214: "   (the space string will only be added if NERDSpaceDelims is set)[J

line 2215: "   -esc: specifies whether the tricky chars in the string are ESCed[J

line 2216: function s:GetSexyComLeft(space, esc)[J

line 2245: [J

line 2246: " Function: s:GetSexyComRight(space, esc) {{{2[J

line 2247: " Returns the right delimiter for sexy comments for this filetype or -1 if[J

line 2248: " there is none. C style sexy comments are used if possible.[J

line 2249: " Args:[J

line 2250: "   -space: specifies if the delimiter has a space string on the start[J

line 2251: "   (the space string will only be added if NERDSpaceDelims[J

line 2252: "   is specified for the current filetype)[J

line 2253: "   -esc: specifies whether the tricky chars in the string are ESCed[J

line 2254: function s:GetSexyComRight(space, esc)[J

line 2283: [J

line 2284: " Function: s:HasMultipartDelims() {{{2[J

line 2285: " Returns 1 if the current filetype has at least one set of multipart delimiters[J

line 2286: function s:HasMultipartDelims()[J

line 2289: [J

line 2290: " Function: s:HasLeadingTabs(...) {{{2[J

line 2291: " Returns 1 if any of the given strings have leading tabs[J

line 2292: function s:HasLeadingTabs(...)[J

line 2300: " Function: s:HasCStyleComments() {{{2[J

line 2301: " Returns 1 if the current filetype has c style comment delimiters[J

line 2302: function s:HasCStyleComments()[J

line 2305: [J

line 2306: " Function: s:IsCommentedNormOrSexy(lineNum) {{{2[J

line 2307: "This function is used to determine whether the given line is commented with[J

line 2308: "either set of delimiters or if it is part of a sexy comment[J

line 2309: "[J

line 2310: " Args:[J

line 2311: "   -lineNum: the line number of the line to check[J

line 2312: function s:IsCommentedNormOrSexy(lineNum)[J

line 2326: [J

line 2327: " Function: s:IsCommented(left, right, line) {{{2[J

line 2328: "This function is used to determine whether the given line is commented with[J

line 2329: "the given delimiters[J

line 2330: "[J

line 2331: " Args:[J

line 2332: "   -line: the line that to check if commented[J

line 2333: "   -left/right: the left and right delimiters to check for[J

line 2334: function s:IsCommented(left, right, line)[J

line 2341: [J

line 2342: " Function: s:IsCommentedFromStartOfLine(left, line) {{{2[J

line 2343: "This function is used to determine whether the given line is commented with[J

line 2344: "the given delimiters at the start of the line i.e the left delimiter is the[J

line 2345: "first thing on the line (apart from spaces\tabs)[J

line 2346: "[J

line 2347: " Args:[J

line 2348: "   -line: the line that to check if commented[J

line 2349: "   -left: the left delimiter to check for[J

line 2350: function s:IsCommentedFromStartOfLine(left, line)[J

line 2356: [J

line 2357: " Function: s:IsCommentedOutermost(left, right, leftAlt, rightAlt, line) {{{2[J

line 2358: " Finds the type of the outermost delimiters on the line[J

line 2359: "[J

line 2360: " Args:[J

line 2361: "   -line: the line that to check if the outermost comments on it are[J

line 2362: "    left/right[J

line 2363: "   -left/right: the left and right delimiters to check for[J

line 2364: "   -leftAlt/rightAlt: the left and right alternative delimiters to check for[J

line 2365: "[J

line 2366: " Returns:[J

line 2367: "   0 if the line is not commented with either set of delimiters[J

line 2368: "   1 if the line is commented with the left/right delimiter set[J

line 2369: "   2 if the line is commented with the leftAlt/rightAlt delim set[J

line 2370: function s:IsCommentedOutermost(left, right, leftAlt, rightAlt, line)[J

line 2398: [J

line 2399: [J

line 2400: " Function: s:IsDelimValid(delimiter, delIndx, line) {{{2[J

line 2401: " This function is responsible for determining whether a given instance of a[J

line 2402: " comment delimiter is a real delimiter or not. For example, in java the[J

line 2403: " // string is a comment delimiter but in the line:[J

line 2404: "               System.out.println("//");[J

line 2405: " it does not count as a comment delimiter. This function is responsible for[J

line 2406: " distinguishing between such cases. It does so by applying a set of[J

line 2407: " heuristics that are not fool proof but should work most of the time.[J

line 2408: "[J

line 2409: " Args:[J

line 2410: "   -delimiter: the delimiter we are validating[J

line 2411: "   -delIndx: the position of delimiter in line[J

line 2412: "   -line: the line that delimiter occurs in[J

line 2413: "[J

line 2414: " Returns:[J

line 2415: " 0 if the given delimiter is not a real delimiter (as far as we can tell) ,[J

line 2416: " 1 otherwise[J

line 2417: function s:IsDelimValid(delimiter, delIndx, line)[J

line 2476: [J

line 2477: " Function: s:IsNumEven(num) {{{2[J

line 2478: " A small function the returns 1 if the input number is even and 0 otherwise[J

line 2479: " Args:[J

line 2480: "   -num: the number to check[J

line 2481: function s:IsNumEven(num)[J

line 2484: [J

line 2485: " Function: s:IsEscaped(str, indx, escChar) {{{2[J

line 2486: " This function takes a string, an index into that string and an esc char and[J

line 2487: " returns 1 if the char at the index is escaped (i.e if it is preceded by an[J

line 2488: " odd number of esc chars)[J

line 2489: " Args:[J

line 2490: "   -str: the string to check[J

line 2491: "   -indx: the index into str that we want to check[J

line 2492: "   -escChar: the escape char the char at indx may be ESCed with[J

line 2493: function s:IsEscaped(str, indx, escChar)[J

line 2513: [J

line 2514: " Function: s:IsInSexyComment(line) {{{2[J

line 2515: " returns 1 if the given line number is part of a sexy comment[J

line 2516: function s:IsInSexyComment(line)[J

line 2519: [J

line 2520: " Function: s:IsSexyComment(topline, bottomline) {{{2[J

line 2521: " This function takes in 2 line numbers and returns 1 if the lines between and[J

line 2522: " including the given line numbers are a sexy comment. It returns 0 otherwise.[J

line 2523: " Args:[J

line 2524: "   -topline: the line that the possible sexy comment starts on[J

line 2525: "   -bottomline: the line that the possible sexy comment stops on[J

line 2526: function s:IsSexyComment(topline, bottomline)[J

line 2600: [J

line 2601: " Function: s:LastIndexOfDelim(delim, str) {{{2[J

line 2602: " This function takes a string and a delimiter and returns the last index of[J

line 2603: " that delimiter in string[J

line 2604: " Args:[J

line 2605: "   -delim: the delimiter to look for[J

line 2606: "   -str: the string to look for delimiter in[J

line 2607: function s:LastIndexOfDelim(delim, str)[J

line 2638: [J

line 2639: " Function: s:Left(...) {{{2[J

line 2640: " returns left delimiter data[J

line 2641: function s:Left(...)[J

line 2660: [J

line 2661: " Function: s:LeftMostIndx(countCommentedLines, countEmptyLines, topline, bottomline) {{{2[J

line 2662: " This function takes in 2 line numbers and returns the index of the left most[J

line 2663: " char (that is not a space or a tab) on all of these lines.[J

line 2664: " Args:[J

line 2665: "   -countCommentedLines: 1 if lines that are commented are to be checked as[J

line 2666: "    well. 0 otherwise[J

line 2667: "   -countEmptyLines: 1 if empty lines are to be counted in the search[J

line 2668: "   -topline: the top line to be checked[J

line 2669: "   -bottomline: the bottom line to be checked[J

line 2670: function s:LeftMostIndx(countCommentedLines, countEmptyLines, topline, bottomline)[J

line 2704: [J

line 2705: " Function: s:Multipart() {{{2[J

line 2706: " returns 1 if the current delimiters are multipart[J

line 2707: function s:Multipart()[J

line 2710: [J

line 2711: " Function: s:NerdEcho(msg, typeOfMsg) {{{2[J

line 2712: " Args:[J

line 2713: "   -msg: the message to echo[J

line 2714: "   -typeOfMsg: 0 = warning message[J

line 2715: "               1 = normal message[J

line 2716: function s:NerdEcho(msg, typeOfMsg)[J

line 2725: [J

line 2726: " Function: s:Nested() {{{2[J

line 2727: " returns 1 if the current multipart (if any) delimiters allow nesting[J

line 2728: function s:Nested()[J

line 2731: [J

line 2732: " Function: s:NumberOfLeadingTabs(s) {{{2[J

line 2733: " returns the number of leading tabs in the given string[J

line 2734: function s:NumberOfLeadingTabs(s)[J

line 2737: [J

line 2738: " Function: s:NumLinesInBuf() {{{2[J

line 2739: " Returns the number of lines in the current buffer[J

line 2740: function s:NumLinesInBuf()[J

line 2743: [J

line 2744: " Function: s:ReplaceDelims(toReplace1, toReplace2, replacor1, replacor2, str) {{{2[J

line 2745: " This function takes in a string, 2 delimiters in that string and 2 strings[J

line 2746: " to replace these delimiters with.[J

line 2747: "[J

line 2748: " Args:[J

line 2749: "   -toReplace1: the first delimiter to replace[J

line 2750: "   -toReplace2: the second delimiter to replace[J

line 2751: "   -replacor1: the string to replace toReplace1 with[J

line 2752: "   -replacor2: the string to replace toReplace2 with[J

line 2753: "   -str: the string that the delimiters to be replaced are in[J

line 2754: function s:ReplaceDelims(toReplace1, toReplace2, replacor1, replacor2, str)[J

line 2759: [J

line 2760: " Function: s:ReplaceLeftMostDelim(toReplace, replacor, str) {{{2[J

line 2761: " This function takes a string and a delimiter and replaces the left most[J

line 2762: " occurrence of this delimiter in the string with a given string[J

line 2763: "[J

line 2764: " Args:[J

line 2765: "   -toReplace: the delimiter in str that is to be replaced[J

line 2766: "   -replacor: the string to replace toReplace with[J

line 2767: "   -str: the string that contains toReplace[J

line 2768: function s:ReplaceLeftMostDelim(toReplace, replacor, str)[J

line 2783: [J

line 2784: " Function: s:ReplaceRightMostDelim(toReplace, replacor, str) {{{2[J

line 2785: " This function takes a string and a delimiter and replaces the right most[J

line 2786: " occurrence of this delimiter in the string with a given string[J

line 2787: "[J

line 2788: " Args:[J

line 2789: "   -toReplace: the delimiter in str that is to be replaced[J

line 2790: "   -replacor: the string to replace toReplace with[J

line 2791: "   -str: the string that contains toReplace[J

line 2792: "[J

line 2793: function s:ReplaceRightMostDelim(toReplace, replacor, str)[J

line 2808: [J

line 2809: "FUNCTION: s:RestoreScreenState() {{{2[J

line 2810: "[J

line 2811: "Sets the screen state back to what it was when s:SaveScreenState was last[J

line 2812: "called.[J

line 2813: "[J

line 2814: function s:RestoreScreenState()[J

line 2823: [J

line 2824: " Function: s:Right(...) {{{2[J

line 2825: " returns right delimiter data[J

line 2826: function s:Right(...)[J

line 2845: [J

line 2846: " Function: s:RightMostIndx(countCommentedLines, countEmptyLines, topline, bottomline) {{{2[J

line 2847: " This function takes in 2 line numbers and returns the index of the right most[J

line 2848: " char on all of these lines.[J

line 2849: " Args:[J

line 2850: "   -countCommentedLines: 1 if lines that are commented are to be checked as[J

line 2851: "    well. 0 otherwise[J

line 2852: "   -countEmptyLines: 1 if empty lines are to be counted in the search[J

line 2853: "   -topline: the top line to be checked[J

line 2854: "   -bottomline: the bottom line to be checked[J

line 2855: function s:RightMostIndx(countCommentedLines, countEmptyLines, topline, bottomline)[J

line 2884: [J

line 2885: "FUNCTION: s:SaveScreenState() {{{2[J

line 2886: "Saves the current cursor position in the current buffer and the window[J

line 2887: "scroll position[J

line 2888: function s:SaveScreenState()[J

line 2892: [J

line 2893: " Function: s:SwapOuterMultiPartDelimsForPlaceHolders(line) {{{2[J

line 2894: " This function takes a line and swaps the outer most multi-part delimiters for[J

line 2895: " place holders[J

line 2896: " Args:[J

line 2897: "   -line: the line to swap the delimiters in[J

line 2898: "[J

line 2899: function s:SwapOuterMultiPartDelimsForPlaceHolders(line)[J

line 2920: [J

line 2921: " Function: s:SwapOuterPlaceHoldersForMultiPartDelims(line) {{{2[J

line 2922: " This function takes a line and swaps the outermost place holders for[J

line 2923: " multi-part delimiters[J

line 2924: " Args:[J

line 2925: "   -line: the line to swap the delimiters in[J

line 2926: "[J

line 2927: function s:SwapOuterPlaceHoldersForMultiPartDelims(line)[J

line 2941: " Function: s:TabbedCol(line, col) {{{2[J

line 2942: " Gets the col number for given line and existing col number. The new col[J

line 2943: " number is the col number when all leading spaces are converted to tabs[J

line 2944: " Args:[J

line 2945: "   -line:the line to get the rel col for[J

line 2946: "   -col: the abs col[J

line 2947: function s:TabbedCol(line, col)[J

line 2952: "FUNCTION: s:TabSpace() {{{2[J

line 2953: "returns a string of spaces equal in length to &tabstop[J

line 2954: function s:TabSpace()[J

line 2963: [J

line 2964: " Function: s:UnEsc(str, escChar) {{{2[J

line 2965: " This function removes all the escape chars from a string[J

line 2966: " Args:[J

line 2967: "   -str: the string to remove esc chars from[J

line 2968: "   -escChar: the escape char to be removed[J

line 2969: function s:UnEsc(str, escChar)[J

line 2972: [J

line 2973: " Function: s:UntabbedCol(line, col) {{{2[J

line 2974: " Takes a line and a col and returns the absolute column of col taking into[J

line 2975: " account that a tab is worth 3 or 4 (or whatever) spaces.[J

line 2976: " Args:[J

line 2977: "   -line:the line to get the abs col for[J

line 2978: "   -col: the col that doesn't take into account tabs[J

line 2979: function s:UntabbedCol(line, col)[J

line 2984: " Section: Comment mapping and menu item setup {{{1[J

line 2985: " ===========================================================================[J

line 2986: [J

line 2987: " Create menu items for the specified modes.  If a:combo is not empty, then[J

line 2988: " also define mappings and show a:combo in the menu items.[J

line 2989: function! s:CreateMaps(modes, target, desc, combo)[J

line 3019: call s:CreateMaps('nx', 'Comment',    'Comment', 'cc')[J

calling function <SNR>37_CreateMaps[J('nx', 'Comment', 'Comment', 'cc')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: nnoremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: nmap <leader>cc <plug>NERDCommenterComment[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: nmenu <silent> &Plugin.&comment.Comment<Tab>\\cc <plug>NERDCommenterComment[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: xnoremap <silent> <plug>NERDCommenterComment :call NERDComment("x", "Comment")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: xmap <leader>cc <plug>NERDCommenterComment[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: xmenu <silent> &Plugin.&comment.Comment<Tab>\\cc <plug>NERDCommenterComment[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>37_CreateMaps returning #0[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3020: call s:CreateMaps('nx', 'Toggle',     'Toggle', 'c<space>')[J

calling function <SNR>37_CreateMaps[J('nx', 'Toggle', 'Toggle', 'c<space>')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: nnoremap <silent> <plug>NERDCommenterToggle :call NERDComment("n", "Toggle")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: nmap <leader>c<space> <plug>NERDCommenterToggle[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: nmenu <silent> &Plugin.&comment.Toggle<Tab>\\c<space> <plug>NERDCommenterToggle[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: xnoremap <silent> <plug>NERDCommenterToggle :call NERDComment("x", "Toggle")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: xmap <leader>c<space> <plug>NERDCommenterToggle[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: xmenu <silent> &Plugin.&comment.Toggle<Tab>\\c<space> <plug>NERDCommenterToggle[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>37_CreateMaps returning #0[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3021: call s:CreateMaps('nx', 'Minimal',    'Minimal', 'cm')[J

calling function <SNR>37_CreateMaps[J('nx', 'Minimal', 'Minimal', 'cm')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: nnoremap <silent> <plug>NERDCommenterMinimal :call NERDComment("n", "Minimal")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: nmap <leader>cm <plug>NERDCommenterMinimal[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: nmenu <silent> &Plugin.&comment.Minimal<Tab>\\cm <plug>NERDCommenterMinimal[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: xnoremap <silent> <plug>NERDCommenterMinimal :call NERDComment("x", "Minimal")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: xmap <leader>cm <plug>NERDCommenterMinimal[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: xmenu <silent> &Plugin.&comment.Minimal<Tab>\\cm <plug>NERDCommenterMinimal[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>37_CreateMaps returning #0[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3022: call s:CreateMaps('nx', 'Nested',     'Nested', 'cn')[J

calling function <SNR>37_CreateMaps[J('nx', 'Nested', 'Nested', 'cn')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: nnoremap <silent> <plug>NERDCommenterNested :call NERDComment("n", "Nested")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: nmap <leader>cn <plug>NERDCommenterNested[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: nmenu <silent> &Plugin.&comment.Nested<Tab>\\cn <plug>NERDCommenterNested[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: xnoremap <silent> <plug>NERDCommenterNested :call NERDComment("x", "Nested")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: xmap <leader>cn <plug>NERDCommenterNested[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: xmenu <silent> &Plugin.&comment.Nested<Tab>\\cn <plug>NERDCommenterNested[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>37_CreateMaps returning #0[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3023: call s:CreateMaps('n',  'ToEOL',      'To EOL', 'c$')[J

calling function <SNR>37_CreateMaps[J('n', 'ToEOL', 'To EOL', 'c$')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: nnoremap <silent> <plug>NERDCommenterToEOL :call NERDComment("n", "ToEOL")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: nmap <leader>c$ <plug>NERDCommenterToEOL[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: nmenu <silent> &Plugin.&comment.To\ EOL<Tab>\\c$ <plug>NERDCommenterToEOL[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>37_CreateMaps returning #0[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3024: call s:CreateMaps('nx', 'Invert',     'Invert', 'ci')[J

calling function <SNR>37_CreateMaps[J('nx', 'Invert', 'Invert', 'ci')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: nnoremap <silent> <plug>NERDCommenterInvert :call NERDComment("n", "Invert")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: nmap <leader>ci <plug>NERDCommenterInvert[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: nmenu <silent> &Plugin.&comment.Invert<Tab>\\ci <plug>NERDCommenterInvert[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: xnoremap <silent> <plug>NERDCommenterInvert :call NERDComment("x", "Invert")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: xmap <leader>ci <plug>NERDCommenterInvert[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: xmenu <silent> &Plugin.&comment.Invert<Tab>\\ci <plug>NERDCommenterInvert[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>37_CreateMaps returning #0[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3025: call s:CreateMaps('nx', 'Sexy',       'Sexy', 'cs')[J

calling function <SNR>37_CreateMaps[J('nx', 'Sexy', 'Sexy', 'cs')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: nnoremap <silent> <plug>NERDCommenterSexy :call NERDComment("n", "Sexy")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: nmap <leader>cs <plug>NERDCommenterSexy[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: nmenu <silent> &Plugin.&comment.Sexy<Tab>\\cs <plug>NERDCommenterSexy[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: xnoremap <silent> <plug>NERDCommenterSexy :call NERDComment("x", "Sexy")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: xmap <leader>cs <plug>NERDCommenterSexy[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: xmenu <silent> &Plugin.&comment.Sexy<Tab>\\cs <plug>NERDCommenterSexy[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>37_CreateMaps returning #0[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3026: call s:CreateMaps('nx', 'Yank',       'Yank then comment', 'cy')[J

calling function <SNR>37_CreateMaps[J('nx', 'Yank', 'Yank then comment', 'cy')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: nnoremap <silent> <plug>NERDCommenterYank :call NERDComment("n", "Yank")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: nmap <leader>cy <plug>NERDCommenterYank[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: nmenu <silent> &Plugin.&comment.Yank\ then\ comment<Tab>\\cy <plug>NERDCommenterYank[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: xnoremap <silent> <plug>NERDCommenterYank :call NERDComment("x", "Yank")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: xmap <leader>cy <plug>NERDCommenterYank[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: xmenu <silent> &Plugin.&comment.Yank\ then\ comment<Tab>\\cy <plug>NERDCommenterYank[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>37_CreateMaps returning #0[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3027: call s:CreateMaps('n',  'Append',     'Append', 'cA')[J

calling function <SNR>37_CreateMaps[J('n', 'Append', 'Append', 'cA')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: nnoremap <silent> <plug>NERDCommenterAppend :call NERDComment("n", "Append")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: nmap <leader>cA <plug>NERDCommenterAppend[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: nmenu <silent> &Plugin.&comment.Append<Tab>\\cA <plug>NERDCommenterAppend[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>37_CreateMaps returning #0[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3028: call s:CreateMaps('',   ':',          '-Sep-', '')[J

calling function <SNR>37_CreateMaps[J('', ':', '-Sep-', '')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: menu <silent> &Plugin.&comment.-Sep- :[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>37_CreateMaps returning #0[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3029: call s:CreateMaps('nx', 'AlignLeft',  'Left aligned', 'cl')[J

calling function <SNR>37_CreateMaps[J('nx', 'AlignLeft', 'Left aligned', 'cl')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: nnoremap <silent> <plug>NERDCommenterAlignLeft :call NERDComment("n", "AlignLeft")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: nmap <leader>cl <plug>NERDCommenterAlignLeft[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: nmenu <silent> &Plugin.&comment.Left\ aligned<Tab>\\cl <plug>NERDCommenterAlignLeft[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: xnoremap <silent> <plug>NERDCommenterAlignLeft :call NERDComment("x", "AlignLeft")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: xmap <leader>cl <plug>NERDCommenterAlignLeft[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: xmenu <silent> &Plugin.&comment.Left\ aligned<Tab>\\cl <plug>NERDCommenterAlignLeft[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>37_CreateMaps returning #0[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3030: call s:CreateMaps('nx', 'AlignBoth',  'Left and right aligned', 'cb')[J

calling function <SNR>37_CreateMaps[J('nx', 'AlignBoth', 'Left and right aligned', 'cb')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: nnoremap <silent> <plug>NERDCommenterAlignBoth :call NERDComment("n", "AlignBoth")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: nmap <leader>cb <plug>NERDCommenterAlignBoth[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: nmenu <silent> &Plugin.&comment.Left\ and\ right\ aligned<Tab>\\cb <plug>NERDCommenterAlignBoth[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: xnoremap <silent> <plug>NERDCommenterAlignBoth :call NERDComment("x", "AlignBoth")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: xmap <leader>cb <plug>NERDCommenterAlignBoth[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: xmenu <silent> &Plugin.&comment.Left\ and\ right\ aligned<Tab>\\cb <plug>NERDCommenterAlignBoth[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>37_CreateMaps returning #0[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3031: call s:CreateMaps('',   ':',          '-Sep2-', '')[J

calling function <SNR>37_CreateMaps[J('', ':', '-Sep2-', '')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: menu <silent> &Plugin.&comment.-Sep2- :[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>37_CreateMaps returning #0[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3032: call s:CreateMaps('nx', 'Uncomment',  'Uncomment', 'cu')[J

calling function <SNR>37_CreateMaps[J('nx', 'Uncomment', 'Uncomment', 'cu')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: nnoremap <silent> <plug>NERDCommenterUncomment :call NERDComment("n", "Uncomment")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: nmap <leader>cu <plug>NERDCommenterUncomment[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: nmenu <silent> &Plugin.&comment.Uncomment<Tab>\\cu <plug>NERDCommenterUncomment[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: xnoremap <silent> <plug>NERDCommenterUncomment :call NERDComment("x", "Uncomment")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: xmap <leader>cu <plug>NERDCommenterUncomment[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: xmenu <silent> &Plugin.&comment.Uncomment<Tab>\\cu <plug>NERDCommenterUncomment[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>37_CreateMaps returning #0[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3033: call s:CreateMaps('n',  'AltDelims',  'Switch Delimiters', 'ca')[J

calling function <SNR>37_CreateMaps[J('n', 'AltDelims', 'Switch Delimiters', 'ca')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: nnoremap <silent> <plug>NERDCommenterAltDelims :call NERDComment("n", "AltDelims")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: nmap <leader>ca <plug>NERDCommenterAltDelims[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: nmenu <silent> &Plugin.&comment.Switch\ Delimiters<Tab>\\ca <plug>NERDCommenterAltDelims[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>37_CreateMaps returning #0[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3034: call s:CreateMaps('i',  'Insert',     'Insert Comment Here', '')[J

calling function <SNR>37_CreateMaps[J('i', 'Insert', 'Insert Comment Here', '')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: imenu <silent> &Plugin.&comment.Insert\ Comment\ Here Insert[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>37_CreateMaps returning #0[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3035: call s:CreateMaps('',   ':',          '-Sep3-', '')[J

calling function <SNR>37_CreateMaps[J('', ':', '-Sep3-', '')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: menu <silent> &Plugin.&comment.-Sep3- :[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>37_CreateMaps returning #0[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3036: call s:CreateMaps('',   ':help NERDCommenterContents<CR>', 'Help', '')[J

calling function <SNR>37_CreateMaps[J('', ':help NERDCommenterContents<CR>', 'Help', '')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: menu <silent> &Plugin.&comment.Help :help NERDCommenterContents<CR>[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>37_CreateMaps returning #0[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3037: [J

line 3038: inoremap <silent> <plug>NERDCommenterInsert <SPACE><BS><ESC>:call NERDComment('i', "insert")<CR>[J

line 3039: [J

line 3040: " switch to/from alternative delimiters (does not use wrapper function)[J

line 3041: nnoremap <plug>NERDCommenterAltDelims :call <SID>SwitchToAlternativeDelimiters(1)<cr>[J

line 3042: [J

line 3043: " This is a workaround to enable lazy-loading from supported plugin managers:[J

line 3044: " See https://github.com/scrooloose/nerdcommenter/issues/176[J

line 3045: call s:SetUpForNewFiletype(&filetype, 1)[J

calling function <SNR>37_SetUpForNewFiletype[J('', 1)

line 1:     let ft = a:filetype[J

line 2: [J

line 3:     "for compound filetypes, if we don't know how to handle the full filetype[J

line 4:     "then break it down and use the first part that we know how to handle[J

line 5:     if ft =~ '\.' && !has_key(s:delimiterMap, ft)[J

line 6:         let filetypes = split(a:filetype, '\.')[J

line 7:         for i in filetypes[J

line 8:             if has_key(s:delimiterMap, i)[J

line 9:                 let ft = i[J

line 10:                 break[J

line 11:             endif[J

line 12:         endfor[J

line 13:     endif[J

line 14: [J

line 15:     let b:NERDSexyComMarker = ''[J

line 16: [J

line 17:     if has_key(s:delimiterMap, ft)[J

line 18:         let b:NERDCommenterDelims = s:delimiterMap[ft][J

line 19:         for i in ['left', 'leftAlt', 'right', 'rightAlt'][J

line 20:             if !has_key(b:NERDCommenterDelims, i)[J

line 21:                 let b:NERDCommenterDelims[i] = ''[J

line 22:             endif[J

line 23:         endfor[J

line 24:         for i in ['nested', 'nestedAlt'][J

line 25:             if !has_key(b:NERDCommenterDelims, i)[J

line 26:                 let b:NERDCommenterDelims[i] = 0[J

line 27:             endif[J

line 28:         endfor[J

line 29:         " if g:NERD_<filetype>_alt_style is defined, use the alternate style[J

line 30:         let b:NERDCommenterFirstInit = getbufvar(1,"NERDCommenterFirstInit")[J

line 31:         if exists('g:NERDAltDelims_'.ft) && eval('g:NERDAltDelims_'.ft) && !b:NERDCommenterFirstInit[J

line 32:             call s:SwitchToAlternativeDelimiters(0)[J

line 33:             let b:NERDCommenterFirstInit = 1[J

line 34:         endif[J

line 35:     else[J

line 36:         let b:NERDCommenterDelims = s:CreateDelimMapFromCms()[J

calling function <SNR>37_SetUpForNewFiletype[36]..<SNR>37_CreateDelimMapFromCms[J()

line 1:     if &ft == '' && exists('g:NERDDefaultDelims')[J

line 2:         let delims = g:NERDDefaultDelims[J

line 3:         for i in ['left', 'leftAlt', 'right', 'rightAlt'][J

line 4:             if !has_key(delims, i)[J

line 5:                 let delims[i] = ''[J

line 6:             endif[J

line 7:         endfor[J

line 8:         return delims[J

line 9:     endif[J

line 10:     return { 'left': substitute(&commentstring, '\([^ \t]*\)\s*%s.*', '\1', ''), 'right': substitute(&commentstring, '.*%s\s*\(.*\)', '\1', 'g'), 'nested': 0, 'leftAlt': '', 'rightAlt': '', 'nestedAlt': 0}[J

function <SNR>37_SetUpForNewFiletype[36]..<SNR>37_CreateDelimMapFromCms returning {'nestedAlt': 0, 'right': '*/', 'neste...Alt': '', 'left': '/*', 'rightAlt': ''}[J

continuing in function <SNR>37_SetUpForNewFiletype[J

line 37:     endif[J

line 38: [J

function <SNR>37_SetUpForNewFiletype returning #0[J

continuing in /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3046: [J

line 3047: " vim: set foldmethod=marker :[J

finished sourcing /home/patrick/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J
Searching for "/home/patrick/.vim/bundle/vim-fugitive/plugin/**/*.vim"[J
chdir(/home/patrick/.vim/bundle/vim-fugitive/plugin)[J
fchdir() to previous dir[J
sourcing "/home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim"[J
line 1: " fugitive.vim - A Git wrapper so awesome, it should be illegal[J

line 2: " Maintainer:   Tim Pope <http://tpo.pe/>[J

line 3: " Version:      2.2[J

line 4: " GetLatestVimScripts: 2975 1 :AutoInstall: fugitive.vim[J

line 5: [J

line 6: if exists('g:loaded_fugitive') || &cp[J

line 7:   finish[J

line 8: endif[J

line 9: let g:loaded_fugitive = 1[J

line 10: [J

line 11: if !exists('g:fugitive_git_executable')[J

line 12:   let g:fugitive_git_executable = 'git'[J

line 13: endif[J

line 14: [J

line 15: " Section: Utility[J

line 16: [J

line 17: function! s:function(name) abort[J

line 20: [J

line 21: function! s:sub(str,pat,rep) abort[J

line 24: [J

line 25: function! s:gsub(str,pat,rep) abort[J

line 28: [J

line 29: function! s:winshell() abort[J

line 32: [J

line 33: function! s:shellesc(arg) abort[J

line 42: [J

line 43: function! s:fnameescape(file) abort[J

line 50: [J

line 51: function! s:throw(string) abort[J

line 55: [J

line 56: function! s:warn(str) abort[J

line 62: [J

line 63: function! s:shellslash(path) abort[J

line 70: [J

line 71: let s:executables = {}[J

line 72: [J

line 73: function! s:executable(binary) abort[J

line 79: [J

line 80: let s:git_versions = {}[J

line 81: [J

line 82: function! s:git_command() abort[J

line 85: [J

line 86: function! fugitive#git_version(...) abort[J

Searching for "autoload/fugitive.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vim80/pack/dist/opt/matchit,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/after,/hom[J
Searching for "/home/patrick/.vim/autoload/fugitive.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/autoload/fugitive.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/autoload/fugitive.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/autoload/fugitive.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/autoload/fugitive.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/autoload/fugitive.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdcommenter/autoload/fugitive.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-fugitive/autoload/fugitive.vim"[J
Searching for "/home/patrick/.vim/bundle/ale/autoload/fugitive.vim"[J
Searching for "/home/patrick/.vim/bundle/tabular/autoload/fugitive.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-table-mode/autoload/fugitive.vim"[J
Searching for "/var/lib/vim/addons/autoload/fugitive.vim"[J
Searching for "/usr/share/vim/vimfiles/autoload/fugitive.vim"[J
Searching for "/usr/share/vim/vim80/autoload/fugitive.vim"[J
Searching for "/usr/share/vim/vim80/pack/dist/opt/matchit/autoload/fugitive.vim"[J
Searching for "/usr/share/vim/vimfiles/after/autoload/fugitive.vim"[J
Searching for "/var/lib/vim/addons/after/autoload/fugitive.vim"[J
Searching for "/home/patrick/.vim/after/autoload/fugitive.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/autoload/fugitive.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/after/autoload/fugitive.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/after/autoload/fugitive.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/after/autoload/fugitive.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/after/autoload/fugitive.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/after/autoload/fugitive.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdcommenter/after/autoload/fugitive.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-fugitive/after/autoload/fugitive.vim"[J
Searching for "/home/patrick/.vim/bundle/ale/after/autoload/fugitive.vim"[J
Searching for "/home/patrick/.vim/bundle/tabular/after/autoload/fugitive.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-table-mode/after/autoload/fugitive.vim"[J
not found in 'runtimepath': "autoload/fugitive.vim"[J
line 92: [J

line 93: function! s:recall() abort[J

line 110: [J

line 111: function! s:add_methods(namespace, method_names) abort[J

line 116: [J

line 117: let s:commands = [][J

line 118: function! s:command(definition) abort[J

line 121: [J

line 122: function! s:define_commands() abort[J

line 127: [J

line 128: let s:abstract_prototype = {}[J

line 129: [J

line 130: " Section: Initialization[J

line 131: [J

line 132: function! fugitive#is_git_dir(path) abort[J

line 138: [J

line 139: function! fugitive#extract_git_dir(path) abort[J

line 191: [J

line 192: function! fugitive#detect(path) abort[J

line 239: [J

line 240: augroup fugitive[J

line 241:   autocmd![J

line 242:   autocmd BufNewFile,BufReadPost * call fugitive#detect(expand('%:p'))[J

line 243:   autocmd FileType           netrw call fugitive#detect(expand('%:p'))[J

line 244:   autocmd User NERDTreeInit,NERDTreeNewRoot call fugitive#detect(b:NERDTreeRoot.path.str())[J

line 245:   autocmd VimEnter * if expand('<amatch>')==''|call fugitive#detect(getcwd())|endif[J

line 246:   autocmd CmdWinEnter * call fugitive#detect(expand('#:p'))[J

line 247:   autocmd BufWinLeave * execute getwinvar(+bufwinnr(+expand('<abuf>')), 'fugitive_leave')[J

line 248: augroup END[J

line 249: [J

line 250: " Section: Repository[J

line 251: [J

line 252: let s:repo_prototype = {}[J

line 253: let s:repos = {}[J

line 254: let s:worktree_for_dir = {}[J

line 255: let s:dir_for_worktree = {}[J

line 256: [J

line 257: function! s:repo(...) abort[J

line 270: [J

line 271: function! fugitive#repo(...) abort[J

line 274: [J

line 275: function! s:repo_dir(...) dict abort[J

line 278: [J

line 279: function! s:configured_tree(git_dir) abort[J

line 306: [J

line 307: function! s:repo_tree(...) dict abort[J

line 322: [J

line 323: function! s:repo_bare() dict abort[J

line 330: [J

line 331: function! s:repo_translate(spec) dict abort[J

line 381: [J

line 382: function! s:repo_head(...) dict abort[J

line 397: [J

line 398: call s:add_methods('repo',['dir','tree','bare','translate','head'])[J

calling function <SNR>38_add_methods[J('repo', ['dir', 'tree', 'bare', 'translate', 'head'])

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>38_add_methods[2]..<SNR>38_function[J('s:repo_dir')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>38_add_methods[2]..<SNR>38_function returning function('<SNR>38_repo_dir')[J

continuing in function <SNR>38_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>38_add_methods[2]..<SNR>38_function[J('s:repo_tree')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>38_add_methods[2]..<SNR>38_function returning function('<SNR>38_repo_tree')[J

continuing in function <SNR>38_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>38_add_methods[2]..<SNR>38_function[J('s:repo_bare')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>38_add_methods[2]..<SNR>38_function returning function('<SNR>38_repo_bare')[J

continuing in function <SNR>38_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>38_add_methods[2]..<SNR>38_function[J('s:repo_translate')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>38_add_methods[2]..<SNR>38_function returning function('<SNR>38_repo_translate')[J

continuing in function <SNR>38_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>38_add_methods[2]..<SNR>38_function[J('s:repo_head')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>38_add_methods[2]..<SNR>38_function returning function('<SNR>38_repo_head')[J

continuing in function <SNR>38_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

line 3:   endfor[J

function <SNR>38_add_methods returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 399: [J

line 400: function! s:repo_git_command(...) dict abort[J

line 404: [J

line 405: function! s:repo_git_chomp(...) dict abort[J

line 410: [J

line 411: function! s:repo_git_chomp_in_tree(...) dict abort[J

line 421: [J

line 422: function! s:repo_rev_parse(rev) dict abort[J

line 429: [J

line 430: call s:add_methods('repo',['git_command','git_chomp','git_chomp_in_tree','rev_parse'])[J

calling function <SNR>38_add_methods[J('repo', ['git_command', 'git_chomp', 'git_chomp_in_tree', 'rev_parse'])

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>38_add_methods[2]..<SNR>38_function[J('s:repo_git_command')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>38_add_methods[2]..<SNR>38_function returning function('<SNR>38_repo_git_command')[J

continuing in function <SNR>38_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>38_add_methods[2]..<SNR>38_function[J('s:repo_git_chomp')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>38_add_methods[2]..<SNR>38_function returning function('<SNR>38_repo_git_chomp')[J

continuing in function <SNR>38_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>38_add_methods[2]..<SNR>38_function[J('s:repo_git_chomp_in_tree')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>38_add_methods[2]..<SNR>38_function returning function('<SNR>38_repo_git_chomp_in_tree')[J

continuing in function <SNR>38_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>38_add_methods[2]..<SNR>38_function[J('s:repo_rev_parse')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>38_add_methods[2]..<SNR>38_function returning function('<SNR>38_repo_rev_parse')[J

continuing in function <SNR>38_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

line 3:   endfor[J

function <SNR>38_add_methods returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 431: [J

line 432: function! s:repo_dirglob(base) dict abort[J

line 438: [J

line 439: function! s:repo_superglob(base) dict abort[J

line 481: [J

line 482: call s:add_methods('repo',['dirglob','superglob'])[J

calling function <SNR>38_add_methods[J('repo', ['dirglob', 'superglob'])

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>38_add_methods[2]..<SNR>38_function[J('s:repo_dirglob')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>38_add_methods[2]..<SNR>38_function returning function('<SNR>38_repo_dirglob')[J

continuing in function <SNR>38_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>38_add_methods[2]..<SNR>38_function[J('s:repo_superglob')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>38_add_methods[2]..<SNR>38_function returning function('<SNR>38_repo_superglob')[J

continuing in function <SNR>38_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

line 3:   endfor[J

function <SNR>38_add_methods returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 483: [J

line 484: function! s:repo_config(conf) dict abort[J

line 487: [J

line 488: function! s:repo_user() dict abort[J

line 493: [J

line 494: function! s:repo_aliases() dict abort[J

line 503: [J

line 504: call s:add_methods('repo',['config', 'user', 'aliases'])[J

calling function <SNR>38_add_methods[J('repo', ['config', 'user', 'aliases'])

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>38_add_methods[2]..<SNR>38_function[J('s:repo_config')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>38_add_methods[2]..<SNR>38_function returning function('<SNR>38_repo_config')[J

continuing in function <SNR>38_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>38_add_methods[2]..<SNR>38_function[J('s:repo_user')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>38_add_methods[2]..<SNR>38_function returning function('<SNR>38_repo_user')[J

continuing in function <SNR>38_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>38_add_methods[2]..<SNR>38_function[J('s:repo_aliases')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>38_add_methods[2]..<SNR>38_function returning function('<SNR>38_repo_aliases')[J

continuing in function <SNR>38_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

line 3:   endfor[J

function <SNR>38_add_methods returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 505: [J

line 506: function! s:repo_keywordprg() dict abort[J

line 514: [J

line 515: call s:add_methods('repo',['keywordprg'])[J

calling function <SNR>38_add_methods[J('repo', ['keywordprg'])

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>38_add_methods[2]..<SNR>38_function[J('s:repo_keywordprg')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>38_add_methods[2]..<SNR>38_function returning function('<SNR>38_repo_keywordprg')[J

continuing in function <SNR>38_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

line 3:   endfor[J

function <SNR>38_add_methods returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 516: [J

line 517: " Section: Buffer[J

line 518: [J

line 519: let s:buffer_prototype = {}[J

line 520: [J

line 521: function! s:buffer(...) abort[J

line 529: [J

line 530: function! fugitive#buffer(...) abort[J

line 533: [J

line 534: function! s:buffer_getvar(var) dict abort[J

line 537: [J

line 538: function! s:buffer_setvar(var,value) dict abort[J

line 541: [J

line 542: function! s:buffer_getline(lnum) dict abort[J

line 545: [J

line 546: function! s:buffer_repo() dict abort[J

line 549: [J

line 550: function! s:buffer_type(...) dict abort[J

line 574: [J

line 575: if has('win32')[J

line 576: [J

line 577:   function! s:buffer_spec() dict abort[J

line 585: [J

line 586: else[J

line 587: [J

line 588:   function! s:buffer_spec() dict abort[J

line 592: [J

line 593: endif[J

line 594: [J

line 595: function! s:buffer_name() dict abort[J

line 598: [J

line 599: function! s:buffer_commit() dict abort[J

line 602: [J

line 603: function! s:cpath(path) abort[J

line 610: [J

line 611: function! s:buffer_path(...) dict abort[J

line 625: [J

line 626: function! s:buffer_rev() dict abort[J

line 640: [J

line 641: function! s:buffer_sha1() dict abort[J

line 648: [J

line 649: function! s:buffer_expand(rev) dict abort[J

line 666: [J

line 667: function! s:buffer_containing_commit() dict abort[J

line 676: [J

line 677: function! s:buffer_up(...) dict abort[J

line 700: [J

line 701: call s:add_methods('buffer',['getvar','setvar','getline','repo','type','spec','name','commit','path','rev','sha1','expand','containing_commit','up'])[J

calling function <SNR>38_add_methods[J('buffer', ['getvar', 'setvar', 'getline', 'repo'...', 'expand', 'containing_commit', 'up'])

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>38_add_methods[2]..<SNR>38_function[J('s:buffer_getvar')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>38_add_methods[2]..<SNR>38_function returning function('<SNR>38_buffer_getvar')[J

continuing in function <SNR>38_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>38_add_methods[2]..<SNR>38_function[J('s:buffer_setvar')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>38_add_methods[2]..<SNR>38_function returning function('<SNR>38_buffer_setvar')[J

continuing in function <SNR>38_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>38_add_methods[2]..<SNR>38_function[J('s:buffer_getline')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>38_add_methods[2]..<SNR>38_function returning function('<SNR>38_buffer_getline')[J

continuing in function <SNR>38_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>38_add_methods[2]..<SNR>38_function[J('s:buffer_repo')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>38_add_methods[2]..<SNR>38_function returning function('<SNR>38_buffer_repo')[J

continuing in function <SNR>38_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>38_add_methods[2]..<SNR>38_function[J('s:buffer_type')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>38_add_methods[2]..<SNR>38_function returning function('<SNR>38_buffer_type')[J

continuing in function <SNR>38_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>38_add_methods[2]..<SNR>38_function[J('s:buffer_spec')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>38_add_methods[2]..<SNR>38_function returning function('<SNR>38_buffer_spec')[J

continuing in function <SNR>38_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>38_add_methods[2]..<SNR>38_function[J('s:buffer_name')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>38_add_methods[2]..<SNR>38_function returning function('<SNR>38_buffer_name')[J

continuing in function <SNR>38_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>38_add_methods[2]..<SNR>38_function[J('s:buffer_commit')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>38_add_methods[2]..<SNR>38_function returning function('<SNR>38_buffer_commit')[J

continuing in function <SNR>38_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>38_add_methods[2]..<SNR>38_function[J('s:buffer_path')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>38_add_methods[2]..<SNR>38_function returning function('<SNR>38_buffer_path')[J

continuing in function <SNR>38_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>38_add_methods[2]..<SNR>38_function[J('s:buffer_rev')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>38_add_methods[2]..<SNR>38_function returning function('<SNR>38_buffer_rev')[J

continuing in function <SNR>38_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>38_add_methods[2]..<SNR>38_function[J('s:buffer_sha1')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>38_add_methods[2]..<SNR>38_function returning function('<SNR>38_buffer_sha1')[J

continuing in function <SNR>38_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>38_add_methods[2]..<SNR>38_function[J('s:buffer_expand')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>38_add_methods[2]..<SNR>38_function returning function('<SNR>38_buffer_expand')[J

continuing in function <SNR>38_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>38_add_methods[2]..<SNR>38_function[J('s:buffer_containing_commit')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>38_add_methods[2]..<SNR>38_function returning function('<SNR>38_buffer_containing_commit')[J

continuing in function <SNR>38_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>38_add_methods[2]..<SNR>38_function[J('s:buffer_up')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>38_add_methods[2]..<SNR>38_function returning function('<SNR>38_buffer_up')[J

continuing in function <SNR>38_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

line 3:   endfor[J

function <SNR>38_add_methods returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 702: [J

line 703: " Section: Git[J

line 704: [J

line 705: call s:command("-bang -nargs=? -complete=customlist,s:GitComplete Git :execute s:Git(<bang>0,<q-args>)")[J

calling function <SNR>38_command[J('-bang -nargs=? -complete=customlist,s...e Git :execute s:Git(<bang>0,<q-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>38_command returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 706: [J

line 707: function! s:ExecuteInTree(cmd) abort[J

line 717: [J

line 718: function! s:Git(bang, args) abort[J

line 744: [J

line 745: function! fugitive#git_commands() abort[J

line 751: [J

line 752: function! s:GitComplete(A, L, P) abort[J

line 760: [J

line 761: " Section: Gcd, Glcd[J

line 762: [J

line 763: function! s:DirComplete(A,L,P) abort[J

line 767: [J

line 768: call s:command("-bar -bang -nargs=? -complete=customlist,s:DirComplete Gcd  :exe 'cd<bang>'  s:fnameescape(s:repo().bare() ? s:repo().dir(<q-args>) : s:repo().tree(<q-args>))")[J

calling function <SNR>38_command[J('-bar -bang -nargs=? -complete=customl...r(<q-args>) : s:repo().tree(<q-args>))')

line 1:   let s:commands += [a:definition][J

function <SNR>38_command returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 769: call s:command("-bar -bang -nargs=? -complete=customlist,s:DirComplete Glcd :exe 'lcd<bang>' s:fnameescape(s:repo().bare() ? s:repo().dir(<q-args>) : s:repo().tree(<q-args>))")[J

calling function <SNR>38_command[J('-bar -bang -nargs=? -complete=customl...r(<q-args>) : s:repo().tree(<q-args>))')

line 1:   let s:commands += [a:definition][J

function <SNR>38_command returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 770: [J

line 771: " Section: Gstatus[J

line 772: [J

line 773: call s:command("-bar Gstatus :execute s:Status()")[J

calling function <SNR>38_command[J('-bar Gstatus :execute s:Status()')

line 1:   let s:commands += [a:definition][J

function <SNR>38_command returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 774: augroup fugitive_status[J

line 775:   autocmd![J

line 776:   if !has('win32')[J

line 777:     autocmd FocusGained,ShellCmdPost * call fugitive#reload_status()[J

line 778:     autocmd BufDelete term://* call fugitive#reload_status()[J

line 779:   endif[J

line 780: augroup END[J

line 781: [J

line 782: function! s:Status() abort[J

line 793: [J

line 794: function! fugitive#reload_status() abort[J

line 826: [J

line 827: function! s:stage_info(lnum) abort[J

line 852: [J

line 853: function! s:StageNext(count) abort[J

line 859: [J

line 860: function! s:StagePrevious(count) abort[J

line 870: [J

line 871: function! s:StageReloadSeek(target,lnum1,lnum2) abort[J

line 882: [J

line 883: function! s:StageUndo() abort[J

line 906: [J

line 907: function! s:StageDiff(diff) abort[J

line 925: [J

line 926: function! s:StageDiffEdit() abort[J

line 948: [J

line 949: function! s:StageToggle(lnum1,lnum2) abort[J

line 1016: [J

line 1017: function! s:StagePatch(lnum1,lnum2) abort[J

line 1062: [J

line 1063: " Section: Gcommit[J

line 1064: [J

line 1065: call s:command("-nargs=? -complete=customlist,s:CommitComplete Gcommit :execute s:Commit(<q-args>)")[J

calling function <SNR>38_command[J('-nargs=? -complete=customlist,s:Commi...te Gcommit :execute s:Commit(<q-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>38_command returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 1066: [J

line 1067: function! s:Commit(args, ...) abort[J

line 1150: [J

line 1151: function! s:CommitComplete(A,L,P) abort[J

line 1159: [J

line 1160: function! s:FinishCommit() abort[J

line 1168: [J

line 1169: " Section: Gmerge, Gpull[J

line 1170: [J

line 1172: call s:command("-nargs=? -bang -complete=custom,s:RevisionComplete Gmerge " . "execute s:Merge('merge', <bang>0, <q-args>)")[J

calling function <SNR>38_command[J('-nargs=? -bang -complete=custom,s:Rev... s:Merge(''merge'', <bang>0, <q-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>38_command returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 1174: call s:command("-nargs=? -bang -complete=custom,s:RemoteComplete Gpull " . "execute s:Merge('pull --progress', <bang>0, <q-args>)")[J

calling function <SNR>38_command[J('-nargs=? -bang -complete=custom,s:Rem...'pull --progress'', <bang>0, <q-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>38_command returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 1175: [J

line 1176: function! s:RevisionComplete(A, L, P) abort[J

line 1180: [J

line 1181: function! s:RemoteComplete(A, L, P) abort[J

line 1192: [J

line 1193: function! fugitive#cwindow() abort[J

line 1203: [J

line 1210: let s:common_efm = '' . '%+Egit:%.%#,' . '%+Eusage:%.%#,' . '%+Eerror:%.%#,' . '%+Efatal:%.%#,' . '%-G%.%#%\e[K%.%#,' . '%-G%.%#%\r%.%\+'[J

line 1211: [J

line 1212: function! s:Merge(cmd, bang, args) abort[J

line 1289: [J

line 1290: " Section: Ggrep, Glog[J

line 1291: [J

line 1292: if !exists('g:fugitive_summary_format')[J

line 1293:   let g:fugitive_summary_format = '%s'[J

line 1294: endif[J

line 1295: [J

line 1296: call s:command("-bang -nargs=? -complete=customlist,s:EditComplete Ggrep :execute s:Grep('grep',<bang>0,<q-args>)")[J

calling function <SNR>38_command[J('-bang -nargs=? -complete=customlist,s...cute s:Grep(''grep'',<bang>0,<q-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>38_command returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 1297: call s:command("-bang -nargs=? -complete=customlist,s:EditComplete Glgrep :execute s:Grep('lgrep',<bang>0,<q-args>)")[J

calling function <SNR>38_command[J('-bang -nargs=? -complete=customlist,s...ute s:Grep(''lgrep'',<bang>0,<q-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>38_command returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 1298: call s:command("-bar -bang -nargs=* -range=0 -complete=customlist,s:EditComplete Glog :call s:Log('grep<bang>',<line1>,<count>,<f-args>)")[J

calling function <SNR>38_command[J('-bar -bang -nargs=* -range=0 -complet...grep<bang>'',<line1>,<count>,<f-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>38_command returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 1299: call s:command("-bar -bang -nargs=* -range=0 -complete=customlist,s:EditComplete Gllog :call s:Log('lgrep<bang>',<line1>,<count>,<f-args>)")[J

calling function <SNR>38_command[J('-bar -bang -nargs=* -range=0 -complet...grep<bang>'',<line1>,<count>,<f-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>38_command returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 1300: [J

line 1301: function! s:Grep(cmd,bang,arg) abort[J

line 1339: [J

line 1340: function! s:Log(cmd, line1, line2, ...) abort[J

line 1377: [J

line 1378: " Section: Gedit, Gpedit, Gsplit, Gvsplit, Gtabedit, Gread[J

line 1379: [J

line 1380: function! s:Edit(cmd,bang,...) abort[J

line 1470: [J

line 1471: function! s:EditComplete(A,L,P) abort[J

line 1474: [J

line 1475: function! s:EditRunComplete(A,L,P) abort[J

line 1482: [J

line 1483: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditComplete Ge       :execute s:Edit('edit<bang>',0,<f-args>)")[J

calling function <SNR>38_command[J('-bar -bang -nargs=* -complete=customl...cute s:Edit(''edit<bang>'',0,<f-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>38_command returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 1484: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditComplete Gedit    :execute s:Edit('edit<bang>',0,<f-args>)")[J

calling function <SNR>38_command[J('-bar -bang -nargs=* -complete=customl...cute s:Edit(''edit<bang>'',0,<f-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>38_command returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 1485: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditRunComplete Gpedit   :execute s:Edit('pedit',<bang>0,<f-args>)")[J

calling function <SNR>38_command[J('-bar -bang -nargs=* -complete=customl...ute s:Edit(''pedit'',<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>38_command returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 1486: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditRunComplete Gsplit   :execute s:Edit('split',<bang>0,<f-args>)")[J

calling function <SNR>38_command[J('-bar -bang -nargs=* -complete=customl...ute s:Edit(''split'',<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>38_command returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 1487: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditRunComplete Gvsplit  :execute s:Edit('vsplit',<bang>0,<f-args>)")[J

calling function <SNR>38_command[J('-bar -bang -nargs=* -complete=customl...te s:Edit(''vsplit'',<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>38_command returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 1488: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditRunComplete Gtabedit :execute s:Edit('tabedit',<bang>0,<f-args>)")[J

calling function <SNR>38_command[J('-bar -bang -nargs=* -complete=customl...e s:Edit(''tabedit'',<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>38_command returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 1489: call s:command("-bar -bang -nargs=* -count -complete=customlist,s:EditRunComplete Gread :execute s:Edit((!<count> && <line1> ? '' : <count>).'read',<bang>0,<f-args>)")[J

calling function <SNR>38_command[J('-bar -bang -nargs=* -count -complete=... : <count>).''read'',<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>38_command returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 1490: [J

line 1491: " Section: Gwrite, Gwq[J

line 1492: [J

line 1493: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditComplete Gwrite :execute s:Write(<bang>0,<f-args>)")[J

calling function <SNR>38_command[J('-bar -bang -nargs=* -complete=customl...ite :execute s:Write(<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>38_command returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 1494: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditComplete Gw :execute s:Write(<bang>0,<f-args>)")[J

calling function <SNR>38_command[J('-bar -bang -nargs=* -complete=customl... Gw :execute s:Write(<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>38_command returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 1495: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditComplete Gwq :execute s:Wq(<bang>0,<f-args>)")[J

calling function <SNR>38_command[J('-bar -bang -nargs=* -complete=customl...te Gwq :execute s:Wq(<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>38_command returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 1496: [J

line 1497: function! s:Write(force,...) abort[J

line 1637: [J

line 1638: function! s:Wq(force,...) abort[J

line 1650: [J

line 1651: augroup fugitive_commit[J

line 1652:   autocmd![J

line 1653:   autocmd VimLeavePre,BufDelete COMMIT_EDITMSG execute s:sub(s:FinishCommit(), '^echoerr (.*)', 'echohl ErrorMsg|echo \1|echohl NONE')[J

line 1654: augroup END[J

line 1655: [J

line 1656: " Section: Gpush, Gfetch[J

line 1657: [J

line 1658: call s:command("-nargs=? -bang -complete=custom,s:RemoteComplete Gpush  execute s:Dispatch('<bang>', 'push '.<q-args>)")[J

calling function <SNR>38_command[J('-nargs=? -bang -complete=custom,s:Rem...spatch(''<bang>'', ''push ''.<q-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>38_command returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 1659: call s:command("-nargs=? -bang -complete=custom,s:RemoteComplete Gfetch execute s:Dispatch('<bang>', 'fetch '.<q-args>)")[J

calling function <SNR>38_command[J('-nargs=? -bang -complete=custom,s:Rem...patch(''<bang>'', ''fetch ''.<q-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>38_command returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 1660: [J

line 1661: function! s:Dispatch(bang, args)[J

line 1684: [J

line 1685: " Section: Gdiff[J

line 1686: [J

line 1687: call s:command("-bang -bar -nargs=* -complete=customlist,s:EditComplete Gdiff :execute s:Diff('',<bang>0,<f-args>)")[J

calling function <SNR>38_command[J('-bang -bar -nargs=* -complete=customl...:execute s:Diff('''',<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>38_command returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 1688: call s:command("-bang -bar -nargs=* -complete=customlist,s:EditComplete Gvdiff :execute s:Diff('keepalt vert ',<bang>0,<f-args>)")[J

calling function <SNR>38_command[J('-bang -bar -nargs=* -complete=customl...ff(''keepalt vert '',<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>38_command returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 1689: call s:command("-bang -bar -nargs=* -complete=customlist,s:EditComplete Gsdiff :execute s:Diff('keepalt ',<bang>0,<f-args>)")[J

calling function <SNR>38_command[J('-bang -bar -nargs=* -complete=customl... s:Diff(''keepalt '',<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>38_command returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 1690: [J

line 1691: augroup fugitive_diff[J

line 1692:   autocmd![J

line 1696:   autocmd BufWinLeave * if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 2 |   call s:diffoff_all(getbufvar(+expand('<abuf>'), 'git_dir')) | endif[J

line 1700:   autocmd BufWinEnter * if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 1 |   call s:diffoff() | endif[J

line 1701: augroup END[J

line 1702: [J

line 1703: function! s:can_diffoff(buf) abort[J

line 1708: [J

line 1709: function! fugitive#can_diffoff(buf) abort[J

line 1712: [J

line 1713: function! s:diff_modifier(count) abort[J

line 1725: [J

line 1726: function! s:diff_window_count() abort[J

line 1733: [J

line 1734: function! s:diff_restore() abort[J

line 1748: [J

line 1749: function! s:diffthis() abort[J

line 1755: [J

line 1756: function! s:diffoff() abort[J

line 1764: [J

line 1765: function! s:diffoff_all(dir) abort[J

line 1780: [J

line 1781: function! s:buffer_compare_age(commit) dict abort[J

line 1800: [J

line 1801: call s:add_methods('buffer',['compare_age'])[J

calling function <SNR>38_add_methods[J('buffer', ['compare_age'])

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>38_add_methods[2]..<SNR>38_function[J('s:buffer_compare_age')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>38_add_methods[2]..<SNR>38_function returning function('<SNR>38_buffer_compare_age')[J

continuing in function <SNR>38_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

line 3:   endfor[J

function <SNR>38_add_methods returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 1802: [J

line 1803: function! s:Diff(vert,keepfocus,...) abort[J

line 1880: [J

line 1881: " Section: Gmove, Gremove[J

line 1882: [J

line 1883: function! s:Move(force,destination) abort[J

line 1916: [J

line 1917: function! s:MoveComplete(A,L,P) abort[J

line 1926: [J

line 1927: function! s:Remove(after, force) abort[J

line 1948: [J

line 1949: augroup fugitive_remove[J

line 1950:   autocmd![J

line 1955:   autocmd User Fugitive if s:buffer().commit() =~# '^0\=$' | exe "command! -buffer -bar -bang -nargs=1 -complete=customlist,s:MoveComplete Gmove :execute s:Move(<bang>0,<q-args>)" | exe "command! -buffer -bar -bang Gremove :execute s:Remove('edit',<bang>0)" | exe "command! -buffer -bar -bang Gdelete :execute s:Remove('bdelete',<bang>0)" | endif[J

line 1956: augroup END[J

line 1957: [J

line 1958: " Section: Gblame[J

line 1959: [J

line 1960: augroup fugitive_blame[J

line 1961:   autocmd![J

line 1962:   autocmd BufReadPost *.fugitiveblame setfiletype fugitiveblame[J

line 1963:   autocmd FileType fugitiveblame setlocal nomodeline | if exists('b:git_dir') | let &l:keywordprg = s:repo().keywordprg() | endif[J

line 1964:   autocmd Syntax fugitiveblame call s:BlameSyntax()[J

line 1965:   autocmd User Fugitive if s:buffer().type('file', 'blob') | exe "command! -buffer -bar -bang -range=0 -nargs=* Gblame :execute s:Blame(<bang>0,<line1>,<line2>,<count>,[<f-args>])" | endif[J

line 1966:   autocmd ColorScheme,GUIEnter * call s:RehighlightBlame()[J

line 1967: augroup END[J

line 1968: [J

line 1969: function! s:linechars(pattern) abort[J

line 1978: [J

line 1979: function! s:Blame(bang,line1,line2,count,args) abort[J

line 2097: [J

line 2098: function! s:BlameCommit(cmd) abort[J

line 2138: [J

line 2139: function! s:BlameJump(suffix) abort[J

line 2174: [J

line 2175: let s:hash_colors = {}[J

line 2176: [J

line 2177: function! s:BlameSyntax() abort[J

line 2225: [J

line 2226: function! s:RehighlightBlame() abort[J

line 2235: [J

line 2236: " Section: Gbrowse[J

line 2237: [J

line 2238: call s:command("-bar -bang -range=0 -nargs=* -complete=customlist,s:EditComplete Gbrowse :execute s:Browse(<bang>0,<line1>,<count>,<f-args>)")[J

calling function <SNR>38_command[J('-bar -bang -range=0 -nargs=* -complet...owse(<bang>0,<line1>,<count>,<f-args>)')

line 1:   let s:commands += [a:definition][J

function <SNR>38_command returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 2239: [J

line 2240: let s:redirects = {}[J

line 2241: [J

line 2242: function! s:Browse(bang,line1,count,...) abort[J

line 2410: [J

line 2411: function! s:github_url(opts, ...) abort[J

line 2427: [J

line 2428: function! s:instaweb_url(opts) abort[J

line 2469: [J

line 2470: if !exists('g:fugitive_browse_handlers')[J

line 2471:   let g:fugitive_browse_handlers = [][J

line 2472: endif[J

line 2473: [J

line 2475: call extend(g:fugitive_browse_handlers, [s:function('s:github_url'), s:function('s:instaweb_url')])[J

calling function <SNR>38_function[J('s:github_url')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>38_function returning function('<SNR>38_github_url')[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

calling function <SNR>38_function[J('s:instaweb_url')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>38_function returning function('<SNR>38_instaweb_url')[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 2476: [J

line 2477: " Section: File access[J

line 2478: [J

line 2479: function! s:ReplaceCmd(cmd,...) abort[J

line 2524: [J

line 2525: function! s:BufReadIndex() abort[J

line 2602: [J

line 2603: function! s:FileRead() abort[J

line 2619: [J

line 2620: function! s:BufReadIndexFile() abort[J

line 2640: [J

line 2641: function! s:BufWriteIndexFile() abort[J

line 2673: [J

line 2674: function! s:BufReadObject() abort[J

line 2755: [J

line 2756: augroup fugitive_files[J

line 2757:   autocmd![J

line 2764:   autocmd BufReadCmd  index{,.lock} if fugitive#is_git_dir(expand('<amatch>:p:h')) |   exe s:BufReadIndex() | elseif filereadable(expand('<amatch>')) |   read <amatch> |   1delete | endif[J

line 2765:   autocmd FileReadCmd fugitive://**//[0-3]/**          exe s:FileRead()[J

line 2766:   autocmd BufReadCmd  fugitive://**//[0-3]/**          exe s:BufReadIndexFile()[J

line 2767:   autocmd BufWriteCmd fugitive://**//[0-3]/**          exe s:BufWriteIndexFile()[J

line 2768:   autocmd BufReadCmd  fugitive://**//[0-9a-f][0-9a-f]* exe s:BufReadObject()[J

line 2769:   autocmd FileReadCmd fugitive://**//[0-9a-f][0-9a-f]* exe s:FileRead()[J

line 2773:   autocmd FileType git if exists('b:git_dir') |  call s:JumpInit() | endif[J

line 2777:   autocmd FileType git,gitcommit,gitrebase if exists('b:git_dir') |   call s:GFInit() | endif[J

line 2778: augroup END[J

line 2779: [J

line 2780: " Section: Temp files[J

line 2781: [J

line 2782: if !exists('s:temp_files')[J

line 2783:   let s:temp_files = {}[J

line 2784: endif[J

line 2785: [J

line 2786: augroup fugitive_temp[J

line 2787:   autocmd![J

line 2796:   autocmd BufNewFile,BufReadPost * if has_key(s:temp_files,s:cpath(expand('<afile>:p'))) |   let b:git_dir = s:temp_files[s:cpath(expand('<afile>:p'))].dir |   let b:git_type = 'temp' |   let b:git_args = s:temp_files[s:cpath(expand('<afile>:p'))].args |   call fugitive#detect(expand('<afile>:p')) |   setlocal bufhidden=delete nobuflisted |   nnoremap <buffer> <silent> q    :<C-U>bdelete<CR>| endif[J

line 2797: augroup END[J

line 2798: [J

line 2799: " Section: Go to file[J

line 2800: [J

line 2801: nnoremap <SID>: :<C-U><C-R>=v:count ? v:count : ''<CR>[J

line 2802: function! s:GFInit(...) abort[J

line 2811: [J

line 2812: function! s:JumpInit(...) abort[J

line 2830: [J

line 2831: function! s:cfile() abort[J

line 3010: [J

line 3011: function! s:GF(mode) abort[J

line 3023: [J

line 3024: function! fugitive#cfile() abort[J

line 3038: [J

line 3039: " Section: Statusline[J

line 3040: [J

line 3041: function! s:repo_head_ref() dict abort[J

line 3047: [J

line 3048: call s:add_methods('repo',['head_ref'])[J

calling function <SNR>38_add_methods[J('repo', ['head_ref'])

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

calling function <SNR>38_add_methods[2]..<SNR>38_function[J('s:repo_head_ref')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))[J

function <SNR>38_add_methods[2]..<SNR>38_function returning function('<SNR>38_repo_head_ref')[J

continuing in function <SNR>38_add_methods[J

line 3:   endfor[J

line 1:   for name in a:method_names[J

line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)[J

line 3:   endfor[J

function <SNR>38_add_methods returning #0[J

continuing in /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J

line 3049: [J

line 3050: function! fugitive#statusline(...) abort[J

line 3065: [J

line 3066: function! fugitive#head(...) abort[J

line 3073: [J

line 3074: augroup fugitive_statusline[J

line 3075:   autocmd![J

line 3076:   autocmd User Flags call Hoist('buffer', function('fugitive#statusline'))[J

line 3077: augroup END[J

line 3078: [J

line 3079: " Section: Folding[J

line 3080: [J

line 3081: function! fugitive#foldtext() abort[J

line 3119: [J

line 3120: augroup fugitive_foldtext[J

line 3121:   autocmd![J

line 3125:   autocmd User Fugitive if &filetype =~# '^git\%(commit\)\=$' && &foldtext ==# 'foldtext()' |    set foldtext=fugitive#foldtext() | endif[J

line 3126: augroup END[J

finished sourcing /home/patrick/.vim/bundle/vim-fugitive/plugin/fugitive.vim[J
Searching for "/home/patrick/.vim/bundle/ale/plugin/**/*.vim"[J
chdir(/home/patrick/.vim/bundle/ale/plugin)[J
fchdir() to previous dir[J
sourcing "/home/patrick/.vim/bundle/ale/plugin/ale.vim"[J
line 1: " Author: w0rp <devw0rp@gmail.com>[J

line 2: " Description: Main entry point for the plugin: sets up prefs and autocommands[J

line 3: "   Preferences can be set in vimrc files and so on to configure ale[J

line 4: [J

line 5: " Sanity Checks[J

line 6: [J

line 7: if exists('g:loaded_ale_dont_use_this_in_other_plugins_please')[J

line 8:     finish[J

line 9: endif[J

line 10: [J

line 11: " Set a special flag used only by this plugin for preventing doubly[J

line 12: " loading the script.[J

line 13: let g:loaded_ale_dont_use_this_in_other_plugins_please = 1[J

line 14: [J

line 15: " A flag for detecting if the required features are set.[J

line 16: if has('nvim')[J

line 17:     let s:has_features = has('timers')[J

line 18: else[J

line 19:     " Check if Job and Channel functions are available, instead of the[J

line 20:     " features. This works better on old MacVim versions.[J

line 21:     let s:has_features = has('timers') && exists('*job_start') && exists('*ch_close_in')[J

line 22: endif[J

line 23: [J

line 24: if !s:has_features[J

line 25:     " Only output a warning if editing some special files.[J

line 26:     if index(['', 'gitcommit'], &filetype) == -1[J

line 27:         echoerr 'ALE requires NeoVim >= 0.1.5 or Vim 8 with +timers +job +channel'[J

line 28:         echoerr 'Please update your editor appropriately.'[J

line 29:     endif[J

line 30: [J

line 31:     " Stop here, as it won't work.[J

line 32:     finish[J

line 33: endif[J

line 34: [J

line 35: " Add the after directory to the runtimepath[J

line 36: let &runtimepath .= ',' . expand('<sfile>:p:h:h') . '/after'[J

line 37: [J

line 38: " Set this flag so that other plugins can use it, like airline.[J

line 39: let g:loaded_ale = 1[J

line 40: [J

line 41: " Set the TMPDIR environment variable if it is not set automatically.[J

line 42: " This can automatically fix some environments.[J

line 43: if has('unix') && empty($TMPDIR)[J

line 44:     let $TMPDIR = '/tmp'[J

line 45: endif[J

line 46: [J

line 47: " This flag can be set to 0 to disable emitting conflict warnings.[J

line 48: let g:ale_emit_conflict_warnings = get(g:, 'ale_emit_conflict_warnings', 1)[J

line 49: [J

line 50: " This global variable is used internally by ALE for tracking information for[J

line 51: " each buffer which linters are being run against.[J

line 52: let g:ale_buffer_info = {}[J

line 53: [J

line 54: " User Configuration[J

line 55: [J

line 56: " This option prevents ALE autocmd commands from being run for particular[J

line 57: " filetypes which can cause issues.[J

line 64: let g:ale_filetype_blacklist = [   'dirvish',   'nerdtree',   'qf',   'tags',   'unite',][J

line 65: [J

line 66: " This Dictionary configures which linters are enabled for which languages.[J

line 67: let g:ale_linters = get(g:, 'ale_linters', {})[J

line 68: [J

line 69: " This Dictionary configures which functions will be used for fixing problems.[J

line 70: let g:ale_fixers = get(g:, 'ale_fixers', {})[J

line 71: [J

line 72: " This Dictionary allows users to set up filetype aliases for new filetypes.[J

line 73: let g:ale_linter_aliases = get(g:, 'ale_linter_aliases', {})[J

line 74: [J

line 75: " This flag can be set with a number of milliseconds for delaying the[J

line 76: " execution of a linter when text is changed. The timeout will be set and[J

line 77: " cleared each time text is changed, so repeated edits won't trigger the[J

line 78: " jobs for linting until enough time has passed after editing is done.[J

line 79: let g:ale_lint_delay = get(g:, 'ale_lint_delay', 200)[J

line 80: [J

line 81: " This flag can be set to 'never' to disable linting when text is changed.[J

line 82: " This flag can also be set to 'insert' or 'normal' to lint when text is[J

line 83: " changed only in insert or normal mode respectively.[J

line 84: let g:ale_lint_on_text_changed = get(g:, 'ale_lint_on_text_changed', 'always')[J

line 85: [J

line 86: " This flag can be set to 1 to enable linting when leaving insert mode.[J

line 87: let g:ale_lint_on_insert_leave = get(g:, 'ale_lint_on_insert_leave', 0)[J

line 88: [J

line 89: " This flag can be set to 0 to disable linting when the buffer is entered.[J

line 90: let g:ale_lint_on_enter = get(g:, 'ale_lint_on_enter', 1)[J

line 91: [J

line 92: " This flag can be set to 1 to enable linting when a buffer is written.[J

line 93: let g:ale_lint_on_save = get(g:, 'ale_lint_on_save', 1)[J

line 94: [J

line 95: " This flag can be set to 1 to enable linting when the filetype is changed.[J

line 96: let g:ale_lint_on_filetype_changed = get(g:, 'ale_lint_on_filetype_changed', 1)[J

line 97: [J

line 98: call ale#Set('fix_on_save', 0)[J

Searching for "autoload/ale.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vim80/pack/dist/opt/matchit,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/after,/home/pat[J
Searching for "/home/patrick/.vim/autoload/ale.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/autoload/ale.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/autoload/ale.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/autoload/ale.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/autoload/ale.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/autoload/ale.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdcommenter/autoload/ale.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-fugitive/autoload/ale.vim"[J
Searching for "/home/patrick/.vim/bundle/ale/autoload/ale.vim"[J
chdir(/home/patrick/.vim/bundle/ale/autoload)[J
fchdir() to previous dir[J
line 98: sourcing "/home/patrick/.vim/bundle/ale/autoload/ale.vim"[J
line 1: " Author: w0rp <devw0rp@gmail.com>, David Alexander <opensource@thelonelyghost.com>[J

line 2: " Description: Primary code path for the plugin[J

line 3: "   Manages execution of linters when requested by autocommands[J

line 4: [J

line 5: let s:lint_timer = -1[J

line 6: let s:queued_buffer_number = -1[J

line 7: let s:should_lint_file_for_buffer = {}[J

line 8: let s:error_delay_ms = 1000 * 60 * 2[J

line 9: [J

line 10: let s:timestamp_map = {}[J

line 11: [J

line 12: " Given a key for a script variable for tracking the time to wait until[J

line 13: " a given function should be called, a funcref for a function to call, and[J

line 14: " a List of arguments, call the function and return whatever value it returns.[J

line 15: "[J

line 16: " If the function throws an exception, then the function will not be called[J

line 17: " for a while, and 0 will be returned instead.[J

line 18: function! ale#CallWithCooldown(timestamp_key, func, arglist) abort[J

line 33: [J

line 34: " Return 1 if a file is too large for ALE to handle.[J

line 35: function! ale#FileTooLarge() abort[J

line 40: [J

line 41: " A function for checking various conditions whereby ALE just shouldn't[J

line 42: " attempt to do anything, say if particular buffer types are open in Vim.[J

line 43: function! ale#ShouldDoNothing(buffer) abort[J

line 53: [J

line 54: " (delay, [linting_flag, buffer_number])[J

line 55: function! ale#Queue(delay, ...) abort[J

line 70: [J

line 71: function! s:ALEQueueImpl(delay, linting_flag, buffer) abort[J

line 115: [J

line 116: function! ale#Lint(...) abort[J

line 134: [J

line 135: function! s:ALELintImpl(buffer) abort[J

line 153: [J

line 154: " Reset flags indicating that files should be checked for all buffers.[J

line 155: function! ale#ResetLintFileMarkers() abort[J

line 158: [J

line 159: function! ale#ResetErrorDelays() abort[J

line 162: [J

line 163: let g:ale_has_override = get(g:, 'ale_has_override', {})[J

line 164: [J

line 165: " Call has(), but check a global Dictionary so we can force flags on or off[J

line 166: " for testing purposes.[J

line 167: function! ale#Has(feature) abort[J

line 170: [J

line 171: " Given a buffer number and a variable name, look for that variable in the[J

line 172: " buffer scope, then in global scope. If the name does not exist in the global[J

line 173: " scope, an exception will be thrown.[J

line 174: "[J

line 175: " Every variable name will be prefixed with 'ale_'.[J

line 176: function! ale#Var(buffer, variable_name) abort[J

line 190: [J

line 191: " Initialize a variable with a default value, if it isn't already set.[J

line 192: "[J

line 193: " Every variable name will be prefixed with 'ale_'.[J

line 194: function! ale#Set(variable_name, default) abort[J

line 201: [J

line 202: " Escape a string suitably for each platform.[J

line 203: " shellescape does not work on Windows.[J

line 204: function! ale#Escape(str) abort[J

finished sourcing /home/patrick/.vim/bundle/ale/autoload/ale.vim[J
continuing in /home/patrick/.vim/bundle/ale/plugin/ale.vim[J
calling function ale#Set[J('fix_on_save', 0)

line 1:     let l:full_name = 'ale_' . a:variable_name[J

line 2:     let l:value = get(g:, l:full_name, a:default)[J

line 3:     let g:[l:full_name] = l:value[J

line 4: [J

line 5:     return l:value[J

function ale#Set returning #0[J

continuing in /home/patrick/.vim/bundle/ale/plugin/ale.vim[J

line 99: [J

line 100: " This flag may be set to 0 to disable ale. After ale is loaded, :ALEToggle[J

line 101: " should be used instead.[J

line 102: let g:ale_enabled = get(g:, 'ale_enabled', 1)[J

line 103: [J

line 104: " These flags dictates if ale uses the quickfix or the loclist (loclist is the[J

line 105: " default, quickfix overrides loclist).[J

line 106: let g:ale_set_loclist = get(g:, 'ale_set_loclist', 1)[J

line 107: let g:ale_set_quickfix = get(g:, 'ale_set_quickfix', 0)[J

line 108: [J

line 109: " This flag dictates if ale open the configured loclist[J

line 110: let g:ale_open_list = get(g:, 'ale_open_list', 0)[J

line 111: [J

line 112: " This flag dictates if ale keeps open loclist even if there is no error in loclist[J

line 113: let g:ale_keep_list_window_open = get(g:, 'ale_keep_list_window_open', 0)[J

line 114: [J

line 115: " The window size to set for the quickfix and loclist windows[J

line 116: call ale#Set('list_window_size', 10)[J

calling function ale#Set[J('list_window_size', 10)

line 1:     let l:full_name = 'ale_' . a:variable_name[J

line 2:     let l:value = get(g:, l:full_name, a:default)[J

line 3:     let g:[l:full_name] = l:value[J

line 4: [J

line 5:     return l:value[J

function ale#Set returning #10[J

continuing in /home/patrick/.vim/bundle/ale/plugin/ale.vim[J

line 117: [J

line 118: " This flag can be set to 0 to disable setting signs.[J

line 119: " This is enabled by default only if the 'signs' feature exists.[J

line 120: let g:ale_set_signs = get(g:, 'ale_set_signs', has('signs'))[J

line 121: [J

line 122: " This flag can be set to 1 to enable changing the sign column colors when[J

line 123: " there are errors.[J

line 124: call ale#Set('change_sign_column_color', 0)[J

calling function ale#Set[J('change_sign_column_color', 0)

line 1:     let l:full_name = 'ale_' . a:variable_name[J

line 2:     let l:value = get(g:, l:full_name, a:default)[J

line 3:     let g:[l:full_name] = l:value[J

line 4: [J

line 5:     return l:value[J

function ale#Set returning #0[J

continuing in /home/patrick/.vim/bundle/ale/plugin/ale.vim[J

line 125: [J

line 126: " This flag can be set to 0 to disable setting error highlights.[J

line 127: let g:ale_set_highlights = get(g:, 'ale_set_highlights', has('syntax'))[J

line 128: [J

line 129: " These variables dictate what sign is used to indicate errors and warnings.[J

line 130: call ale#Set('sign_error', '>>')[J

calling function ale#Set[J('sign_error', '>>')

line 1:     let l:full_name = 'ale_' . a:variable_name[J

line 2:     let l:value = get(g:, l:full_name, a:default)[J

line 3:     let g:[l:full_name] = l:value[J

line 4: [J

line 5:     return l:value[J

function ale#Set returning '>>'[J

continuing in /home/patrick/.vim/bundle/ale/plugin/ale.vim[J

line 131: call ale#Set('sign_style_error', g:ale_sign_error)[J

calling function ale#Set[J('sign_style_error', '>>')

line 1:     let l:full_name = 'ale_' . a:variable_name[J

line 2:     let l:value = get(g:, l:full_name, a:default)[J

line 3:     let g:[l:full_name] = l:value[J

line 4: [J

line 5:     return l:value[J

function ale#Set returning '>>'[J

continuing in /home/patrick/.vim/bundle/ale/plugin/ale.vim[J

line 132: call ale#Set('sign_warning', '--')[J

calling function ale#Set[J('sign_warning', '--')

line 1:     let l:full_name = 'ale_' . a:variable_name[J

line 2:     let l:value = get(g:, l:full_name, a:default)[J

line 3:     let g:[l:full_name] = l:value[J

line 4: [J

line 5:     return l:value[J

function ale#Set returning '--'[J

continuing in /home/patrick/.vim/bundle/ale/plugin/ale.vim[J

line 133: call ale#Set('sign_style_warning', g:ale_sign_warning)[J

calling function ale#Set[J('sign_style_warning', '--')

line 1:     let l:full_name = 'ale_' . a:variable_name[J

line 2:     let l:value = get(g:, l:full_name, a:default)[J

line 3:     let g:[l:full_name] = l:value[J

line 4: [J

line 5:     return l:value[J

function ale#Set returning '--'[J

continuing in /home/patrick/.vim/bundle/ale/plugin/ale.vim[J

line 134: call ale#Set('sign_info', g:ale_sign_warning)[J

calling function ale#Set[J('sign_info', '--')

line 1:     let l:full_name = 'ale_' . a:variable_name[J

line 2:     let l:value = get(g:, l:full_name, a:default)[J

line 3:     let g:[l:full_name] = l:value[J

line 4: [J

line 5:     return l:value[J

function ale#Set returning '--'[J

continuing in /home/patrick/.vim/bundle/ale/plugin/ale.vim[J

line 135: [J

line 136: " This variable sets an offset which can be set for sign IDs.[J

line 137: " This ID can be changed depending on what IDs are set for other plugins.[J

line 138: " The dummy sign will use the ID exactly equal to the offset.[J

line 139: let g:ale_sign_offset = get(g:, 'ale_sign_offset', 1000000)[J

line 140: [J

line 141: " This flag can be set to 1 to keep sign gutter always open[J

line 142: let g:ale_sign_column_always = get(g:, 'ale_sign_column_always', 0)[J

line 143: [J

line 144: " String format for the echoed message[J

line 145: " A %s is mandatory[J

line 146: " It can contain 2 handlers: %linter%, %severity%[J

line 147: let g:ale_echo_msg_format = get(g:, 'ale_echo_msg_format', '%s')[J

line 148: [J

line 149: " Strings used for severity in the echoed message[J

line 150: let g:ale_echo_msg_error_str = get(g:, 'ale_echo_msg_error_str', 'Error')[J

line 151: let g:ale_echo_msg_warning_str = get(g:, 'ale_echo_msg_warning_str', 'Warning')[J

line 152: [J

line 153: " This flag can be set to 0 to disable echoing when the cursor moves.[J

line 154: let g:ale_echo_cursor = get(g:, 'ale_echo_cursor', 1)[J

line 155: [J

line 156: " This flag can be set to 0 to disable balloon support.[J

line 157: call ale#Set('set_balloons', has('balloon_eval'))[J

calling function ale#Set[J('set_balloons', 0)

line 1:     let l:full_name = 'ale_' . a:variable_name[J

line 2:     let l:value = get(g:, l:full_name, a:default)[J

line 3:     let g:[l:full_name] = l:value[J

line 4: [J

line 5:     return l:value[J

function ale#Set returning #0[J

continuing in /home/patrick/.vim/bundle/ale/plugin/ale.vim[J

line 158: [J

line 159: " A deprecated setting for ale#statusline#Status()[J

line 160: " See :help ale#statusline#Count() for getting status reports.[J

line 163: let g:ale_statusline_format = get(g:, 'ale_statusline_format',   ['%d error(s)', '%d warning(s)', 'OK'])[J

line 164: [J

line 165: " This flag can be set to 0 to disable warnings for trailing whitespace[J

line 167: let g:ale_warn_about_trailing_whitespace =   get(g:, 'ale_warn_about_trailing_whitespace', 1)[J

line 168: [J

line 169: " A flag for controlling the maximum size of the command history to store.[J

line 170: let g:ale_max_buffer_history_size = get(g:, 'ale_max_buffer_history_size', 20)[J

line 171: [J

line 172: " A flag for enabling or disabling the command history.[J

line 173: let g:ale_history_enabled = get(g:, 'ale_history_enabled', 1)[J

line 174: [J

line 175: " A flag for storing the full output of commands in the history.[J

line 176: let g:ale_history_log_output = get(g:, 'ale_history_log_output', 1)[J

line 177: [J

line 178: " A dictionary mapping regular expression patterns to arbitrary buffer[J

line 179: " variables to be set. Useful for configuration ALE based on filename[J

line 180: " patterns.[J

line 181: call ale#Set('pattern_options', {})[J

calling function ale#Set[J('pattern_options', {})

line 1:     let l:full_name = 'ale_' . a:variable_name[J

line 2:     let l:value = get(g:, l:full_name, a:default)[J

line 3:     let g:[l:full_name] = l:value[J

line 4: [J

line 5:     return l:value[J

function ale#Set returning {}[J

continuing in /home/patrick/.vim/bundle/ale/plugin/ale.vim[J

line 182: call ale#Set('pattern_options_enabled', !empty(g:ale_pattern_options))[J

calling function ale#Set[J('pattern_options_enabled', 0)

line 1:     let l:full_name = 'ale_' . a:variable_name[J

line 2:     let l:value = get(g:, l:full_name, a:default)[J

line 3:     let g:[l:full_name] = l:value[J

line 4: [J

line 5:     return l:value[J

function ale#Set returning #0[J

continuing in /home/patrick/.vim/bundle/ale/plugin/ale.vim[J

line 183: [J

line 184: " A maximum file size for checking for errors.[J

line 185: call ale#Set('maximum_file_size', 0)[J

calling function ale#Set[J('maximum_file_size', 0)

line 1:     let l:full_name = 'ale_' . a:variable_name[J

line 2:     let l:value = get(g:, l:full_name, a:default)[J

line 3:     let g:[l:full_name] = l:value[J

line 4: [J

line 5:     return l:value[J

function ale#Set returning #0[J

continuing in /home/patrick/.vim/bundle/ale/plugin/ale.vim[J

line 186: [J

line 187: " Remapping of linter problems.[J

line 188: call ale#Set('type_map', {})[J

calling function ale#Set[J('type_map', {})

line 1:     let l:full_name = 'ale_' . a:variable_name[J

line 2:     let l:value = get(g:, l:full_name, a:default)[J

line 3:     let g:[l:full_name] = l:value[J

line 4: [J

line 5:     return l:value[J

function ale#Set returning {}[J

continuing in /home/patrick/.vim/bundle/ale/plugin/ale.vim[J

line 189: [J

line 190: " Enable automatic completion with LSP servers and tsserver[J

line 191: call ale#Set('completion_enabled', 0)[J

calling function ale#Set[J('completion_enabled', 0)

line 1:     let l:full_name = 'ale_' . a:variable_name[J

line 2:     let l:value = get(g:, l:full_name, a:default)[J

line 3:     let g:[l:full_name] = l:value[J

line 4: [J

line 5:     return l:value[J

function ale#Set returning #0[J

continuing in /home/patrick/.vim/bundle/ale/plugin/ale.vim[J

line 192: call ale#Set('completion_delay', 100)[J

calling function ale#Set[J('completion_delay', 100)

line 1:     let l:full_name = 'ale_' . a:variable_name[J

line 2:     let l:value = get(g:, l:full_name, a:default)[J

line 3:     let g:[l:full_name] = l:value[J

line 4: [J

line 5:     return l:value[J

function ale#Set returning #100[J

continuing in /home/patrick/.vim/bundle/ale/plugin/ale.vim[J

line 193: call ale#Set('completion_max_suggestions', 50)[J

calling function ale#Set[J('completion_max_suggestions', 50)

line 1:     let l:full_name = 'ale_' . a:variable_name[J

line 2:     let l:value = get(g:, l:full_name, a:default)[J

line 3:     let g:[l:full_name] = l:value[J

line 4: [J

line 5:     return l:value[J

function ale#Set returning #50[J

continuing in /home/patrick/.vim/bundle/ale/plugin/ale.vim[J

line 194: [J

line 195: function! ALEInitAuGroups() abort[J

line 281: [J

line 282: function! s:ALEToggle() abort[J

line 323: [J

line 324: call ALEInitAuGroups()[J

calling function ALEInitAuGroups[J()

line 1:     " This value used to be a Boolean as a Number, and is now a String.[J

line 2:     let l:text_changed = '' . g:ale_lint_on_text_changed[J

line 3: [J

line 4:     augroup ALEPatternOptionsGroup[J

line 5:         autocmd![J

line 6:         if g:ale_enabled && g:ale_pattern_options_enabled[J

line 7:             autocmd BufEnter,BufRead * call ale#pattern_options#SetOptions()[J

line 8:         endif[J

line 9:     augroup END[J

line 10: [J

line 11:     augroup ALERunOnTextChangedGroup[J

line 12:         autocmd![J

line 13:         if g:ale_enabled[J

line 14:             if l:text_changed is? 'always' || l:text_changed is# '1'[J

line 15:                 autocmd TextChanged,TextChangedI * call ale#Queue(g:ale_lint_delay)[J

line 16:             elseif l:text_changed is? 'normal'[J

line 17:                 autocmd TextChanged * call ale#Queue(g:ale_lint_delay)[J

line 18:             elseif l:text_changed is? 'insert'[J

line 19:                 autocmd TextChangedI * call ale#Queue(g:ale_lint_delay)[J

line 20:             endif[J

line 21:         endif[J

line 22:     augroup END[J

line 23: [J

line 24:     augroup ALERunOnEnterGroup[J

line 25:         autocmd![J

line 26:         if g:ale_enabled[J

line 27:             " Handle everything that needs to happen when buffers are entered.[J

line 28:             autocmd BufEnter * call ale#events#EnterEvent(str2nr(expand('<abuf>')))[J

line 29:         endif[J

line 30:         if g:ale_enabled && g:ale_lint_on_enter[J

line 31:             autocmd BufWinEnter,BufRead * call ale#Queue(0, 'lint_file', str2nr(expand('<abuf>')))[J

line 32:             " Track when the file is changed outside of Vim.[J

line 33:             autocmd FileChangedShellPost * call ale#events#FileChangedEvent(str2nr(expand('<abuf>')))[J

line 34:         endif[J

line 35:     augroup END[J

line 36: [J

line 37:     augroup ALERunOnFiletypeChangeGroup[J

line 38:         autocmd![J

line 39:         if g:ale_enabled && g:ale_lint_on_filetype_changed[J

line 40:             " Only start linting if the FileType actually changes after[J

line 41:             " opening a buffer. The FileType will fire when buffers are opened.[J

line 42:             autocmd FileType * call ale#events#FileTypeEvent(   str2nr(expand('<abuf>')),   expand('<amatch>'))[J

line 46:         endif[J

line 47:     augroup END[J

line 48: [J

line 49:     augroup ALERunOnSaveGroup[J

line 50:         autocmd![J

line 51:         if (g:ale_enabled && g:ale_lint_on_save) || g:ale_fix_on_save[J

line 52:             autocmd BufWritePost * call ale#events#SaveEvent(str2nr(expand('<abuf>')))[J

line 53:         endif[J

line 54:     augroup END[J

line 55: [J

line 56:     augroup ALERunOnInsertLeave[J

line 57:         autocmd![J

line 58:         if g:ale_enabled && g:ale_lint_on_insert_leave[J

line 59:             autocmd InsertLeave * call ale#Queue(0)[J

line 60:         endif[J

line 61:     augroup END[J

line 62: [J

line 63:     augroup ALECursorGroup[J

line 64:         autocmd![J

line 65:         if g:ale_enabled && g:ale_echo_cursor[J

line 66:             autocmd CursorMoved,CursorHold * call ale#cursor#EchoCursorWarningWithDelay()[J

line 67:             " Look for a warning to echo as soon as we leave Insert mode.[J

line 68:             " The script's position variable used when moving the cursor will[J

line 69:             " not be changed here.[J

line 70:             autocmd InsertLeave * call ale#cursor#EchoCursorWarning()[J

line 71:         endif[J

line 72:     augroup END[J

line 73: [J

line 74:     if !g:ale_enabled[J

line 75:         if !g:ale_fix_on_save[J

line 76:             augroup! ALERunOnSaveGroup[J

line 77:         endif[J

line 78: [J

line 79:         augroup! ALEPatternOptionsGroup[J

line 80:         augroup! ALERunOnTextChangedGroup[J

line 81:         augroup! ALERunOnEnterGroup[J

line 82:         augroup! ALERunOnInsertLeave[J

line 83:         augroup! ALECursorGroup[J

line 84:     endif[J

function ALEInitAuGroups returning #0[J

continuing in /home/patrick/.vim/bundle/ale/plugin/ale.vim[J

line 325: [J

line 326: if g:ale_set_balloons[J

line 327:     call ale#balloon#Enable()[J

line 328: endif[J

line 329: [J

line 330: if g:ale_completion_enabled[J

line 331:     call ale#completion#Enable()[J

line 332: endif[J

line 333: [J

line 334: " Define commands for moving through warnings and errors.[J

line 335: command! -bar ALEPrevious :call ale#loclist_jumping#Jump('before', 0)[J

line 336: command! -bar ALEPreviousWrap :call ale#loclist_jumping#Jump('before', 1)[J

line 337: command! -bar ALENext :call ale#loclist_jumping#Jump('after', 0)[J

line 338: command! -bar ALENextWrap :call ale#loclist_jumping#Jump('after', 1)[J

line 339: command! -bar ALEFirst :call ale#loclist_jumping#JumpToIndex(0)[J

line 340: command! -bar ALELast :call ale#loclist_jumping#JumpToIndex(-1)[J

line 341: [J

line 342: " A command for showing error details.[J

line 343: command! -bar ALEDetail :call ale#cursor#ShowCursorDetail()[J

line 344: [J

line 345: " Define commands for turning ALE on or off.[J

line 346: command! -bar ALEToggle :call s:ALEToggle()[J

line 347: command! -bar ALEEnable :if !g:ale_enabled | ALEToggle | endif[J

line 348: command! -bar ALEDisable :if g:ale_enabled | ALEToggle | endif[J

line 349: [J

line 350: " A command for linting manually.[J

line 351: command! -bar ALELint :call ale#Queue(0, 'lint_file')[J

line 352: [J

line 353: " Define a command to get information about current filetype.[J

line 354: command! -bar ALEInfo :call ale#debugging#Info()[J

line 355: " The same, but copy output to your clipboard.[J

line 356: command! -bar ALEInfoToClipboard :call ale#debugging#InfoToClipboard()[J

line 357: [J

line 358: " Fix problems in files.[J

line 359: command! -bar ALEFix :call ale#fix#Fix()[J

line 360: " Suggest registered functions to use for fixing problems.[J

line 361: command! -bar ALEFixSuggest :call ale#fix#registry#Suggest(&filetype)[J

line 362: [J

line 363: " <Plug> mappings for commands[J

line 364: nnoremap <silent> <Plug>(ale_previous) :ALEPrevious<Return>[J

line 365: nnoremap <silent> <Plug>(ale_previous_wrap) :ALEPreviousWrap<Return>[J

line 366: nnoremap <silent> <Plug>(ale_next) :ALENext<Return>[J

line 367: nnoremap <silent> <Plug>(ale_next_wrap) :ALENextWrap<Return>[J

line 368: nnoremap <silent> <Plug>(ale_first) :ALEFirst<Return>[J

line 369: nnoremap <silent> <Plug>(ale_last) :ALELast<Return>[J

line 370: nnoremap <silent> <Plug>(ale_toggle) :ALEToggle<Return>[J

line 371: nnoremap <silent> <Plug>(ale_lint) :ALELint<Return>[J

line 372: nnoremap <silent> <Plug>(ale_detail) :ALEDetail<Return>[J

line 373: nnoremap <silent> <Plug>(ale_fix) :ALEFix<Return>[J

line 374: [J

line 375: " Housekeeping[J

line 376: [J

line 377: augroup ALECleanupGroup[J

line 378:     autocmd![J

line 379:     " Clean up buffers automatically when they are unloaded.[J

line 380:     autocmd BufUnload * call ale#engine#Cleanup(str2nr(expand('<abuf>')))[J

line 381: augroup END[J

line 382: [J

line 383: " Backwards Compatibility[J

line 384: [J

line 385: function! ALELint(delay) abort[J

line 388: [J

line 389: function! ALEGetStatusLine() abort[J

finished sourcing /home/patrick/.vim/bundle/ale/plugin/ale.vim[J
Searching for "/home/patrick/.vim/bundle/tabular/plugin/**/*.vim"[J
chdir(/home/patrick/.vim/bundle/tabular/plugin)[J
fchdir() to previous dir[J
sourcing "/home/patrick/.vim/bundle/tabular/plugin/Tabular.vim"[J
line 1: " Tabular:     Align columnar data using regex-designated column boundaries[J

line 2: " Maintainer:  Matthew Wozniski (godlygeek@gmail.com)[J

line 3: " Date:        Thu, 03 May 2012 20:49:32 -0400[J

line 4: " Version:     1.0[J

line 5: "[J

line 6: " Long Description:[J

line 7: " Sometimes, it's useful to line up text.  Naturally, it's nicer to have the[J

line 8: " computer do this for you, since aligning things by hand quickly becomes[J

line 9: " unpleasant.  While there are other plugins for aligning text, the ones I've[J

line 10: " tried are either impossibly difficult to understand and use, or too simplistic[J

line 11: " to handle complicated tasks.  This plugin aims to make the easy things easy[J

line 12: " and the hard things possible, without providing an unnecessarily obtuse[J

line 13: " interface.  It's still a work in progress, and criticisms are welcome.[J

line 14: "[J

line 15: " License:[J

line 16: " Copyright (c) 2012, Matthew J. Wozniski[J

line 17: " All rights reserved.[J

line 18: "[J

line 19: " Redistribution and use in source and binary forms, with or without[J

line 20: " modification, are permitted provided that the following conditions are met:[J

line 21: "     * Redistributions of source code must retain the above copyright notice,[J

line 22: "       this list of conditions and the following disclaimer.[J

line 23: "     * Redistributions in binary form must reproduce the above copyright[J

line 24: "       notice, this list of conditions and the following disclaimer in the[J

line 25: "       documentation and/or other materials provided with the distribution.[J

line 26: "     * The names of the contributors may not be used to endorse or promote[J

line 27: "       products derived from this software without specific prior written[J

line 28: "       permission.[J

line 29: "[J

line 30: " THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER ``AS IS'' AND ANY EXPRESS[J

line 31: " OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES[J

line 32: " OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN[J

line 33: " NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY DIRECT, INDIRECT,[J

line 34: " INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT[J

line 35: " LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,[J

line 36: " OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF[J

line 37: " LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING[J

line 38: " NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,[J

line 39: " EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.[J

line 40: [J

line 41: " Abort if running in vi-compatible mode or the user doesn't want us.[J

line 42: if &cp || exists('g:tabular_loaded')[J

line 43:   if &cp && &verbose[J

line 44:     echo "Not loading Tabular in compatible mode."[J

line 45:   endif[J

line 46:   finish[J

line 47: endif[J

line 48: [J

line 49: let g:tabular_loaded = 1[J

line 50: [J

line 51: " Stupid vimscript crap                                                   {{{1[J

line 52: let s:savecpo = &cpo[J

line 53: set cpo&vim[J

line 54: [J

line 55: " Private Things                                                          {{{1[J

line 56: [J

line 57: " Dictionary of command name to command[J

line 58: let s:TabularCommands = {}[J

line 59: [J

line 60: " Generate tab completion list for :Tabularize                            {{{2[J

line 61: " Return a list of commands that match the command line typed so far.[J

line 62: " NOTE: Tries to handle commands with spaces in the name, but Vim doesn't seem[J

line 63: "       to handle that terribly well... maybe I should give up on that.[J

line 64: function! s:CompleteTabularizeCommand(argstart, cmdline, cursorpos)[J

line 74: [J

line 75: " Choose the proper command map from the given command line               {{{2[J

line 76: " Returns [ command map, command line with leading <buffer> removed ][J

line 77: function! s:ChooseCommandMap(commandline)[J

line 91: [J

line 92: " Parse '/pattern/format' into separate pattern and format parts.         {{{2[J

line 93: " If parsing fails, return [ '', '' ][J

line 94: function! s:ParsePattern(string)[J

line 110: [J

line 111: " Split apart a list of | separated expressions.                          {{{2[J

line 112: function! s:SplitCommands(string)[J

line 152: [J

line 153: " Public Things                                                           {{{1[J

line 154: [J

line 155: " Command associating a command name with a simple pattern command        {{{2[J

line 156: " AddTabularPattern[!] [<buffer>] name /pattern[/format][J

line 157: "[J

line 158: " If <buffer> is provided, the command will only be available in the current[J

line 159: " buffer, and will be used instead of any global command with the same name.[J

line 160: "[J

line 161: " If a command with the same name and scope already exists, it is an error,[J

line 162: " unless the ! is provided, in which case the existing command will be[J

line 163: " replaced.[J

line 164: "[J

line 165: " pattern is a regex describing the delimiter to be used.[J

line 166: "[J

line 167: " format describes the format pattern to be used.  The default will be used if[J

line 168: " none is provided.[J

line 170: com! -nargs=+ -bang AddTabularPattern call AddTabularPattern(<q-args>, <bang>0)[J

line 171: [J

line 172: function! AddTabularPattern(command, force)[J

line 204: [J

line 205: " Command associating a command name with a pipeline of functions         {{{2[J

line 206: " AddTabularPipeline[!] [<buffer>] name /pattern/ func [ | func2 [ | func3 ] ][J

line 207: "[J

line 208: " If <buffer> is provided, the command will only be available in the current[J

line 209: " buffer, and will be used instead of any global command with the same name.[J

line 210: "[J

line 211: " If a command with the same name and scope already exists, it is an error,[J

line 212: " unless the ! is provided, in which case the existing command will be[J

line 213: " replaced.[J

line 214: "[J

line 215: " pattern is a regex that will be used to determine which lines will be[J

line 216: " filtered.  If the cursor line doesn't match the pattern, using the command[J

line 217: " will be a no-op, otherwise the cursor and all contiguous lines matching the[J

line 218: " pattern will be filtered.[J

line 219: "[J

line 220: " Each 'func' argument represents a function to be called.  This function[J

line 221: " will have access to a:lines, a List containing one String per line being[J

line 222: " filtered.[J

line 224: com! -nargs=+ -bang AddTabularPipeline call AddTabularPipeline(<q-args>, <bang>0)[J

line 225: [J

line 226: function! AddTabularPipeline(command, force)[J

line 257: [J

line 258: " Tabularize /pattern[/format]                                            {{{2[J

line 259: " Tabularize name[J

line 260: "[J

line 261: " Align text, either using the given pattern, or the command associated with[J

line 262: " the given name.[J

line 264: com! -nargs=* -range -complete=customlist,<SID>CompleteTabularizeCommand Tabularize <line1>,<line2>call Tabularize(<q-args>)[J

line 265: [J

line 266: function! Tabularize(command, ...) range[J

line 320: [J

line 321: " GTabularize /pattern[/format]                                           {{{2[J

line 322: " GTabularize name[J

line 323: "[J

line 324: " Align text on only matching lines, either using the given pattern, or the[J

line 325: " command associated with the given name.  Mnemonically, this is similar to[J

line 326: " the :global command, which takes some action on all rows matching a pattern[J

line 327: " in a range.  This command is different from normal :Tabularize in 3 ways:[J

line 328: "   1) If a line in the range does not match the pattern, it will be left[J

line 329: "      unchanged, and not in any way affect the outcome of other lines in the[J

line 330: "      range (at least, normally - but Pipelines can and will still look at[J

line 331: "      non-matching rows unless they are specifically written to be aware of[J

line 332: "      tabular#DoGTabularize() and handle it appropriately).[J

line 333: "   2) No automatic range determination - :Tabularize automatically expands[J

line 334: "      a single-line range (or a call with no range) to include all adjacent[J

line 335: "      matching lines.  That behavior does not make sense for this command.[J

line 336: "   3) If called without a range, it will act on all lines in the buffer (like[J

line 337: "      :global) rather than only a single line[J

line 340: com! -nargs=* -range=% -complete=customlist,<SID>CompleteTabularizeCommand GTabularize <line1>,<line2> call Tabularize(<q-args>, { 'mode': 'GTabularize' } )[J

line 341: [J

line 342: " Stupid vimscript crap, part 2                                           {{{1[J

line 343: let &cpo = s:savecpo[J

line 344: unlet s:savecpo[J

line 345: [J

line 346: " vim:set sw=2 sts=2 fdm=marker:[J

finished sourcing /home/patrick/.vim/bundle/tabular/plugin/Tabular.vim[J
Searching for "/home/patrick/.vim/bundle/vim-table-mode/plugin/**/*.vim"[J
chdir(/home/patrick/.vim/bundle/vim-table-mode/plugin)[J
fchdir() to previous dir[J
sourcing "/home/patrick/.vim/bundle/vim-table-mode/plugin/table-mode.vim"[J
line 1: " Finish if already loaded {{{1[J

line 2: if exists('g:loaded_table_mode')[J

line 3:   finish[J

line 4: endif[J

line 5: let g:loaded_table_mode = 1[J

line 6: [J

line 7: " Avoiding side effects {{{1[J

line 8: let s:save_cpo = &cpo[J

line 9: set cpo&vim[J

line 10: [J

line 11: function! s:SetGlobalOptDefault(opt, val) "{{{1[J

line 16: [J

line 17: " Set Global Defaults {{{1[J

line 18: call s:SetGlobalOptDefault('table_mode_corner', '+')[J

calling function <SNR>42_SetGlobalOptDefault[J('table_mode_corner', '+')

line 1:   if !exists('g:' . a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>42_SetGlobalOptDefault returning #0[J

continuing in /home/patrick/.vim/bundle/vim-table-mode/plugin/table-mode.vim[J

line 19: call s:SetGlobalOptDefault('table_mode_verbose', 1)[J

calling function <SNR>42_SetGlobalOptDefault[J('table_mode_verbose', 1)

line 1:   if !exists('g:' . a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>42_SetGlobalOptDefault returning #0[J

continuing in /home/patrick/.vim/bundle/vim-table-mode/plugin/table-mode.vim[J

line 20: call s:SetGlobalOptDefault('table_mode_separator', '|')[J

calling function <SNR>42_SetGlobalOptDefault[J('table_mode_separator', '|')

line 1:   if !exists('g:' . a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>42_SetGlobalOptDefault returning #0[J

continuing in /home/patrick/.vim/bundle/vim-table-mode/plugin/table-mode.vim[J

line 21: call s:SetGlobalOptDefault('table_mode_fillchar', '-')[J

calling function <SNR>42_SetGlobalOptDefault[J('table_mode_fillchar', '-')

line 1:   if !exists('g:' . a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>42_SetGlobalOptDefault returning #0[J

continuing in /home/patrick/.vim/bundle/vim-table-mode/plugin/table-mode.vim[J

line 22: call s:SetGlobalOptDefault('table_mode_header_fillchar', '-')[J

calling function <SNR>42_SetGlobalOptDefault[J('table_mode_header_fillchar', '-')

line 1:   if !exists('g:' . a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>42_SetGlobalOptDefault returning #0[J

continuing in /home/patrick/.vim/bundle/vim-table-mode/plugin/table-mode.vim[J

line 23: call s:SetGlobalOptDefault('table_mode_map_prefix', '<Leader>t')[J

calling function <SNR>42_SetGlobalOptDefault[J('table_mode_map_prefix', '<Leader>t')

line 1:   if !exists('g:' . a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>42_SetGlobalOptDefault returning #0[J

continuing in /home/patrick/.vim/bundle/vim-table-mode/plugin/table-mode.vim[J

line 24: call s:SetGlobalOptDefault('table_mode_toggle_map', 'm')[J

calling function <SNR>42_SetGlobalOptDefault[J('table_mode_toggle_map', 'm')

line 1:   if !exists('g:' . a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>42_SetGlobalOptDefault returning #0[J

continuing in /home/patrick/.vim/bundle/vim-table-mode/plugin/table-mode.vim[J

line 25: call s:SetGlobalOptDefault('table_mode_always_active', 0)[J

calling function <SNR>42_SetGlobalOptDefault[J('table_mode_always_active', 0)

line 1:   if !exists('g:' . a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>42_SetGlobalOptDefault returning #0[J

continuing in /home/patrick/.vim/bundle/vim-table-mode/plugin/table-mode.vim[J

line 26: call s:SetGlobalOptDefault('table_mode_delimiter', ',')[J

calling function <SNR>42_SetGlobalOptDefault[J('table_mode_delimiter', ',')

line 1:   if !exists('g:' . a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>42_SetGlobalOptDefault returning #0[J

continuing in /home/patrick/.vim/bundle/vim-table-mode/plugin/table-mode.vim[J

line 27: call s:SetGlobalOptDefault('table_mode_corner_corner', '|')[J

calling function <SNR>42_SetGlobalOptDefault[J('table_mode_corner_corner', '|')

line 1:   if !exists('g:' . a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>42_SetGlobalOptDefault returning #0[J

continuing in /home/patrick/.vim/bundle/vim-table-mode/plugin/table-mode.vim[J

line 28: call s:SetGlobalOptDefault('table_mode_align_char', ':')[J

calling function <SNR>42_SetGlobalOptDefault[J('table_mode_align_char', ':')

line 1:   if !exists('g:' . a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>42_SetGlobalOptDefault returning #0[J

continuing in /home/patrick/.vim/bundle/vim-table-mode/plugin/table-mode.vim[J

line 29: call s:SetGlobalOptDefault('table_mode_disable_mappings', 0)[J

calling function <SNR>42_SetGlobalOptDefault[J('table_mode_disable_mappings', 0)

line 1:   if !exists('g:' . a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>42_SetGlobalOptDefault returning #0[J

continuing in /home/patrick/.vim/bundle/vim-table-mode/plugin/table-mode.vim[J

line 30: [J

line 31: call s:SetGlobalOptDefault('table_mode_motion_up_map', '{<Bar>')[J

calling function <SNR>42_SetGlobalOptDefault[J('table_mode_motion_up_map', '{<Bar>')

line 1:   if !exists('g:' . a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>42_SetGlobalOptDefault returning #0[J

continuing in /home/patrick/.vim/bundle/vim-table-mode/plugin/table-mode.vim[J

line 32: call s:SetGlobalOptDefault('table_mode_motion_down_map', '}<Bar>')[J

calling function <SNR>42_SetGlobalOptDefault[J('table_mode_motion_down_map', '}<Bar>')

line 1:   if !exists('g:' . a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>42_SetGlobalOptDefault returning #0[J

continuing in /home/patrick/.vim/bundle/vim-table-mode/plugin/table-mode.vim[J

line 33: call s:SetGlobalOptDefault('table_mode_motion_left_map', '[<Bar>')[J

calling function <SNR>42_SetGlobalOptDefault[J('table_mode_motion_left_map', '[<Bar>')

line 1:   if !exists('g:' . a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>42_SetGlobalOptDefault returning #0[J

continuing in /home/patrick/.vim/bundle/vim-table-mode/plugin/table-mode.vim[J

line 34: call s:SetGlobalOptDefault('table_mode_motion_right_map', ']<Bar>')[J

calling function <SNR>42_SetGlobalOptDefault[J('table_mode_motion_right_map', ']<Bar>')

line 1:   if !exists('g:' . a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>42_SetGlobalOptDefault returning #0[J

continuing in /home/patrick/.vim/bundle/vim-table-mode/plugin/table-mode.vim[J

line 35: [J

line 36: call s:SetGlobalOptDefault('table_mode_cell_text_object_a_map', 'a<Bar>')[J

calling function <SNR>42_SetGlobalOptDefault[J('table_mode_cell_text_object_a_map', 'a<Bar>')

line 1:   if !exists('g:' . a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>42_SetGlobalOptDefault returning #0[J

continuing in /home/patrick/.vim/bundle/vim-table-mode/plugin/table-mode.vim[J

line 37: call s:SetGlobalOptDefault('table_mode_cell_text_object_i_map', 'i<Bar>')[J

calling function <SNR>42_SetGlobalOptDefault[J('table_mode_cell_text_object_i_map', 'i<Bar>')

line 1:   if !exists('g:' . a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>42_SetGlobalOptDefault returning #0[J

continuing in /home/patrick/.vim/bundle/vim-table-mode/plugin/table-mode.vim[J

line 38: [J

line 39: call s:SetGlobalOptDefault('table_mode_realign_map', '<Leader>tr')[J

calling function <SNR>42_SetGlobalOptDefault[J('table_mode_realign_map', '<Leader>tr')

line 1:   if !exists('g:' . a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>42_SetGlobalOptDefault returning #0[J

continuing in /home/patrick/.vim/bundle/vim-table-mode/plugin/table-mode.vim[J

line 40: call s:SetGlobalOptDefault('table_mode_delete_row_map', '<Leader>tdd')[J

calling function <SNR>42_SetGlobalOptDefault[J('table_mode_delete_row_map', '<Leader>tdd')

line 1:   if !exists('g:' . a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>42_SetGlobalOptDefault returning #0[J

continuing in /home/patrick/.vim/bundle/vim-table-mode/plugin/table-mode.vim[J

line 41: call s:SetGlobalOptDefault('table_mode_delete_column_map', '<Leader>tdc')[J

calling function <SNR>42_SetGlobalOptDefault[J('table_mode_delete_column_map', '<Leader>tdc')

line 1:   if !exists('g:' . a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>42_SetGlobalOptDefault returning #0[J

continuing in /home/patrick/.vim/bundle/vim-table-mode/plugin/table-mode.vim[J

line 42: call s:SetGlobalOptDefault('table_mode_add_formula_map', '<Leader>tfa')[J

calling function <SNR>42_SetGlobalOptDefault[J('table_mode_add_formula_map', '<Leader>tfa')

line 1:   if !exists('g:' . a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>42_SetGlobalOptDefault returning #0[J

continuing in /home/patrick/.vim/bundle/vim-table-mode/plugin/table-mode.vim[J

line 43: call s:SetGlobalOptDefault('table_mode_eval_formula_map', '<Leader>tfe')[J

calling function <SNR>42_SetGlobalOptDefault[J('table_mode_eval_formula_map', '<Leader>tfe')

line 1:   if !exists('g:' . a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>42_SetGlobalOptDefault returning #0[J

continuing in /home/patrick/.vim/bundle/vim-table-mode/plugin/table-mode.vim[J

line 44: call s:SetGlobalOptDefault('table_mode_echo_cell_map', '<Leader>t?')[J

calling function <SNR>42_SetGlobalOptDefault[J('table_mode_echo_cell_map', '<Leader>t?')

line 1:   if !exists('g:' . a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>42_SetGlobalOptDefault returning #0[J

continuing in /home/patrick/.vim/bundle/vim-table-mode/plugin/table-mode.vim[J

line 45: call s:SetGlobalOptDefault('table_mode_sort_map', '<Leader>ts')[J

calling function <SNR>42_SetGlobalOptDefault[J('table_mode_sort_map', '<Leader>ts')

line 1:   if !exists('g:' . a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>42_SetGlobalOptDefault returning #0[J

continuing in /home/patrick/.vim/bundle/vim-table-mode/plugin/table-mode.vim[J

line 46: [J

line 47: call s:SetGlobalOptDefault('table_mode_syntax', 1)[J

calling function <SNR>42_SetGlobalOptDefault[J('table_mode_syntax', 1)

line 1:   if !exists('g:' . a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>42_SetGlobalOptDefault returning #0[J

continuing in /home/patrick/.vim/bundle/vim-table-mode/plugin/table-mode.vim[J

line 48: call s:SetGlobalOptDefault('table_mode_auto_align', 1)[J

calling function <SNR>42_SetGlobalOptDefault[J('table_mode_auto_align', 1)

line 1:   if !exists('g:' . a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>42_SetGlobalOptDefault returning #0[J

continuing in /home/patrick/.vim/bundle/vim-table-mode/plugin/table-mode.vim[J

line 49: call s:SetGlobalOptDefault('table_mode_update_time', 500)[J

calling function <SNR>42_SetGlobalOptDefault[J('table_mode_update_time', 500)

line 1:   if !exists('g:' . a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>42_SetGlobalOptDefault returning #0[J

continuing in /home/patrick/.vim/bundle/vim-table-mode/plugin/table-mode.vim[J

line 50: [J

line 51: function! s:TableEchoCell() "{{{1[J

line 56: [J

line 57: " Define Commands & Mappings {{{1[J

line 58: if !g:table_mode_always_active "{{{2[J

line 59:   exec "nnoremap <silent>" g:table_mode_map_prefix . g:table_mode_toggle_map ":<C-U>call tablemode#Toggle()<CR>"[J

line 59: nnoremap <silent> <Leader>tm :<C-U>call tablemode#Toggle()<CR>[J

line 60:   command! -nargs=0 TableModeToggle call tablemode#Toggle()[J

line 61:   command! -nargs=0 TableModeEnable call tablemode#Enable()[J

line 62:   command! -nargs=0 TableModeDisable call tablemode#Disable()[J

line 63: else[J

line 64:   let table_mode_separator_map = g:table_mode_separator[J

line 65:   " '|' is a special character, we need to map <Bar> instead[J

line 66:   if g:table_mode_separator ==# '|' | let table_mode_separator_map = '<Bar>' | endif[J

line 66:  let table_mode_separator_map = '<Bar>' | endif[J

line 66:  endif[J

line 67: [J

line 69:   execute "inoremap <silent> " . table_mode_separator_map . ' ' . table_mode_separator_map . "<Esc>:call tablemode#TableizeInsertMode()<CR>a"[J

line 70:   unlet table_mode_separator_map[J

line 71: endif[J

line 72: " }}}2[J

line 73: [J

line 74: command! -nargs=? -range Tableize <line1>,<line2>call tablemode#TableizeRange(<q-args>)[J

line 75: command! -nargs=? -bang TableSort call tablemode#spreadsheet#Sort(<bang>0, <q-args>)[J

line 76: command! TableAddFormula call tablemode#spreadsheet#formula#Add()[J

line 77: command! TableModeRealign call tablemode#table#Realign('.')[J

line 78: command! TableEvalFormulaLine call tablemode#spreadsheet#formula#EvaluateFormulaLine()[J

line 79: [J

line 80: " '|' is a special character, we need to map <Bar> instead[J

line 81: if g:table_mode_separator ==# '|' | let separator_map = '<Bar>' | endif[J

line 81:  let separator_map = '<Bar>' | endif[J

line 81:  endif[J

line 82: execute 'inoremap <silent> <Plug>(table-mode-tableize)' separator_map . '<Esc>:call tablemode#TableizeInsertMode()<CR>a'[J

line 82: inoremap <silent> <Plug>(table-mode-tableize) <Bar><Esc>:call tablemode#TableizeInsertMode()<CR>a[J

line 83: [J

line 84: nnoremap <silent> <Plug>(table-mode-tableize) :Tableize<CR>[J

line 85: xnoremap <silent> <Plug>(table-mode-tableize) :Tableize<CR>[J

line 86: xnoremap <silent> <Plug>(table-mode-tableize-delimiter) :<C-U>call tablemode#TableizeByDelimiter()<CR>[J

line 87: [J

line 88: nnoremap <silent> <Plug>(table-mode-realign) :call tablemode#table#Realign('.')<CR>[J

line 89: [J

line 90: nnoremap <silent> <Plug>(table-mode-motion-up) :<C-U>call tablemode#spreadsheet#cell#Motion('k')<CR>[J

line 91: nnoremap <silent> <Plug>(table-mode-motion-down) :<C-U>call tablemode#spreadsheet#cell#Motion('j')<CR>[J

line 92: nnoremap <silent> <Plug>(table-mode-motion-left) :<C-U>call tablemode#spreadsheet#cell#Motion('h')<CR>[J

line 93: nnoremap <silent> <Plug>(table-mode-motion-right) :<C-U>call tablemode#spreadsheet#cell#Motion('l')<CR>[J

line 94: [J

line 95: onoremap <silent> <Plug>(table-mode-cell-text-object-a) :<C-U>call tablemode#spreadsheet#cell#TextObject(0)<CR>[J

line 96: onoremap <silent> <Plug>(table-mode-cell-text-object-i) :<C-U>call tablemode#spreadsheet#cell#TextObject(1)<CR>[J

line 97: xnoremap <silent> <Plug>(table-mode-cell-text-object-a) :<C-U>call tablemode#spreadsheet#cell#TextObject(0)<CR>[J

line 98: xnoremap <silent> <Plug>(table-mode-cell-text-object-i) :<C-U>call tablemode#spreadsheet#cell#TextObject(1)<CR>[J

line 99: [J

line 100: nnoremap <silent> <Plug>(table-mode-delete-row) :call tablemode#spreadsheet#DeleteRow()<CR>[J

line 101: nnoremap <silent> <Plug>(table-mode-delete-column) :call tablemode#spreadsheet#DeleteColumn()<CR>[J

line 102: [J

line 103: nnoremap <silent> <Plug>(table-mode-add-formula) :call tablemode#spreadsheet#formula#Add()<CR>[J

line 104: nnoremap <silent> <Plug>(table-mode-eval-formula) :call tablemode#spreadsheet#formula#EvaluateFormulaLine()<CR>[J

line 105: [J

line 106: nnoremap <silent> <Plug>(table-mode-echo-cell) :call <SID>TableEchoCell()<CR>[J

line 107: [J

line 108: nnoremap <silent> <Plug>(table-mode-sort) :call tablemode#spreadsheet#Sort('')<CR>[J

line 109: [J

line 110: if !hasmapto('<Plug>(table-mode-tableize)')[J

line 111:   exec "nmap" g:table_mode_map_prefix . "t <Plug>(table-mode-tableize)"[J

line 111: nmap <Leader>tt <Plug>(table-mode-tableize)[J

line 112:   exec "xmap" g:table_mode_map_prefix . "t <Plug>(table-mode-tableize)"[J

line 112: xmap <Leader>tt <Plug>(table-mode-tableize)[J

line 113: endif[J

line 114: [J

line 115: if !hasmapto('<Plug>(table-mode-tableize-delimiter)')[J

line 116:   xmap <Leader>T <Plug>(table-mode-tableize-delimiter)[J

line 117: endif[J

line 118: [J

line 119: augroup TableMode "{{{1[J

line 120:   au![J

line 121: [J

line 122:   autocmd User TableModeEnabled call tablemode#logger#log('Table Mode Enabled')[J

line 123:   autocmd User TableModeDisabled call tablemode#logger#log('Table Mode Disabled')[J

line 124: augroup END[J

line 125: " Avoiding side effects {{{1[J

line 126: let &cpo = s:save_cpo[J

line 127: [J

line 128: " ModeLine {{{[J

line 129: " vim: sw=2 sts=2 fdl=0 fdm=marker[J

finished sourcing /home/patrick/.vim/bundle/vim-table-mode/plugin/table-mode.vim[J
Searching for "/var/lib/vim/addons/plugin/**/*.vim"[J
Searching for "/usr/share/vim/vimfiles/plugin/**/*.vim"[J
Searching for "/usr/share/vim/vim80/plugin/**/*.vim"[J
chdir(/usr/share/vim/vim80/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim80/plugin/getscriptPlugin.vim"[J
line 1: " ---------------------------------------------------------------------[J

line 2: " getscriptPlugin.vim[J

line 3: "  Author:^ICharles E. Campbell[J

line 4: "  Date:^INov 29, 2013[J

line 5: "  Installing:^I:help glvs-install[J

line 6: "  Usage:^I:help glvs[J

line 7: "[J

line 8: " GetLatestVimScripts: 642 1 :AutoInstall: getscript.vim[J

line 9: "[J

line 10: " (Rom 15:11 WEB) Again, "Praise the Lord, all you Gentiles!  Let[J

line 11: " all the peoples praise Him."[J

line 12: " ---------------------------------------------------------------------[J

line 13: " Initialization:^I{{{1[J

line 14: " if you're sourcing this file, surely you can't be[J

line 15: " expecting vim to be in its vi-compatible mode[J

line 16: if exists("g:loaded_getscriptPlugin")[J

line 17:  finish[J

line 18: endif[J

line 19: if &cp[J

line 20:  if &verbose[J

line 21:   echo "GetLatestVimScripts is not vi-compatible; not loaded (you need to set nocp)"[J

line 22:  endif[J

line 23:  finish[J

line 24: endif[J

line 25: let g:loaded_getscriptPlugin = "v36"[J

line 26: let s:keepcpo                = &cpo[J

line 27: set cpo&vim[J

line 28: [J

line 29: " ---------------------------------------------------------------------[J

line 30: "  Public Interface: {{{1[J

line 31: com!        -nargs=0 GetLatestVimScripts call getscript#GetLatestVimScripts()[J

line 32: com!        -nargs=0 GetScripts          call getscript#GetLatestVimScripts()[J

line 33: silent! com -nargs=0 GLVS                call getscript#GetLatestVimScripts()[J

line 34: [J

line 35: " ---------------------------------------------------------------------[J

line 36: " Restore Options: {{{1[J

line 37: let &cpo= s:keepcpo[J

line 38: unlet s:keepcpo[J

line 39: [J

line 40: " ---------------------------------------------------------------------[J

line 41: " vim: ts=8 sts=2 fdm=marker nowrap[J

finished sourcing /usr/share/vim/vim80/plugin/getscriptPlugin.vim[J
chdir(/usr/share/vim/vim80/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim80/plugin/gzip.vim"[J
line 1: " Vim plugin for editing compressed files.[J

line 2: " Maintainer: Bram Moolenaar <Bram@vim.org>[J

line 3: " Last Change: 2016 Oct 30[J

line 4: [J

line 5: " Exit quickly when:[J

line 6: " - this plugin was already loaded[J

line 7: " - when 'compatible' is set[J

line 8: " - some autocommands are already taking care of compressed files[J

line 9: if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")[J

line 10:   finish[J

line 11: endif[J

line 12: let loaded_gzip = 1[J

line 13: [J

line 14: augroup gzip[J

line 15:   " Remove all gzip autocommands[J

line 16:   au![J

line 17: [J

line 18:   " Enable editing of gzipped files.[J

line 19:   " The functions are defined in autoload/gzip.vim.[J

line 20:   "[J

line 21:   " Set binary mode before reading the file.[J

line 22:   " Use "gzip -d", gunzip isn't always available.[J

line 23:   autocmd BufReadPre,FileReadPre^I*.gz,*.bz2,*.Z,*.lzma,*.xz,*.lz,*.zst setlocal bin[J

line 24:   autocmd BufReadPost,FileReadPost^I*.gz  call gzip#read("gzip -dn")[J

line 25:   autocmd BufReadPost,FileReadPost^I*.bz2 call gzip#read("bzip2 -d")[J

line 26:   autocmd BufReadPost,FileReadPost^I*.Z   call gzip#read("uncompress")[J

line 27:   autocmd BufReadPost,FileReadPost^I*.lzma call gzip#read("lzma -d")[J

line 28:   autocmd BufReadPost,FileReadPost^I*.xz  call gzip#read("xz -d")[J

line 29:   autocmd BufReadPost,FileReadPost^I*.lz  call gzip#read("lzip -d")[J

line 30:   autocmd BufReadPost,FileReadPost^I*.zst call gzip#read("zstd -d --rm")[J

line 31:   autocmd BufWritePost,FileWritePost^I*.gz  call gzip#write("gzip")[J

line 32:   autocmd BufWritePost,FileWritePost^I*.bz2 call gzip#write("bzip2")[J

line 33:   autocmd BufWritePost,FileWritePost^I*.Z   call gzip#write("compress -f")[J

line 34:   autocmd BufWritePost,FileWritePost^I*.lzma call gzip#write("lzma -z")[J

line 35:   autocmd BufWritePost,FileWritePost^I*.xz  call gzip#write("xz -z")[J

line 36:   autocmd BufWritePost,FileWritePost^I*.lz  call gzip#write("lzip")[J

line 37:   autocmd BufWritePost,FileWritePost^I*.zst  call gzip#write("zstd --rm")[J

line 38:   autocmd FileAppendPre^I^I^I*.gz  call gzip#appre("gzip -dn")[J

line 39:   autocmd FileAppendPre^I^I^I*.bz2 call gzip#appre("bzip2 -d")[J

line 40:   autocmd FileAppendPre^I^I^I*.Z   call gzip#appre("uncompress")[J

line 41:   autocmd FileAppendPre^I^I^I*.lzma call gzip#appre("lzma -d")[J

line 42:   autocmd FileAppendPre^I^I^I*.xz   call gzip#appre("xz -d")[J

line 43:   autocmd FileAppendPre^I^I^I*.lz   call gzip#appre("lzip -d")[J

line 44:   autocmd FileAppendPre^I^I^I*.zst call gzip#appre("zstd -d --rm")[J

line 45:   autocmd FileAppendPost^I^I*.gz  call gzip#write("gzip")[J

line 46:   autocmd FileAppendPost^I^I*.bz2 call gzip#write("bzip2")[J

line 47:   autocmd FileAppendPost^I^I*.Z   call gzip#write("compress -f")[J

line 48:   autocmd FileAppendPost^I^I*.lzma call gzip#write("lzma -z")[J

line 49:   autocmd FileAppendPost^I^I*.xz call gzip#write("xz -z")[J

line 50:   autocmd FileAppendPost^I^I*.lz call gzip#write("lzip")[J

line 51:   autocmd FileAppendPost^I^I*.zst call gzip#write("zstd --rm")[J

line 52: augroup END[J

finished sourcing /usr/share/vim/vim80/plugin/gzip.vim[J
chdir(/usr/share/vim/vim80/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim80/plugin/logiPat.vim"[J
line 1: " LogiPat: Boolean logical pattern matcher[J

line 2: "   Author:  Charles E. Campbell[J

line 3: "   Date:    Apr 04, 2016[J

line 4: "   Version: 4[J

line 5: "   Purpose: to do Boolean-logic based regular expression pattern matching[J

line 6: " Copyright:    Copyright (C) 1999-2011 Charles E. Campbell {{{1[J

line 7: "               Permission is hereby granted to use and distribute this code,[J

line 8: "               with or without modifications, provided that this copyright[J

line 9: "               notice is copied with it. Like most anything else that's free,[J

line 10: "               LogiPat.vim is provided *as is* and comes with no warranty[J

line 11: "               of any kind, either expressed or implied. By using this[J

line 12: "               plugin, you agree that in no event will the copyright[J

line 13: "               holder be liable for any damages resulting from the use[J

line 14: "               of this software.[J

line 15: "[J

line 16: "   Usage: {{{1[J

line 17: "       :LogiPat ...[J

line 18: "[J

line 19: "         Boolean logic supported:[J

line 20: "            () grouping operators[J

line 21: "            !  not the following pattern[J

line 22: "            |  logical or[J

line 23: "            &  logical and[J

line 24: "            "..pattern.."[J

line 25: "^IExample: {{{1[J

line 26: "^I^I:LogiPat !("january"|"february")[J

line 27: "^I^I  would match all strings not containing the strings january[J

line 28: "^I^I  or february[J

line 29: "^IGetLatestVimScripts: 1290 1 :AutoInstall: LogiPat.vim[J

line 30: "[J

line 31: "  Behold, you will conceive in your womb, and bring forth a son, {{{1[J

line 32: "  and will call his name Jesus. He will be great, and will be[J

line 33: "  called the Son of the Most High. The Lord God will give him the[J

line 34: "  throne of his father, David, and he will reign over the house of[J

line 35: "  Jacob forever. There will be no end to his kingdom. (Luke 1:31-33 WEB)[J

line 36: [J

line 37: " ---------------------------------------------------------------------[J

line 38: " Load Once: {{{1[J

line 39: if &cp || exists("loaded_logiPat")[J

line 40:  finish[J

line 41: endif[J

line 42: let g:loaded_logiPat = "v4"[J

line 43: let s:keepcpo        = &cpo[J

line 44: set cpo&vim[J

line 45: "DechoRemOn[J

line 46: [J

line 47: " ---------------------------------------------------------------------[J

line 48: " Public Interface: {{{1[J

line 49: com!     -nargs=* LogiPat^I^Icall   LogiPat(<q-args>,1)[J

line 50: sil! com -nargs=* LP^I^I^Icall   LogiPat(<q-args>,1)[J

line 51: sil! com -nargs=* LPR^I^I^Icall   LogiPat(<q-args>,1,"r")[J

line 52: com!     -nargs=+ LPE^I^I^Iechomsg LogiPat(<q-args>)[J

line 53: com!     -nargs=+ LogiPatFlags^Ilet  s:LogiPatFlags="<args>"[J

line 54: sil! com -nargs=+ LPF^I^I^Ilet  s:LogiPatFlags="<args>"[J

line 55: [J

line 56: " =====================================================================[J

line 57: " Functions: {{{1[J

line 58: [J

line 59: " ---------------------------------------------------------------------[J

line 60: " LogiPat: this function interprets the boolean-logic pattern {{{2[J

line 61: fun! LogiPat(pat,...)[J

line 146: [J

line 147: " ---------------------------------------------------------------------[J

line 148: " s:String: Vim6.4 doesn't have string() {{{2[J

line 149: func! s:String(str)[J

line 152: [J

line 153: " ---------------------------------------------------------------------[J

line 154: " LP_PatPush: {{{2[J

line 155: fun! s:LP_PatPush(pat)[J

line 162: [J

line 163: " ---------------------------------------------------------------------[J

line 164: " LP_PatPop: pop a number/variable from LogiPat's pattern stack {{{2[J

line 165: fun! s:LP_PatPop(lookup)[J

line 178: [J

line 179: " ---------------------------------------------------------------------[J

line 180: " LP_OpPush: {{{2[J

line 181: fun! s:LP_OpPush(op)[J

line 232: [J

line 233: " ---------------------------------------------------------------------[J

line 234: " LP_Execute: execute operators from opstack using pattern stack {{{2[J

line 235: fun! s:LP_Execute(preclvl)[J

line 265: [J

line 266: " ---------------------------------------------------------------------[J

line 267: " LP_Not: writes a logical-not for a pattern {{{2[J

line 268: fun! s:LP_Not(pat)[J

line 279: [J

line 280: " ---------------------------------------------------------------------[J

line 281: " LP_Or: writes a logical-or branch using two patterns {{{2[J

line 282: fun! s:LP_Or(pat1,pat2)[J

line 288: [J

line 289: " ---------------------------------------------------------------------[J

line 290: " LP_And: writes a logical-and concat using two patterns {{{2[J

line 291: fun! s:LP_And(pat1,pat2)[J

line 297: [J

line 298: " ---------------------------------------------------------------------[J

line 299: " StackLook: {{{2[J

line 300: fun! s:StackLook(description)[J

line 334: [J

line 335: " ---------------------------------------------------------------------[J

line 336: "  Cleanup And Modeline: {{{1[J

line 337: let &cpo= s:keepcpo[J

line 338: unlet s:keepcpo[J

line 339: " vim: ts=4 fdm=marker[J

finished sourcing /usr/share/vim/vim80/plugin/logiPat.vim[J
chdir(/usr/share/vim/vim80/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim80/plugin/manpager.vim"[J
line 1: " Vim plugin for using Vim as manpager.[J

line 2: " Maintainer: Enno Nagel <ennonagel+vim@gmail.com>[J

line 3: " Last Change: 2016 May 20[J

line 4: [J

line 5: " $MAN_PN is supposed to be set by MANPAGER, see ":help manpager.vim".[J

line 6: if empty($MAN_PN)[J

line 7:   finish[J

finished sourcing /usr/share/vim/vim80/plugin/manpager.vim[J
chdir(/usr/share/vim/vim80/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim80/plugin/matchparen.vim"[J
line 1: " Vim plugin for showing matching parens[J

line 2: " Maintainer:  Bram Moolenaar <Bram@vim.org>[J

line 3: " Last Change: 2016 Feb 16[J

line 4: [J

line 5: " Exit quickly when:[J

line 6: " - this plugin was already loaded (or disabled)[J

line 7: " - when 'compatible' is set[J

line 8: " - the "CursorMoved" autocmd event is not available.[J

line 9: if exists("g:loaded_matchparen") || &cp || !exists("##CursorMoved")[J

line 10:   finish[J

line 11: endif[J

line 12: let g:loaded_matchparen = 1[J

line 13: [J

line 14: if !exists("g:matchparen_timeout")[J

line 15:   let g:matchparen_timeout = 300[J

line 16: endif[J

line 17: if !exists("g:matchparen_insert_timeout")[J

line 18:   let g:matchparen_insert_timeout = 60[J

line 19: endif[J

line 20: [J

line 21: augroup matchparen[J

line 22:   " Replace all matchparen autocommands[J

line 23:   autocmd! CursorMoved,CursorMovedI,WinEnter * call s:Highlight_Matching_Pair()[J

line 24:   if exists('##TextChanged')[J

line 25:     autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()[J

line 26:   endif[J

line 27: augroup END[J

line 28: [J

line 29: " Skip the rest if it was already done.[J

line 30: if exists("*s:Highlight_Matching_Pair")[J

line 31:   finish[J

line 32: endif[J

line 33: [J

line 34: let s:cpo_save = &cpo[J

line 35: set cpo-=C[J

line 36: [J

line 37: " The function that is invoked (very often) to define a ":match" highlighting[J

line 38: " for any matching paren.[J

line 39: function! s:Highlight_Matching_Pair()[J

line 187: [J

line 188: " Define commands that will disable and enable the plugin.[J

line 190: command! NoMatchParen windo silent! call matchdelete(3) | unlet! g:loaded_matchparen | au! matchparen[J

line 191: command! DoMatchParen runtime plugin/matchparen.vim | windo doau CursorMoved[J

line 192: [J

line 193: let &cpo = s:cpo_save[J

line 194: unlet s:cpo_save[J

finished sourcing /usr/share/vim/vim80/plugin/matchparen.vim[J
chdir(/usr/share/vim/vim80/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim80/plugin/netrwPlugin.vim"[J
line 1: " netrwPlugin.vim: Handles file transfer and remote directory listing across a network[J

line 2: "            PLUGIN SECTION[J

line 3: " Date:^I^IFeb 08, 2016[J

line 4: " Maintainer:^ICharles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>[J

line 5: " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim[J

line 6: " Copyright:    Copyright (C) 1999-2013 Charles E. Campbell {{{1[J

line 7: "               Permission is hereby granted to use and distribute this code,[J

line 8: "               with or without modifications, provided that this copyright[J

line 9: "               notice is copied with it. Like anything else that's free,[J

line 10: "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided[J

line 11: "               *as is* and comes with no warranty of any kind, either[J

line 12: "               expressed or implied. By using this plugin, you agree that[J

line 13: "               in no event will the copyright holder be liable for any damages[J

line 14: "               resulting from the use of this software.[J

line 15: "[J

line 16: "  But be doers of the Word, and not only hearers, deluding your own selves {{{1[J

line 17: "  (James 1:22 RSV)[J

line 18: " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-[J

line 19: " Load Once: {{{1[J

line 20: if &cp || exists("g:loaded_netrwPlugin")[J

line 21:  finish[J

line 22: endif[J

line 23: let g:loaded_netrwPlugin = "v156"[J

line 24: let s:keepcpo = &cpo[J

line 25: set cpo&vim[J

line 26: "DechoRemOn[J

line 27: [J

line 28: " ---------------------------------------------------------------------[J

line 29: " Public Interface: {{{1[J

line 30: [J

line 31: " Local Browsing Autocmds: {{{2[J

line 32: augroup FileExplorer[J

line 33:  au![J

line 34:  au BufLeave *  if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif[J

line 35:  au BufEnter *^Isil call s:LocalBrowse(expand("<amatch>"))[J

line 36:  au VimEnter *^Isil call s:VimEnter(expand("<amatch>"))[J

line 37:  if has("win32") || has("win95") || has("win64") || has("win16")[J

line 38:   au BufEnter .* sil call s:LocalBrowse(expand("<amatch>"))[J

line 39:  endif[J

line 40: augroup END[J

line 41: [J

line 42: " Network Browsing Reading Writing: {{{2[J

line 43: augroup Network[J

line 44:  au![J

line 45:  au BufReadCmd   file://*^I^I^I^I^I^I^I^I^I^I^Icall netrw#FileUrlRead(expand("<amatch>"))[J

line 46:  au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "sil doau BufReadPost ".fnameescape(expand("<amatch>"))[J

line 47:  au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "sil doau FileReadPost ".fnameescape(expand("<amatch>"))[J

line 48:  au BufWriteCmd  ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))[J

line 49:  au FileWriteCmd ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))[J

line 50:  try                                                       [J

line 51:   au SourceCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))[J

line 52:  catch /^Vim\%((\a\+)\)\=:E216/                            [J

line 53:   au SourcePre   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))[J

line 54:  endtry[J

line 55: augroup END[J

line 56: [J

line 57: " Commands: :Nread, :Nwrite, :NetUserPass {{{2[J

line 58: com! -count=1 -nargs=*^INread^I^Ilet s:svpos= winsaveview()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call winrestview(s:svpos)[J

line 59: com! -range=% -nargs=*^INwrite^I^Ilet s:svpos= winsaveview()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call winrestview(s:svpos)[J

line 60: com! -nargs=*^I^INetUserPass^Icall NetUserPass(<f-args>)[J

line 61: com! -nargs=*^I        Nsource^I^Ilet s:svpos= winsaveview()<bar>call netrw#NetSource(<f-args>)<bar>call winrestview(s:svpos)[J

line 62: com! -nargs=?^I^INtree^I^Icall netrw#SetTreetop(<q-args>)[J

line 63: [J

line 64: " Commands: :Explore, :Sexplore, Hexplore, Vexplore, Lexplore {{{2[J

line 65: com! -nargs=* -bar -bang -count=0 -complete=dir^IExplore^I^Icall netrw#Explore(<count>,0,0+<bang>0,<q-args>)[J

line 66: com! -nargs=* -bar -bang -count=0 -complete=dir^ISexplore^Icall netrw#Explore(<count>,1,0+<bang>0,<q-args>)[J

line 67: com! -nargs=* -bar -bang -count=0 -complete=dir^IHexplore^Icall netrw#Explore(<count>,1,2+<bang>0,<q-args>)[J

line 68: com! -nargs=* -bar -bang -count=0 -complete=dir^IVexplore^Icall netrw#Explore(<count>,1,4+<bang>0,<q-args>)[J

line 69: com! -nargs=* -bar       -count=0 -complete=dir^ITexplore^Icall netrw#Explore(<count>,0,6        ,<q-args>)[J

line 70: com! -nargs=* -bar -bang^I^I^INexplore^Icall netrw#Explore(-1,0,0,<q-args>)[J

line 71: com! -nargs=* -bar -bang^I^I^IPexplore^Icall netrw#Explore(-2,0,0,<q-args>)[J

line 72: com! -nargs=* -bar -bang -count=0 -complete=dir Lexplore^Icall netrw#Lexplore(<count>,<bang>0,<q-args>)[J

line 73: [J

line 74: " Commands: NetrwSettings {{{2[J

line 75: com! -nargs=0^INetrwSettings^Icall netrwSettings#NetrwSettings()[J

line 76: com! -bang^INetrwClean^Icall netrw#Clean(<bang>0)[J

line 77: [J

line 78: " Maps:[J

line 79: if !exists("g:netrw_nogx")[J

line 80:  if maparg('gx','n') == ""[J

line 81:   if !hasmapto('<Plug>NetrwBrowseX')[J

line 82:    nmap <unique> gx <Plug>NetrwBrowseX[J

line 83:   endif[J

line 84:   nno <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(expand((exists("g:netrw_gx")? g:netrw_gx : '<cfile>')),netrw#CheckIfRemote())<cr>[J

line 85:  endif[J

line 86:  if maparg('gx','v') == ""[J

line 87:   if !hasmapto('<Plug>NetrwBrowseXVis')[J

line 88:    vmap <unique> gx <Plug>NetrwBrowseXVis[J

line 89:   endif[J

line 90:   vno <silent> <Plug>NetrwBrowseXVis :<c-u>call netrw#BrowseXVis()<cr>[J

line 91:  endif[J

line 92: endif[J

line 93: if exists("g:netrw_usetab") && g:netrw_usetab[J

line 94:  if maparg('<c-tab>','n') == ""[J

line 95:   nmap <unique> <c-tab> <Plug>NetrwShrink[J

line 96:  endif[J

line 97:  nno <silent> <Plug>NetrwShrink :call netrw#Shrink()<cr>[J

line 98: endif[J

line 99: [J

line 100: " ---------------------------------------------------------------------[J

line 101: " LocalBrowse: invokes netrw#LocalBrowseCheck() on directory buffers {{{2[J

line 102: fun! s:LocalBrowse(dirname)[J

line 148: [J

line 149: " ---------------------------------------------------------------------[J

line 150: " s:VimEnter: after all vim startup stuff is done, this function is called. {{{2[J

line 151: "             Its purpose: to look over all windows and run s:LocalBrowse() on[J

line 152: "             them, which checks if they're directories and will create a directory[J

line 153: "             listing when appropriate.[J

line 154: "             It also sets s:vimentered, letting s:LocalBrowse() know that s:VimEnter()[J

line 155: "             has already been called.[J

line 156: fun! s:VimEnter(dirname)[J

line 164: [J

line 165: " ---------------------------------------------------------------------[J

line 166: " NetrwStatusLine: {{{1[J

line 167: fun! NetrwStatusLine()[J

line 178: [J

line 179: " ------------------------------------------------------------------------[J

line 180: " NetUserPass: set username and password for subsequent ftp transfer {{{1[J

line 181: "   Usage:  :call NetUserPass()^I^I^I-- will prompt for userid and password[J

line 182: "^I    :call NetUserPass("uid")^I^I-- will prompt for password[J

line 183: "^I    :call NetUserPass("uid","password") -- sets global userid and password[J

line 184: fun! NetUserPass(...)[J

line 208: [J

line 209: " ------------------------------------------------------------------------[J

line 210: " Modelines And Restoration: {{{1[J

line 211: let &cpo= s:keepcpo[J

line 212: unlet s:keepcpo[J

line 213: " vim:ts=8 fdm=marker[J

finished sourcing /usr/share/vim/vim80/plugin/netrwPlugin.vim[J
chdir(/usr/share/vim/vim80/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim80/plugin/rrhelper.vim"[J
line 1: " Vim plugin with helper function(s) for --remote-wait[J

line 2: " Maintainer: Flemming Madsen <fma@cci.dk>[J

line 3: " Last Change: 2008 May 29[J

line 4: [J

line 5: " Has this already been loaded?[J

line 6: if exists("loaded_rrhelper") || !has("clientserver")[J

line 7:   finish[J

finished sourcing /usr/share/vim/vim80/plugin/rrhelper.vim[J
chdir(/usr/share/vim/vim80/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim80/plugin/spellfile.vim"[J
line 1: " Vim plugin for downloading spell files[J

line 2: " Maintainer:  Bram Moolenaar <Bram@vim.org>[J

line 3: " Last Change: 2006 Feb 01[J

line 4: [J

line 5: " Exit quickly when:[J

line 6: " - this plugin was already loaded[J

line 7: " - when 'compatible' is set[J

line 8: " - some autocommands are already taking care of spell files[J

line 9: if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")[J

line 10:   finish[J

line 11: endif[J

line 12: let loaded_spellfile_plugin = 1[J

line 13: [J

line 14: " The function is in the autoload directory.[J

line 15: autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))[J

finished sourcing /usr/share/vim/vim80/plugin/spellfile.vim[J
chdir(/usr/share/vim/vim80/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim80/plugin/tarPlugin.vim"[J
line 1: " tarPlugin.vim -- a Vim plugin for browsing tarfiles[J

line 2: " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>[J

line 3: " Modified by Charles E. Campbell[J

line 4: " Distributed under the GNU General Public License.[J

line 5: "[J

line 6: " Updates are available from <http://michael.toren.net/code/>.  If you[J

line 7: " find this script useful, or have suggestions for improvements, please[J

line 8: " let me know.[J

line 9: " Also look there for further comments and documentation.[J

line 10: "[J

line 11: " This part only sets the autocommands.  The functions are in autoload/tar.vim.[J

line 12: " ---------------------------------------------------------------------[J

line 13: "  Load Once: {{{1[J

line 14: if &cp || exists("g:loaded_tarPlugin")[J

line 15:  finish[J

line 16: endif[J

line 17: let g:loaded_tarPlugin = "v29"[J

line 18: let s:keepcpo          = &cpo[J

line 19: set cpo&vim[J

line 20: [J

line 21: " ---------------------------------------------------------------------[J

line 22: "  Public Interface: {{{1[J

line 23: augroup tar[J

line 24:   au![J

line 25:   au BufReadCmd   tarfile::*^Icall tar#Read(expand("<amatch>"), 1)[J

line 26:   au FileReadCmd  tarfile::*^Icall tar#Read(expand("<amatch>"), 0)[J

line 27:   au BufWriteCmd  tarfile::*^Icall tar#Write(expand("<amatch>"))[J

line 28:   au FileWriteCmd tarfile::*^Icall tar#Write(expand("<amatch>"))[J

line 29: [J

line 30:   if has("unix")[J

line 31:    au BufReadCmd   tarfile::*/*^Icall tar#Read(expand("<amatch>"), 1)[J

line 32:    au FileReadCmd  tarfile::*/*^Icall tar#Read(expand("<amatch>"), 0)[J

line 33:    au BufWriteCmd  tarfile::*/*^Icall tar#Write(expand("<amatch>"))[J

line 34:    au FileWriteCmd tarfile::*/*^Icall tar#Write(expand("<amatch>"))[J

line 35:   endif[J

line 36: [J

line 37:   au BufReadCmd   *.tar.gz^I^Icall tar#Browse(expand("<amatch>"))[J

line 38:   au BufReadCmd   *.tar^I^I^Icall tar#Browse(expand("<amatch>"))[J

line 39:   au BufReadCmd   *.lrp^I^I^Icall tar#Browse(expand("<amatch>"))[J

line 40:   au BufReadCmd   *.tar.bz2^I^Icall tar#Browse(expand("<amatch>"))[J

line 41:   au BufReadCmd   *.tar.Z^I^Icall tar#Browse(expand("<amatch>"))[J

line 42:   au BufReadCmd   *.tgz^I^I^Icall tar#Browse(expand("<amatch>"))[J

line 43:   au BufReadCmd   *.tar.lzma^Icall tar#Browse(expand("<amatch>"))[J

line 44:   au BufReadCmd   *.tar.xz^I^Icall tar#Browse(expand("<amatch>"))[J

line 45:   au BufReadCmd   *.txz^I^I^Icall tar#Browse(expand("<amatch>"))[J

line 46: augroup END[J

line 47: com! -nargs=? -complete=file Vimuntar call tar#Vimuntar(<q-args>)[J

line 48: [J

line 49: " ---------------------------------------------------------------------[J

line 50: " Restoration And Modelines: {{{1[J

line 51: " vim: fdm=marker[J

line 52: let &cpo= s:keepcpo[J

line 53: unlet s:keepcpo[J

finished sourcing /usr/share/vim/vim80/plugin/tarPlugin.vim[J
chdir(/usr/share/vim/vim80/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim80/plugin/tohtml.vim"[J
line 1: " Vim plugin for converting a syntax highlighted file to HTML.[J

line 2: " Maintainer: Ben Fritz <fritzophrenic@gmail.com>[J

line 3: " Last Change: 2015 Sep 08[J

line 4: "[J

line 5: " The core of the code is in $VIMRUNTIME/autoload/tohtml.vim and[J

line 6: " $VIMRUNTIME/syntax/2html.vim[J

line 7: "[J

line 8: " TODO: {{{[J

line 9: "   * Options for generating the CSS in external style sheets. New :TOcss[J

line 10: "     command to convert the current color scheme into a (mostly) generic CSS[J

line 11: "     stylesheet which can be re-used. Alternate stylesheet support? Good start[J

line 12: "     by Erik Falor[J

line 13: "     ( https://groups.google.com/d/topic/vim_use/7XTmC4D22dU/discussion ).[J

line 14: "   * Add optional argument to :TOhtml command to specify mode (gui, cterm,[J

line 15: "     term) to use for the styling. Suggestion by "nacitar".[J

line 16: "   * Add way to override or specify which RGB colors map to the color numbers[J

line 17: "     in cterm. Get better defaults than just guessing? Suggestion by "nacitar".[J

line 18: "   * Disable filetype detection until after all processing is done.[J

line 19: "   * Add option for not generating the hyperlink on stuff that looks like a[J

line 20: "     URL? Or just color the link to fit with the colorscheme (and only special[J

line 21: "     when hovering)?[J

line 22: "   * Bug: Opera does not allow printing more than one page if uncopyable[J

line 23: "     regions is turned on. Possible solution: Add normal text line numbers with[J

line 24: "     display:none, set to display:inline for print style sheets, and hide[J

line 25: "     <input> elements for print, to allow Opera printing multiple pages (and[J

line 26: "     other uncopyable areas?). May need to make the new text invisible to IE[J

line 27: "     with conditional comments to prevent copying it, IE for some reason likes[J

line 28: "     to copy hidden text. Other browsers too?[J

line 29: "   * Bug: still a 1px gap throughout the fold column when html_prevent_copy is[J

line 30: "     "fn" in some browsers. Specifically, in Chromium on Ubuntu (but not Chrome[J

line 31: "     on Windows). Perhaps it is font related?[J

line 32: "   * Bug: still some gaps in the fold column when html_prevent_copy contains[J

line 33: "     'd' and showing the whole diff (observed in multiple browsers). Only gaps[J

line 34: "     on diff lines though.[J

line 35: "   * Undercurl support via CSS3, with fallback to dotted or something:[J

line 36: "^Ihttps://groups.google.com/d/topic/vim_use/BzXA6He1pHg/discussion[J

line 37: "   * Redo updates for modified default foldtext (v11) when/if the patch is[J

line 38: "     accepted to modify it.[J

line 39: "   * Test case +diff_one_file-dynamic_folds+expand_tabs-hover_unfold[J

line 40: "^I^I+ignore_conceal-ignore_folding+no_foldcolumn+no_pre+no_progress[J

line 41: "^I^I+number_lines-pre_wrap-use_css+use_xhtml+whole_filler.xhtml[J

line 42: "     does not show the whole diff filler as it is supposed to?[J

line 43: "   * Bug: when 'isprint' is wrong for the current encoding, will generate[J

line 44: "     invalid content. Can/should anything be done about this? Maybe a separate[J

line 45: "     plugin to correct 'isprint' based on encoding?[J

line 46: "   * Check to see if the windows-125\d encodings actually work in Unix without[J

line 47: "     the 8bit- prefix. Add prefix to autoload dictionaries for Unix if not.[J

line 48: "   * Font auto-detection similar to[J

line 49: "     http://www.vim.org/scripts/script.php?script_id=2384 but for a variety of[J

line 50: "     platforms.[J

line 51: "   * Error thrown when sourcing 2html.vim directly when plugins are not loaded.[J

line 52: "   * Pull in code from http://www.vim.org/scripts/script.php?script_id=3113 :[J

line 53: "^I- listchars support[J

line 54: "^I- full-line background highlight[J

line 55: "^I- other?[J

line 56: "   * Make it so deleted lines in a diff don't create side-scrolling (get it[J

line 57: "     free with full-line background highlight above).[J

line 58: "   * Restore open/closed folds and cursor position after processing each file[J

line 59: "     with option not to restore for speed increase.[J

line 60: "   * Add extra meta info (generation time, etc.)?[J

line 61: "   * Tidy up so we can use strict doctype in even more situations[J

line 62: "   * Implementation detail: add threshold for writing the lines to the html[J

line 63: "     buffer before we're done (5000 or so lines should do it)[J

line 64: "   * TODO comments for code cleanup scattered throughout[J

line 65: "}}}[J

line 66: [J

line 67: if exists('g:loaded_2html_plugin')[J

line 68:   finish[J

line 69: endif[J

line 70: let g:loaded_2html_plugin = 'vim7.4_v2'[J

line 71: [J

line 72: "[J

line 73: " Changelog: {{{[J

line 74: "   7.4_v2  (this version): Fix error raised when converting a diff containing[J

line 75: "                           an empty buffer. Jan Stocker: allow g:html_font to[J

line 76: "                           take a list so it is easier to specfiy fallback[J

line 77: "                           fonts in the generated CSS.[J

line 78: "   7.4_v1  (Vim 7.4.0000): Fix modeline mangling for new "Vim:" format, and[J

line 79: "^I^I^I    also for version-specific modelines like "vim>703:".[J

line 80: "[J

line 81: "   7.3 updates: {{{[J

line 82: "   7.3_v14 (Vim 7.3.1246): Allow suppressing line number anchors using[J

line 83: "^I^I^I    g:html_line_ids=0. Allow customizing[J

line 84: "^I^I^I    important IDs (like line IDs and fold IDs) using[J

line 85: "^I^I^I    g:html_id_expr evalutated when the buffer conversion[J

line 86: "^I^I^I    is started.[J

line 87: "   7.3_v13 (Vim 7.3.1088): Keep foldmethod at manual in the generated file and[J

line 88: "^I^I^I    insert modeline to set it to manual.[J

line 89: "^I^I^I    Fix bug: diff mode with 2 unsaved buffers creates a[J

line 90: "^I^I^I    duplicate of one buffer instead of including both.[J

line 91: "^I^I^I    Add anchors to each line so you can put '#L123'[J

line 92: "^I^I^I    or '#123' at the end of the URL to jump to line 123[J

line 93: "^I^I^I    (idea by Andy Spencer). Add javascript to open folds[J

line 94: "^I^I^I    to show the anchor being jumped to if it is hidden.[J

line 95: "^I^I^I    Fix XML validation error: &nsbp; not part of XML.[J

line 96: "^I^I^I    Allow TOhtml to chain together with other commands[J

line 97: "^I^I^I    using |.[J

line 98: "   7.3_v12 (Vim 7.3.0616): Fix modeline mangling to also work for when multiple[J

line 99: "^I^I^I    highlight groups make up the start-of-modeline text.[J

line 100: "^I^I^I    Improve render time of page with uncopyable regions[J

line 101: "^I^I^I    by not using one-input-per-char. Change name of[J

line 102: "^I^I^I    uncopyable option from html_unselectable to[J

line 103: "^I^I^I    html_prevent_copy. Added html_no_invalid option and[J

line 104: "^I^I^I    default to inserting invalid markup for uncopyable[J

line 105: "^I^I^I    regions to prevent MS Word from pasting undeletable[J

line 106: "^I^I^I    <input> elements. Fix 'cpo' handling (Thilo Six).[J

line 107: "^I^I 7.3_v12b1: Add html_unselectable option. Rework logic to[J

line 108: "^I^I^I    eliminate post-processing substitute commands in[J

line 109: "^I^I^I    favor of doing the work up front. Remove unnecessary[J

line 110: "^I^I^I    special treatment of 'LineNr' highlight group. Minor[J

line 111: "^I^I^I    speed improvements. Fix modeline mangling in[J

line 112: "^I^I^I    generated output so it works for text in the first[J

line 113: "^I^I^I    column. Fix missing line number and fold column in[J

line 114: "^I^I^I    diff filler lines. Fix that some fonts have a 1px[J

line 115: "^I^I^I    gap (using a dirty hack, improvements welcome). Add[J

line 116: "^I^I^I    "colorscheme" meta tag. Does NOT include support for[J

line 117: "^I^I^I    the new default foldtext added in v11, as the patch[J

line 118: "^I^I^I    adding it has not yet been included in Vim.[J

line 119: "   7.3_v11 ( unreleased ): Support new default foldtext from patch by Christian[J

line 120: "^I^I^I    Brabandt in[J

line 121: "^I^I^I    http://groups.google.com/d/topic/vim_dev/B6FSGfq9VoI/discussion.[J

line 122: "^I^I^I    This patch has not yet been included in Vim, thus[J

line 123: "^I^I^I    these changes are removed in the next version.[J

line 124: "   7.3_v10 (Vim 7.3.0227): Fix error E684 when converting a range wholly inside[J

line 125: "^I^I^I    multiple nested folds with dynamic folding on.[J

line 126: "^I^I^I    Also fix problem with foldtext in this situation.[J

line 127: "   7.3_v9  (Vim 7.3.0170): Add html_pre_wrap option active with html_use_css[J

line 128: "^I^I^I    and without html_no_pre, default value same as[J

line 129: "^I^I^I    'wrap' option, (Andy Spencer). Don't use[J

line 130: "^I^I^I    'fileencoding' for converted document encoding if[J

line 131: "^I^I^I    'buftype' indicates a special buffer which isn't[J

line 132: "^I^I^I    written.[J

line 133: "   7.3_v8  (Vim 7.3.0100): Add html_expand_tabs option to allow leaving tab[J

line 134: "^I^I^I    characters in generated output (Andy Spencer).[J

line 135: "^I^I^I    Escape text that looks like a modeline so Vim[J

line 136: "^I^I^I    doesn't use anything in the converted HTML as a[J

line 137: "^I^I^I    modeline. Bugfixes: Fix folding when a fold starts[J

line 138: "^I^I^I    before the conversion range. Remove fold column when[J

line 139: "^I^I^I    there are no folds.[J

line 140: "   7.3_v7  (Vim 7-3-0063): see betas released on vim_dev below:[J

line 141: "^I^I  7.3_v7b3: Fixed bug, convert Unicode to UTF-8 all the way.[J

line 142: "^I^I  7.3_v7b2: Remove automatic detection of encodings that are not[J

line 143: "^I^I^I    supported by all major browsers according to[J

line 144: "^I^I^I    http://wiki.whatwg.org/wiki/Web_Encodings and[J

line 145: "^I^I^I    convert to UTF-8 for all Unicode encodings. Make[J

line 146: "^I^I^I    HTML encoding to Vim encoding detection be[J

line 147: "^I^I^I    case-insensitive for built-in pairs.[J

line 148: "^I^I  7.3_v7b1: Remove use of setwinvar() function which cannot be[J

line 149: "^I^I^I    called in restricted mode (Andy Spencer). Use[J

line 150: "^I^I^I    'fencoding' instead of 'encoding' to determine by[J

line 151: "^I^I^I    charset, and make sure the 'fenc' of the generated[J

line 152: "^I^I^I    file matches its indicated charset. Add charsets for[J

line 153: "^I^I^I    all of Vim's natively supported encodings.[J

line 154: "   7.3_v6  (Vim 7.3.0000): Really fix bug with 'nowrapscan', 'magic' and other[J

line 155: "^I^I^I    user settings interfering with diff mode generation,[J

line 156: "^I^I^I    trailing whitespace (e.g. line number column) when[J

line 157: "^I^I^I    using html_no_pre, and bugs when using[J

line 158: "^I^I^I    html_hover_unfold.[J

line 159: "   7.3_v5  ( unreleased ): Fix bug with 'nowrapscan' and also with out-of-sync[J

line 160: "^I^I^I    folds in diff mode when first line was folded.[J

line 161: "   7.3_v4  (Vim 7.3.0000): Bugfixes, especially for xhtml markup, and diff mode[J

line 162: "   7.3_v3  (Vim 7.3.0000): Refactor option handling and make html_use_css[J

line 163: "^I^I^I    default to true when not set to anything. Use strict[J

line 164: "^I^I^I    doctypes where possible. Rename use_xhtml option to[J

line 165: "^I^I^I    html_use_xhtml for consistency. Use .xhtml extension[J

line 166: "^I^I^I    when using this option. Add meta tag for settings.[J

line 167: "   7.3_v2  (Vim 7.3.0000): Fix syntax highlighting in diff mode to use both the[J

line 168: "^I^I^I    diff colors and the normal syntax colors[J

line 169: "   7.3_v1  (Vim 7.3.0000): Add conceal support and meta tags in output[J

line 170: "}}}[J

line 171: "}}}[J

line 172: [J

line 173: " Define the :TOhtml command when:[J

line 174: " - 'compatible' is not set[J

line 175: " - this plugin was not already loaded[J

line 176: " - user commands are available. {{{[J

line 177: if !&cp && !exists(":TOhtml") && has("user_commands")[J

line 178:   command -range=% -bar TOhtml :call tohtml#Convert2HTML(<line1>, <line2>)[J

line 179: endif "}}}[J

line 180: [J

line 181: " Make sure any patches will probably use consistent indent[J

line 182: "   vim: ts=8 sw=2 sts=2 noet fdm=marker[J

finished sourcing /usr/share/vim/vim80/plugin/tohtml.vim[J
chdir(/usr/share/vim/vim80/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim80/plugin/vimballPlugin.vim"[J
line 1: " vimballPlugin : construct a file containing both paths and files[J

line 2: " Author: Charles E. Campbell[J

line 3: " Copyright: (c) 2004-2014 by Charles E. Campbell[J

line 4: "            The VIM LICENSE applies to Vimball.vim, and Vimball.txt[J

line 5: "            (see |copyright|) except use "Vimball" instead of "Vim".[J

line 6: "            No warranty, express or implied.[J

line 7: "  *** ***   Use At-Your-Own-Risk!   *** ***[J

line 8: "[J

line 9: " (Rom 2:1 WEB) Therefore you are without excuse, O man, whoever you are who[J

line 10: "      judge. For in that which you judge another, you condemn yourself. For[J

line 11: "      you who judge practice the same things.[J

line 12: " GetLatestVimScripts: 1502 1 :AutoInstall: vimball.vim[J

line 13: [J

line 14: " ---------------------------------------------------------------------[J

line 15: "  Load Once: {{{1[J

line 16: if &cp || exists("g:loaded_vimballPlugin")[J

line 17:  finish[J

line 18: endif[J

line 19: let g:loaded_vimballPlugin = "v37"[J

line 20: let s:keepcpo              = &cpo[J

line 21: set cpo&vim[J

line 22: [J

line 23: " ------------------------------------------------------------------------------[J

line 24: " Public Interface: {{{1[J

line 25: com! -range   -complete=file -nargs=+ -bang MkVimball^I^Icall vimball#MkVimball(<line1>,<line2>,<bang>0,<f-args>)[J

line 26: com! -nargs=? -complete=dir  UseVimball^I^I^I^I^I^Icall vimball#Vimball(1,<f-args>)[J

line 27: com! -nargs=0                VimballList^I^I^I^I^Icall vimball#Vimball(0)[J

line 28: com! -nargs=* -complete=dir  RmVimball^I^I^I^I^I^Icall vimball#SaveSettings()|call vimball#RmVimball(<f-args>)|call vimball#RestoreSettings()[J

line 29: augroup Vimball[J

line 30:  au![J

line 31:  au BufEnter  *.vba,*.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz^Isetlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|if line('$') > 1|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")|endif[J

line 32:  au SourceCmd *.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz^I^I^Ilet s:origfile=expand("%")|if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if s:origfile!=expand("<afile>")|close|endif[J

line 33:  au SourceCmd *.vba^I^I^I^I^I^I^I^I^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif[J

line 34:  au BufEnter  *.vmb,*.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz^Isetlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|if line('$') > 1|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")|endif[J

line 35:  au SourceCmd *.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz^I^I^Ilet s:origfile=expand("%")|if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if s:origfile!=expand("<afile>")|close|endif[J

line 36:  au SourceCmd *.vmb^I^I^I^I^I^I^I^I^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif[J

line 37: augroup END[J

line 38: [J

line 39: " =====================================================================[J

line 40: " Restoration And Modelines: {{{1[J

line 41: " vim: fdm=marker[J

line 42: let &cpo= s:keepcpo[J

line 43: unlet s:keepcpo[J

finished sourcing /usr/share/vim/vim80/plugin/vimballPlugin.vim[J
chdir(/usr/share/vim/vim80/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim80/plugin/zipPlugin.vim"[J
line 1: " zipPlugin.vim: Handles browsing zipfiles[J

line 2: "            PLUGIN PORTION[J

line 3: " Date:^I^I^ISep 13, 2016[J

line 4: " Maintainer:^ICharles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>[J

line 5: " License:^I^IVim License  (see vim's :help license)[J

line 6: " Copyright:    Copyright (C) 2005-2016 Charles E. Campbell {{{1[J

line 7: "               Permission is hereby granted to use and distribute this code,[J

line 8: "               with or without modifications, provided that this copyright[J

line 9: "               notice is copied with it. Like anything else that's free,[J

line 10: "               zipPlugin.vim is provided *as is* and comes with no warranty[J

line 11: "               of any kind, either expressed or implied. By using this[J

line 12: "               plugin, you agree that in no event will the copyright[J

line 13: "               holder be liable for any damages resulting from the use[J

line 14: "               of this software.[J

line 15: "[J

line 16: " (James 4:8 WEB) Draw near to God, and he will draw near to you.[J

line 17: " Cleanse your hands, you sinners; and purify your hearts, you double-minded.[J

line 18: " ---------------------------------------------------------------------[J

line 19: " Load Once: {{{1[J

line 20: if &cp || exists("g:loaded_zipPlugin")[J

line 21:  finish[J

line 22: endif[J

line 23: let g:loaded_zipPlugin = "v28"[J

line 24: let s:keepcpo          = &cpo[J

line 25: set cpo&vim[J

line 26: [J

line 27: " ---------------------------------------------------------------------[J

line 28: " Options: {{{1[J

line 29: if !exists("g:zipPlugin_ext")[J

line 30:  let g:zipPlugin_ext='*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip'[J

line 31: endif[J

line 32: [J

line 33: " ---------------------------------------------------------------------[J

line 34: " Public Interface: {{{1[J

line 35: augroup zip[J

line 36:  au![J

line 37:  au BufReadCmd   zipfile:*^Icall zip#Read(expand("<amatch>"), 1)[J

line 38:  au FileReadCmd  zipfile:*^Icall zip#Read(expand("<amatch>"), 0)[J

line 39:  au BufWriteCmd  zipfile:*^Icall zip#Write(expand("<amatch>"))[J

line 40:  au FileWriteCmd zipfile:*^Icall zip#Write(expand("<amatch>"))[J

line 41: [J

line 42:  if has("unix")[J

line 43:   au BufReadCmd   zipfile:*/*^Icall zip#Read(expand("<amatch>"), 1)[J

line 44:   au FileReadCmd  zipfile:*/*^Icall zip#Read(expand("<amatch>"), 0)[J

line 45:   au BufWriteCmd  zipfile:*/*^Icall zip#Write(expand("<amatch>"))[J

line 46:   au FileWriteCmd zipfile:*/*^Icall zip#Write(expand("<amatch>"))[J

line 47:  endif[J

line 48: [J

line 49:  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'[J

line 49: au BufReadCmd *.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip call zip#Browse(expand("<amatch>"))[J

line 50: augroup END[J

line 51: [J

line 52: " ---------------------------------------------------------------------[J

line 53: "  Restoration And Modelines: {{{1[J

line 54: "  vim: fdm=marker[J

line 55: let &cpo= s:keepcpo[J

line 56: unlet s:keepcpo[J

finished sourcing /usr/share/vim/vim80/plugin/zipPlugin.vim[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/plugin/**/*.vim"[J
Searching for "pack/*/start/*" in "/home/patrick/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vimfiles/after,/home/patrick/.vim/after"[J
Searching for "/home/patrick/.vim/pack/*/start/*"[J
Searching for "/usr/share/vim/vimfiles/pack/*/start/*"[J
Searching for "/usr/share/vim/vim80/pack/*/start/*"[J
Searching for "/usr/share/vim/vimfiles/after/pack/*/start/*"[J
Searching for "/home/patrick/.vim/after/pack/*/start/*"[J
not found in 'packpath': "pack/*/start/*"[J
Searching for "pack/*/start/*" in "/home/patrick/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vimfiles/after,/home/patrick/.vim/after"[J
Searching for "/home/patrick/.vim/pack/*/start/*"[J
Searching for "/usr/share/vim/vimfiles/pack/*/start/*"[J
Searching for "/usr/share/vim/vim80/pack/*/start/*"[J
Searching for "/usr/share/vim/vimfiles/after/pack/*/start/*"[J
Searching for "/home/patrick/.vim/after/pack/*/start/*"[J
not found in 'packpath': "pack/*/start/*"[J
Searching for "plugin/**/*.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vim80/pack/dist/opt/matchit,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/after,/home/patr[J
Searching for "/usr/share/vim/vimfiles/after/plugin/**/*.vim"[J
Searching for "/var/lib/vim/addons/after/plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/after/plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/after/plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/after/plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/after/plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/after/plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/after/plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdcommenter/after/plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-fugitive/after/plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/bundle/ale/after/plugin/**/*.vim"[J
chdir(/home/patrick/.vim/bundle/ale/after/plugin)[J
fchdir() to previous dir[J
sourcing "/home/patrick/.vim/bundle/ale/after/plugin/ale.vim"[J
line 1: " Author: w0rp <devw0rp@gmail.com>[J

line 2: " Description: Follow-up checks for the plugin: warn about conflicting plugins.[J

line 3: [J

line 4: " A flag for ensuring that this is not run more than one time.[J

line 5: if exists('g:loaded_ale_after')[J

line 6:     finish[J

line 7: endif[J

line 8: [J

line 9: " Set the flag so this file is not run more than one time.[J

line 10: let g:loaded_ale_after = 1[J

line 11: [J

line 12: " Check if the flag is available and set to 0 to disable checking for and[J

line 13: " emitting conflicting plugin warnings.[J

line 14: if exists('g:ale_emit_conflict_warnings') && !g:ale_emit_conflict_warnings[J

line 15:     finish[J

line 16: endif[J

line 17: [J

line 18: " Conflicting Plugins Checks[J

line 19: [J

line 20: function! s:GetConflictingPluginWarning(plugin_name) abort[J

line 26: [J

line 27: if exists('g:loaded_syntastic_plugin')[J

line 28:     throw s:GetConflictingPluginWarning('Syntastic')[J

line 29: endif[J

line 30: [J

line 31: if exists('g:loaded_neomake')[J

line 32:     throw s:GetConflictingPluginWarning('Neomake')[J

line 33: endif[J

line 34: [J

line 35: if exists('g:loaded_validator_plugin')[J

line 36:     throw s:GetConflictingPluginWarning('Validator')[J

line 37: endif[J

finished sourcing /home/patrick/.vim/bundle/ale/after/plugin/ale.vim[J
Searching for "/home/patrick/.vim/bundle/tabular/after/plugin/**/*.vim"[J
chdir(/home/patrick/.vim/bundle/tabular/after/plugin)[J
fchdir() to previous dir[J
sourcing "/home/patrick/.vim/bundle/tabular/after/plugin/TabularMaps.vim"[J
line 1: " Copyright (c) 2016, Matthew J. Wozniski[J

line 2: " All rights reserved.[J

line 3: "[J

line 4: " Redistribution and use in source and binary forms, with or without[J

line 5: " modification, are permitted provided that the following conditions are met:[J

line 6: "     * Redistributions of source code must retain the above copyright notice,[J

line 7: "       this list of conditions and the following disclaimer.[J

line 8: "     * Redistributions in binary form must reproduce the above copyright[J

line 9: "       notice, this list of conditions and the following disclaimer in the[J

line 10: "       documentation and/or other materials provided with the distribution.[J

line 11: "     * The names of the contributors may not be used to endorse or promote[J

line 12: "       products derived from this software without specific prior written[J

line 13: "       permission.[J

line 14: "[J

line 15: " THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER ``AS IS'' AND ANY EXPRESS[J

line 16: " OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES[J

line 17: " OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN[J

line 18: " NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY DIRECT, INDIRECT,[J

line 19: " INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT[J

line 20: " LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,[J

line 21: " OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF[J

line 22: " LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING[J

line 23: " NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,[J

line 24: " EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.[J

line 25: [J

line 26: if !exists(':Tabularize') || get(g:, 'no_default_tabular_maps', 0)[J

line 27:   finish " Tabular.vim wasn't loaded or the default maps are unwanted[J

line 28: endif[J

line 29: [J

line 30: let s:save_cpo = &cpo[J

line 31: set cpo&vim[J

line 32: [J

line 33: AddTabularPattern!  assignment      /[|&+*/%<>=!~-]\@<!\([<>!=]=\|=\~\)\@![|&+*/%<>=!~-]*=/l1r1[J

line 33: call AddTabularPattern("assignment      /[|&+*/%<>=!~-]\\@<!\\([<>!=]=\\|=\\~\\)\\@![|&+*/%<>=!~-]*=/l1r1", !0)[J

calling function AddTabularPattern[J('assignment      /[|&+*/%<>=!~-]\@<!\([<>!=]=\|=\~\)\@![|&+*/%<>=!~-]*=/l1r1', 1)

line 1:   try[J

line 2:     let [ commandmap, rest ] = s:ChooseCommandMap(a:command)[J

calling function AddTabularPattern[2]..<SNR>41_ChooseCommandMap[J('assignment      /[|&+*/%<>=!~-]\@<!\([<>!=]=\|=\~\)\@![|&+*/%<>=!~-]*=/l1r1')

line 1:   let map = s:TabularCommands[J

line 2:   let cmd = a:commandline[J

line 3: [J

line 4:   if cmd =~# '^<buffer>\s\+'[J

line 5:     if !exists('b:TabularCommands')[J

line 6:       let b:TabularCommands = {}[J

line 7:     endif[J

line 8:     let map = b:TabularCommands[J

line 9:     let cmd = substitute(cmd, '^<buffer>\s\+', '', '')[J

line 10:   endif[J

line 11: [J

line 12:   return [ map, cmd ][J

function AddTabularPattern[2]..<SNR>41_ChooseCommandMap returning [{}, 'assignment      /[|&+*/%<>=!~-]\...<>!=]=\|=\~\)\@![|&+*/%<>=!~-]*=/l1r1'][J

continuing in function AddTabularPattern[J

line 3: [J

line 4:     let name = matchstr(rest, '.\{-}\ze\s*/')[J

line 5:     let pattern = substitute(rest, '.\{-}\s*\ze/', '', '')[J

line 6: [J

line 7:     let [ pattern, format ] = s:ParsePattern(pattern)[J

calling function AddTabularPattern[7]..<SNR>41_ParsePattern[J('/[|&+*/%<>=!~-]\@<!\([<>!=]=\|=\~\)\@![|&+*/%<>=!~-]*=/l1r1')

line 1:   if a:string[0] != '/'[J

line 2:     return ['',''][J

line 3:   endif[J

line 4: [J

line 5:   let pat = '\\\@<!\%(\\\\\)\{-}\zs/' . tabular#ElementFormatPattern() . '*$'[J

Searching for "autoload/tabular.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vim80/pack/dist/opt/matchit,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/after,/home/patrick/.vim/bundle/ale/after,/home[J
Searching for "/home/patrick/.vim/autoload/tabular.vim"[J
Searching for "/home/patrick/.vim/bundle/Vundle.vim/autoload/tabular.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-sensible/autoload/tabular.vim"[J
Searching for "/home/patrick/.vim/bundle/molokai-dark/autoload/tabular.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree/autoload/tabular.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/autoload/tabular.vim"[J
Searching for "/home/patrick/.vim/bundle/nerdcommenter/autoload/tabular.vim"[J
Searching for "/home/patrick/.vim/bundle/vim-fugitive/autoload/tabular.vim"[J
Searching for "/home/patrick/.vim/bundle/ale/autoload/tabular.vim"[J
Searching for "/home/patrick/.vim/bundle/tabular/autoload/tabular.vim"[J
chdir(/home/patrick/.vim/bundle/tabular/autoload)[J
fchdir() to previous dir[J
line 5: sourcing "/home/patrick/.vim/bundle/tabular/autoload/tabular.vim"[J
line 1: " Tabular:     Align columnar data using regex-designated column boundaries[J

line 2: " Maintainer:  Matthew Wozniski (godlygeek@gmail.com)[J

line 3: " Date:        Thu, 03 May 2012 20:49:32 -0400[J

line 4: " Version:     1.0[J

line 5: "[J

line 6: " Long Description:[J

line 7: " Sometimes, it's useful to line up text.  Naturally, it's nicer to have the[J

line 8: " computer do this for you, since aligning things by hand quickly becomes[J

line 9: " unpleasant.  While there are other plugins for aligning text, the ones I've[J

line 10: " tried are either impossibly difficult to understand and use, or too simplistic[J

line 11: " to handle complicated tasks.  This plugin aims to make the easy things easy[J

line 12: " and the hard things possible, without providing an unnecessarily obtuse[J

line 13: " interface.  It's still a work in progress, and criticisms are welcome.[J

line 14: "[J

line 15: " License:[J

line 16: " Copyright (c) 2012, Matthew J. Wozniski[J

line 17: " All rights reserved.[J

line 18: "[J

line 19: " Redistribution and use in source and binary forms, with or without[J

line 20: " modification, are permitted provided that the following conditions are met:[J

line 21: "     * Redistributions of source code must retain the above copyright notice,[J

line 22: "       this list of conditions and the following disclaimer.[J

line 23: "     * Redistributions in binary form must reproduce the above copyright[J

line 24: "       notice, this list of conditions and the following disclaimer in the[J

line 25: "       documentation and/or other materials provided with the distribution.[J

line 26: "     * The names of the contributors may not be used to endorse or promote[J

line 27: "       products derived from this software without specific prior written[J

line 28: "       permission.[J

line 29: "[J

line 30: " THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER ``AS IS'' AND ANY EXPRESS[J

line 31: " OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES[J

line 32: " OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN[J

line 33: " NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY DIRECT, INDIRECT,[J

line 34: " INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT[J

line 35: " LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,[J

line 36: " OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF[J

line 37: " LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING[J

line 38: " NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,[J

line 39: " EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.[J

line 40: [J

line 41: " Stupid vimscript crap                                                   {{{1[J

line 42: let s:savecpo = &cpo[J

line 43: set cpo&vim[J

line 44: [J

line 45: " Private Functions                                                       {{{1[J

line 46: [J

line 47: " Return the number of bytes in a string after expanding tabs to spaces.  {{{2[J

line 48: " This expansion is done based on the current value of 'tabstop'[J

line 49: if exists('*strdisplaywidth')[J

line 50:   " Needs vim 7.3[J

line 51:   let s:Strlen = function("strdisplaywidth")[J

line 52: else[J

line 53:   function! s:Strlen(string)[J

line 72: endif[J

line 73: [J

line 74: " Align a string within a field                                           {{{2[J

line 75: " These functions do not trim leading and trailing spaces.[J

line 76: [J

line 77: " Right align 'string' in a field of size 'fieldwidth'[J

line 78: function! s:Right(string, fieldwidth)[J

line 82: [J

line 83: " Left align 'string' in a field of size 'fieldwidth'[J

line 84: function! s:Left(string, fieldwidth)[J

line 88: [J

line 89: " Center align 'string' in a field of size 'fieldwidth'[J

line 90: function! s:Center(string, fieldwidth)[J

line 96: [J

line 97: " Remove spaces around a string                                           {{{2[J

line 98: [J

line 99: " Remove all trailing spaces from a string.[J

line 100: function! s:StripTrailingSpaces(string)[J

line 103: [J

line 104: " Remove all leading spaces from a string.[J

line 105: function! s:StripLeadingSpaces(string)[J

line 108: [J

line 109: " Split a string into fields and delimiters                               {{{2[J

line 110: " Like split(), but include the delimiters as elements[J

line 111: " All odd numbered elements are delimiters[J

line 112: " All even numbered elements are non-delimiters (including zero)[J

line 113: function! s:SplitDelim(string, delim)[J

line 151: [J

line 152: " Replace lines from `start' to `start + len - 1' with the given strings. {{{2[J

line 153: " If more lines are needed to show all strings, they will be added.[J

line 154: " If there are too few strings to fill all lines, lines will be removed.[J

line 155: function! s:SetLines(start, len, strings)[J

line 176: [J

line 177: " Runs the given commandstring argument as an expression.                 {{{2[J

line 178: " The commandstring expression is expected to reference the a:lines argument.[J

line 179: " If the commandstring expression returns a list the items of that list will[J

line 180: " replace the items in a:lines, otherwise the expression is assumed to have[J

line 181: " modified a:lines itself.[J

line 182: function! s:FilterString(lines, commandstring)[J

line 190: [J

line 191: " Public API                                                              {{{1[J

line 192: [J

line 193: if !exists("g:tabular_default_format")[J

line 194:   let g:tabular_default_format = "l1"[J

line 195: endif[J

line 196: [J

line 197: let s:formatelempat = '\%([lrc]\d\+\)'[J

line 198: [J

line 199: function! tabular#ElementFormatPattern()[J

line 202: [J

line 203: " Given a list of strings and a delimiter, split each string on every[J

line 204: " occurrence of the delimiter pattern, format each element according to either[J

line 205: " the provided format (optional) or the default format, and join them back[J

line 206: " together with enough space padding to guarantee that the nth delimiter of[J

line 207: " each string is aligned.[J

line 208: function! tabular#TabularizeStrings(strings, delim, ...)[J

line 289: [J

line 290: " Apply 0 or more filters, in sequence, to selected text in the buffer    {{{2[J

line 291: " The lines to be filtered are determined as follows:[J

line 292: "   If the function is called with a range containing multiple lines, then[J

line 293: "     those lines will be used as the range.[J

line 294: "   If the function is called with no range or with a range of 1 line, then[J

line 295: "     if GTabularize mode is being used,[J

line 296: "       the range will not be adjusted[J

line 297: "     if "includepat" is not specified,[J

line 298: "       that 1 line will be filtered,[J

line 299: "     if "includepat" is specified and that line does not match it,[J

line 300: "       no lines will be filtered[J

line 301: "     if "includepat" is specified and that line does match it,[J

line 302: "       all contiguous lines above and below the specified line matching the[J

line 303: "       pattern will be filtered.[J

line 304: "[J

line 305: " The remaining arguments must each be a filter to apply to the text.[J

line 306: " Each filter must either be a String evaluating to a function to be called.[J

line 307: function! tabular#PipeRange(includepat, ...) range[J

line 311: [J

line 312: " Extended version of tabular#PipeRange, which[J

line 313: " 1) Takes the list of filters as an explicit list rather than as varargs[J

line 314: " 2) Supports passing a dictionary of options to control the routine.[J

line 315: "    Currently, the only supported option is 'mode', which determines whether[J

line 316: "    to behave as :Tabularize or as :GTabularize[J

line 317: " This allows me to add new features here without breaking API compatibility[J

line 318: " in the future.[J

line 319: function! tabular#PipeRangeWithOptions(includepat, filterlist, options) range[J

line 354: [J

line 355: " Part of the public interface so interested pipelines can query this and[J

line 356: " adjust their behavior appropriately.[J

line 357: function! tabular#DoGTabularize()[J

line 360: [J

line 361: function! s:SplitDelimTest(string, delim, expected)[J

line 371: [J

line 372: function! tabular#SplitDelimUnitTest()[J

line 404: [J

line 405: " Stupid vimscript crap, part 2                                           {{{1[J

line 406: let &cpo = s:savecpo[J

line 407: unlet s:savecpo[J

line 408: [J

line 409: " vim:set sw=2 sts=2 fdm=marker:[J

finished sourcing /home/patrick/.vim/bundle/tabular/autoload/tabular.vim[J
continuing in function AddTabularPattern[7]..<SNR>41_ParsePattern[J
calling function AddTabularPattern[7]..<SNR>41_ParsePattern[5]..tabular#ElementFormatPattern[J()

line 1:   return s:formatelempat[J

function AddTabularPattern[7]..<SNR>41_ParsePattern[5]..tabular#ElementFormatPattern returning '\%([lrc]\d\+\)'[J

continuing in function AddTabularPattern[7]..<SNR>41_ParsePattern[J

line 6:   let format = matchstr(a:string[1:-1], pat)[J

line 7:   if !empty(format)[J

line 8:     let format = format[1 : -1][J

line 9:     let pattern = a:string[1 : -len(format) - 2][J

line 10:   else[J

line 11:     let pattern = a:string[1 : -1][J

line 12:   endif[J

line 13: [J

line 14:   return [pattern, format][J

function AddTabularPattern[7]..<SNR>41_ParsePattern returning ['[|&+*/%<>=!~-]\@<!\([<>!=]=\|=\~\)\@![|&+*/%<>=!~-]*=', 'l1r1'][J

continuing in function AddTabularPattern[J

line 8: [J

line 9:     if empty(name) || empty(pattern)[J

line 10:       throw "Invalid arguments!"[J

line 11:     endif[J

line 12: [J

line 13:     if !a:force && has_key(commandmap, name)[J

line 14:       throw string(name) . " is already defined, use ! to overwrite."[J

line 15:     endif[J

line 16: [J

line 17:     let command = "tabular#TabularizeStrings(a:lines, " . string(pattern)[J

line 18: [J

line 19:     if !empty(format)[J

line 20:       let command .=  ", " . string(format)[J

line 21:     endif[J

line 22: [J

line 23:     let command .= ")"[J

line 24: [J

line 25:     let commandmap[name] = { 'pattern' : pattern, 'commands' : [ command ] }[J

line 26:   catch[J

line 27:     echohl ErrorMsg[J

line 28:     echomsg "AddTabularPattern: " . v:exception[J

line 29:     echohl None[J

line 30:   endtry[J

function AddTabularPattern returning #0[J

continuing in /home/patrick/.vim/bundle/tabular/after/plugin/TabularMaps.vim[J

line 34: AddTabularPattern!  two_spaces      /  /l0[J

line 34: call AddTabularPattern("two_spaces      /  /l0", !0)[J

calling function AddTabularPattern[J('two_spaces      /  /l0', 1)

line 1:   try[J

line 2:     let [ commandmap, rest ] = s:ChooseCommandMap(a:command)[J

calling function AddTabularPattern[2]..<SNR>41_ChooseCommandMap[J('two_spaces      /  /l0')

line 1:   let map = s:TabularCommands[J

line 2:   let cmd = a:commandline[J

line 3: [J

line 4:   if cmd =~# '^<buffer>\s\+'[J

line 5:     if !exists('b:TabularCommands')[J

line 6:       let b:TabularCommands = {}[J

line 7:     endif[J

line 8:     let map = b:TabularCommands[J

line 9:     let cmd = substitute(cmd, '^<buffer>\s\+', '', '')[J

line 10:   endif[J

line 11: [J

line 12:   return [ map, cmd ][J

function AddTabularPattern[2]..<SNR>41_ChooseCommandMap returning [{'assignment': {'pattern': '[|&+*/%<>...'l1r1'')']}}, 'two_spaces      /  /l0'][J

continuing in function AddTabularPattern[J

line 3: [J

line 4:     let name = matchstr(rest, '.\{-}\ze\s*/')[J

line 5:     let pattern = substitute(rest, '.\{-}\s*\ze/', '', '')[J

line 6: [J

line 7:     let [ pattern, format ] = s:ParsePattern(pattern)[J

calling function AddTabularPattern[7]..<SNR>41_ParsePattern[J('/  /l0')

line 1:   if a:string[0] != '/'[J

line 2:     return ['',''][J

line 3:   endif[J

line 4: [J

line 5:   let pat = '\\\@<!\%(\\\\\)\{-}\zs/' . tabular#ElementFormatPattern() . '*$'[J

calling function AddTabularPattern[7]..<SNR>41_ParsePattern[5]..tabular#ElementFormatPattern[J()

line 1:   return s:formatelempat[J

function AddTabularPattern[7]..<SNR>41_ParsePattern[5]..tabular#ElementFormatPattern returning '\%([lrc]\d\+\)'[J

continuing in function AddTabularPattern[7]..<SNR>41_ParsePattern[J

line 6:   let format = matchstr(a:string[1:-1], pat)[J

line 7:   if !empty(format)[J

line 8:     let format = format[1 : -1][J

line 9:     let pattern = a:string[1 : -len(format) - 2][J

line 10:   else[J

line 11:     let pattern = a:string[1 : -1][J

line 12:   endif[J

line 13: [J

line 14:   return [pattern, format][J

function AddTabularPattern[7]..<SNR>41_ParsePattern returning ['  ', 'l0'][J

continuing in function AddTabularPattern[J

line 8: [J

line 9:     if empty(name) || empty(pattern)[J

line 10:       throw "Invalid arguments!"[J

line 11:     endif[J

line 12: [J

line 13:     if !a:force && has_key(commandmap, name)[J

line 14:       throw string(name) . " is already defined, use ! to overwrite."[J

line 15:     endif[J

line 16: [J

line 17:     let command = "tabular#TabularizeStrings(a:lines, " . string(pattern)[J

line 18: [J

line 19:     if !empty(format)[J

line 20:       let command .=  ", " . string(format)[J

line 21:     endif[J

line 22: [J

line 23:     let command .= ")"[J

line 24: [J

line 25:     let commandmap[name] = { 'pattern' : pattern, 'commands' : [ command ] }[J

line 26:   catch[J

line 27:     echohl ErrorMsg[J

line 28:     echomsg "AddTabularPattern: " . v:exception[J

line 29:     echohl None[J

line 30:   endtry[J

function AddTabularPattern returning #0[J

continuing in /home/patrick/.vim/bundle/tabular/after/plugin/TabularMaps.vim[J

line 35: [J

line 36: AddTabularPipeline! multiple_spaces /  / map(a:lines, "substitute(v:val, '   *', '  ', 'g')") | tabular#TabularizeStrings(a:lines, '  ', 'l0')[J

line 36: call AddTabularPipeline("multiple_spaces /  / map(a:lines, \"substitute(v:val, '   *', '  ', 'g')\") | tabular#TabularizeStrings(a:lines, '  ', 'l0')", !0)[J

calling function AddTabularPipeline[J('multiple_spaces /  / map(a:lines, "su...larizeStrings(a:lines, ''  '', ''l0'')', 1)

line 1:   try[J

line 2:     let [ commandmap, rest ] = s:ChooseCommandMap(a:command)[J

calling function AddTabularPipeline[2]..<SNR>41_ChooseCommandMap[J('multiple_spaces /  / map(a:lines, "su...larizeStrings(a:lines, ''  '', ''l0'')')

line 1:   let map = s:TabularCommands[J

line 2:   let cmd = a:commandline[J

line 3: [J

line 4:   if cmd =~# '^<buffer>\s\+'[J

line 5:     if !exists('b:TabularCommands')[J

line 6:       let b:TabularCommands = {}[J

line 7:     endif[J

line 8:     let map = b:TabularCommands[J

line 9:     let cmd = substitute(cmd, '^<buffer>\s\+', '', '')[J

line 10:   endif[J

line 11: [J

line 12:   return [ map, cmd ][J

function AddTabularPipeline[2]..<SNR>41_ChooseCommandMap returning [{'assignment': {'pattern': '[|&+*/%<>...arizeStrings(a:lines, ''  '', ''l0'')'][J

continuing in function AddTabularPipeline[J

line 3: [J

line 4:     let name = matchstr(rest, '.\{-}\ze\s*/')[J

line 5:     let pattern = substitute(rest, '.\{-}\s*\ze/', '', '')[J

line 6: [J

line 7:     let commands = matchstr(pattern, '^/.\{-}\\\@<!\%(\\\\\)\{-}/\zs.*')[J

line 8:     let pattern = matchstr(pattern, '/\zs.\{-}\\\@<!\%(\\\\\)\{-}\ze/')[J

line 9: [J

line 10:     if empty(name) || empty(pattern)[J

line 11:       throw "Invalid arguments!"[J

line 12:     endif[J

line 13: [J

line 14:     if !a:force && has_key(commandmap, name)[J

line 15:       throw string(name) . " is already defined, use ! to overwrite."[J

line 16:     endif[J

line 17: [J

line 18:     let commandlist = s:SplitCommands(commands)[J

calling function AddTabularPipeline[18]..<SNR>41_SplitCommands[J(' map(a:lines, "substitute(v:val, ''  ...larizeStrings(a:lines, ''  '', ''l0'')')

line 1:   if a:string =~ '^\s*$'[J

line 2:     return [][J

line 3:   endif[J

line 4: [J

line 5:   let end = match(a:string, "[\"'|]")[J

line 6: [J

line 7:   " Loop until we find a delimiting | or end-of-string[J

line 8:   while end != -1 && (a:string[end] != '|' || a:string[end+1] == '|')[J

line 9:     if a:string[end] == "'"[J

line 10:       let end = match(a:string, "'", end+1) + 1[J

line 11:       if end == 0[J

line 12:         throw "No matching end single quote"[J

line 13:       endif[J

line 14:     elseif a:string[end] == '"'[J

line 15:       " Find a " preceded by an even number of \ (or 0)[J

line 16:       let pattern = '\%(\\\@<!\%(\\\\\)*\)\@<="'[J

line 17:       let end = matchend(a:string, pattern, end+1) + 1[J

line 18:       if end == 0[J

line 19:         throw "No matching end double quote"[J

line 20:       endif[J

line 21:     else " Found ||[J

line 22:       let end += 2[J

line 23:     endif[J

line 24: [J

line 25:     let end = match(a:string, "[\"'|]", end)[J

line 26:   endwhile[J

line 8:   while end != -1 && (a:string[end] != '|' || a:string[end+1] == '|')[J

line 9:     if a:string[end] == "'"[J

line 10:       let end = match(a:string, "'", end+1) + 1[J

line 11:       if end == 0[J

line 12:         throw "No matching end single quote"[J

line 13:       endif[J

line 14:     elseif a:string[end] == '"'[J

line 15:       " Find a " preceded by an even number of \ (or 0)[J

line 16:       let pattern = '\%(\\\@<!\%(\\\\\)*\)\@<="'[J

line 17:       let end = matchend(a:string, pattern, end+1) + 1[J

line 18:       if end == 0[J

line 19:         throw "No matching end double quote"[J

line 20:       endif[J

line 21:     else " Found ||[J

line 22:       let end += 2[J

line 23:     endif[J

line 24: [J

line 25:     let end = match(a:string, "[\"'|]", end)[J

line 26:   endwhile[J

line 27: [J

line 28:   if end == 0 || a:string[0 : end - (end > 0)] =~ '^\s*$'[J

line 29:     throw "Empty element"[J

line 30:   endif[J

line 31: [J

line 32:   if end == -1[J

line 33:     let rv = [ a:string ][J

line 34:   else[J

line 35:     let rv = [ a:string[0 : end-1] ] + s:SplitCommands(a:string[end+1 : -1])[J

calling function AddTabularPipeline[18]..<SNR>41_SplitCommands[35]..<SNR>41_SplitCommands[J(' tabular#TabularizeStrings(a:lines, ''  '', ''l0'')')

line 1:   if a:string =~ '^\s*$'[J

line 2:     return [][J

line 3:   endif[J

line 4: [J

line 5:   let end = match(a:string, "[\"'|]")[J

line 6: [J

line 7:   " Loop until we find a delimiting | or end-of-string[J

line 8:   while end != -1 && (a:string[end] != '|' || a:string[end+1] == '|')[J

line 9:     if a:string[end] == "'"[J

line 10:       let end = match(a:string, "'", end+1) + 1[J

line 11:       if end == 0[J

line 12:         throw "No matching end single quote"[J

line 13:       endif[J

line 14:     elseif a:string[end] == '"'[J

line 15:       " Find a " preceded by an even number of \ (or 0)[J

line 16:       let pattern = '\%(\\\@<!\%(\\\\\)*\)\@<="'[J

line 17:       let end = matchend(a:string, pattern, end+1) + 1[J

line 18:       if end == 0[J

line 19:         throw "No matching end double quote"[J

line 20:       endif[J

line 21:     else " Found ||[J

line 22:       let end += 2[J

line 23:     endif[J

line 24: [J

line 25:     let end = match(a:string, "[\"'|]", end)[J

line 26:   endwhile[J

line 8:   while end != -1 && (a:string[end] != '|' || a:string[end+1] == '|')[J

line 9:     if a:string[end] == "'"[J

line 10:       let end = match(a:string, "'", end+1) + 1[J

line 11:       if end == 0[J

line 12:         throw "No matching end single quote"[J

line 13:       endif[J

line 14:     elseif a:string[end] == '"'[J

line 15:       " Find a " preceded by an even number of \ (or 0)[J

line 16:       let pattern = '\%(\\\@<!\%(\\\\\)*\)\@<="'[J

line 17:       let end = matchend(a:string, pattern, end+1) + 1[J

line 18:       if end == 0[J

line 19:         throw "No matching end double quote"[J

line 20:       endif[J

line 21:     else " Found ||[J

line 22:       let end += 2[J

line 23:     endif[J

line 24: [J

line 25:     let end = match(a:string, "[\"'|]", end)[J

line 26:   endwhile[J

line 8:   while end != -1 && (a:string[end] != '|' || a:string[end+1] == '|')[J

line 9:     if a:string[end] == "'"[J

line 10:       let end = match(a:string, "'", end+1) + 1[J

line 11:       if end == 0[J

line 12:         throw "No matching end single quote"[J

line 13:       endif[J

line 14:     elseif a:string[end] == '"'[J

line 15:       " Find a " preceded by an even number of \ (or 0)[J

line 16:       let pattern = '\%(\\\@<!\%(\\\\\)*\)\@<="'[J

line 17:       let end = matchend(a:string, pattern, end+1) + 1[J

line 18:       if end == 0[J

line 19:         throw "No matching end double quote"[J

line 20:       endif[J

line 21:     else " Found ||[J

line 22:       let end += 2[J

line 23:     endif[J

line 24: [J

line 25:     let end = match(a:string, "[\"'|]", end)[J

line 26:   endwhile[J

line 27: [J

line 28:   if end == 0 || a:string[0 : end - (end > 0)] =~ '^\s*$'[J

line 29:     throw "Empty element"[J

line 30:   endif[J

line 31: [J

line 32:   if end == -1[J

line 33:     let rv = [ a:string ][J

line 34:   else[J

line 35:     let rv = [ a:string[0 : end-1] ] + s:SplitCommands(a:string[end+1 : -1])[J

line 36:   endif[J

line 37: [J

line 38:   return rv[J

function AddTabularPipeline[18]..<SNR>41_SplitCommands[35]..<SNR>41_SplitCommands returning [' tabular#TabularizeStrings(a:lines, ''  '', ''l0'')'][J

continuing in function AddTabularPipeline[18]..<SNR>41_SplitCommands[J

line 36:   endif[J

line 37: [J

line 38:   return rv[J

function AddTabularPipeline[18]..<SNR>41_SplitCommands returning [' map(a:lines, "substitute(v:val, '' ...arizeStrings(a:lines, ''  '', ''l0'')'][J

continuing in function AddTabularPipeline[J

line 19: [J

line 20:     if empty(commandlist)[J

line 21:       throw "Must provide a list of functions!"[J

line 22:     endif[J

line 23: [J

line 24:     let commandmap[name] = { 'pattern' : pattern, 'commands' : commandlist }[J

line 25:   catch[J

line 26:     echohl ErrorMsg[J

line 27:     echomsg "AddTabularPipeline: " . v:exception[J

line 28:     echohl None[J

line 29:   endtry[J

function AddTabularPipeline returning #0[J

continuing in /home/patrick/.vim/bundle/tabular/after/plugin/TabularMaps.vim[J

line 37: [J

line 41: AddTabularPipeline! argument_list   /(.*)/ map(a:lines, 'substitute(v:val, ''\s*\([(,)]\)\s*'', ''\1'', ''g'')') | tabular#TabularizeStrings(a:lines, '[(,)]', 'l0') | map(a:lines, 'substitute(v:val, ''\(\s*\),'', '',\1 '', "g")') | map(a:lines, 'substitute(v:val, ''\s*)'', ")", "g")')[J

line 41: call AddTabularPipeline("argument_list   /(.*)/ map(a:lines, 'substitute(v:val, ''\\s*\\([(,)]\\)\\s*'', ''\\1'', ''g'')') | tabular#TabularizeStrings(a:lines, '[(,)]', 'l0') | map(a:lines, 'substitute(v:val, ''\\(\\s*\\),'', '',\\1 '', \"g\")') | map(a:lines, 'substitute(v:val, ''\\s*)'', \")\", \"g\")')", !0)[J

calling function AddTabularPipeline[J('argument_list   /(.*)/ map(a:lines, '...tute(v:val, ''''\s*)'''', ")", "g")'')', 1)

line 1:   try[J

line 2:     let [ commandmap, rest ] = s:ChooseCommandMap(a:command)[J

calling function AddTabularPipeline[2]..<SNR>41_ChooseCommandMap[J('argument_list   /(.*)/ map(a:lines, '...tute(v:val, ''''\s*)'''', ")", "g")'')')

line 1:   let map = s:TabularCommands[J

line 2:   let cmd = a:commandline[J

line 3: [J

line 4:   if cmd =~# '^<buffer>\s\+'[J

line 5:     if !exists('b:TabularCommands')[J

line 6:       let b:TabularCommands = {}[J

line 7:     endif[J

line 8:     let map = b:TabularCommands[J

line 9:     let cmd = substitute(cmd, '^<buffer>\s\+', '', '')[J

line 10:   endif[J

line 11: [J

line 12:   return [ map, cmd ][J

function AddTabularPipeline[2]..<SNR>41_ChooseCommandMap returning [{'assignment': {'pattern': '[|&+*/%<>...ute(v:val, ''''\s*)'''', ")", "g")'')'][J

continuing in function AddTabularPipeline[J

line 3: [J

line 4:     let name = matchstr(rest, '.\{-}\ze\s*/')[J

line 5:     let pattern = substitute(rest, '.\{-}\s*\ze/', '', '')[J

line 6: [J

line 7:     let commands = matchstr(pattern, '^/.\{-}\\\@<!\%(\\\\\)\{-}/\zs.*')[J

line 8:     let pattern = matchstr(pattern, '/\zs.\{-}\\\@<!\%(\\\\\)\{-}\ze/')[J

line 9: [J

line 10:     if empty(name) || empty(pattern)[J

line 11:       throw "Invalid arguments!"[J

line 12:     endif[J

line 13: [J

line 14:     if !a:force && has_key(commandmap, name)[J

line 15:       throw string(name) . " is already defined, use ! to overwrite."[J

line 16:     endif[J

line 17: [J

line 18:     let commandlist = s:SplitCommands(commands)[J

calling function AddTabularPipeline[18]..<SNR>41_SplitCommands[J(' map(a:lines, ''substitute(v:val, '''...tute(v:val, ''''\s*)'''', ")", "g")'')')

line 1:   if a:string =~ '^\s*$'[J

line 2:     return [][J

line 3:   endif[J

line 4: [J

line 5:   let end = match(a:string, "[\"'|]")[J

line 6: [J

line 7:   " Loop until we find a delimiting | or end-of-string[J

line 8:   while end != -1 && (a:string[end] != '|' || a:string[end+1] == '|')[J

line 9:     if a:string[end] == "'"[J

line 10:       let end = match(a:string, "'", end+1) + 1[J

line 11:       if end == 0[J

line 12:         throw "No matching end single quote"[J

line 13:       endif[J

line 14:     elseif a:string[end] == '"'[J

line 15:       " Find a " preceded by an even number of \ (or 0)[J

line 16:       let pattern = '\%(\\\@<!\%(\\\\\)*\)\@<="'[J

line 17:       let end = matchend(a:string, pattern, end+1) + 1[J

line 18:       if end == 0[J

line 19:         throw "No matching end double quote"[J

line 20:       endif[J

line 21:     else " Found ||[J

line 22:       let end += 2[J

line 23:     endif[J

line 24: [J

line 25:     let end = match(a:string, "[\"'|]", end)[J

line 26:   endwhile[J

line 8:   while end != -1 && (a:string[end] != '|' || a:string[end+1] == '|')[J

line 9:     if a:string[end] == "'"[J

line 10:       let end = match(a:string, "'", end+1) + 1[J

line 11:       if end == 0[J

line 12:         throw "No matching end single quote"[J

line 13:       endif[J

line 14:     elseif a:string[end] == '"'[J

line 15:       " Find a " preceded by an even number of \ (or 0)[J

line 16:       let pattern = '\%(\\\@<!\%(\\\\\)*\)\@<="'[J

line 17:       let end = matchend(a:string, pattern, end+1) + 1[J

line 18:       if end == 0[J

line 19:         throw "No matching end double quote"[J

line 20:       endif[J

line 21:     else " Found ||[J

line 22:       let end += 2[J

line 23:     endif[J

line 24: [J

line 25:     let end = match(a:string, "[\"'|]", end)[J

line 26:   endwhile[J

line 8:   while end != -1 && (a:string[end] != '|' || a:string[end+1] == '|')[J

line 9:     if a:string[end] == "'"[J

line 10:       let end = match(a:string, "'", end+1) + 1[J

line 11:       if end == 0[J

line 12:         throw "No matching end single quote"[J

line 13:       endif[J

line 14:     elseif a:string[end] == '"'[J

line 15:       " Find a " preceded by an even number of \ (or 0)[J

line 16:       let pattern = '\%(\\\@<!\%(\\\\\)*\)\@<="'[J

line 17:       let end = matchend(a:string, pattern, end+1) + 1[J

line 18:       if end == 0[J

line 19:         throw "No matching end double quote"[J

line 20:       endif[J

line 21:     else " Found ||[J

line 22:       let end += 2[J

line 23:     endif[J

line 24: [J

line 25:     let end = match(a:string, "[\"'|]", end)[J

line 26:   endwhile[J

line 8:   while end != -1 && (a:string[end] != '|' || a:string[end+1] == '|')[J

line 9:     if a:string[end] == "'"[J

line 10:       let end = match(a:string, "'", end+1) + 1[J

line 11:       if end == 0[J

line 12:         throw "No matching end single quote"[J

line 13:       endif[J

line 14:     elseif a:string[end] == '"'[J

line 15:       " Find a " preceded by an even number of \ (or 0)[J

line 16:       let pattern = '\%(\\\@<!\%(\\\\\)*\)\@<="'[J

line 17:       let end = matchend(a:string, pattern, end+1) + 1[J

line 18:       if end == 0[J

line 19:         throw "No matching end double quote"[J

line 20:       endif[J

line 21:     else " Found ||[J

line 22:       let end += 2[J

line 23:     endif[J

line 24: [J

line 25:     let end = match(a:string, "[\"'|]", end)[J

line 26:   endwhile[J

line 8:   while end != -1 && (a:string[end] != '|' || a:string[end+1] == '|')[J

line 9:     if a:string[end] == "'"[J

line 10:       let end = match(a:string, "'", end+1) + 1[J

line 11:       if end == 0[J

line 12:         throw "No matching end single quote"[J

line 13:       endif[J

line 14:     elseif a:string[end] == '"'[J

line 15:       " Find a " preceded by an even number of \ (or 0)[J

line 16:       let pattern = '\%(\\\@<!\%(\\\\\)*\)\@<="'[J

line 17:       let end = matchend(a:string, pattern, end+1) + 1[J

line 18:       if end == 0[J

line 19:         throw "No matching end double quote"[J

line 20:       endif[J

line 21:     else " Found ||[J

line 22:       let end += 2[J

line 23:     endif[J

line 24: [J

line 25:     let end = match(a:string, "[\"'|]", end)[J

line 26:   endwhile[J

line 8:   while end != -1 && (a:string[end] != '|' || a:string[end+1] == '|')[J

line 9:     if a:string[end] == "'"[J

line 10:       let end = match(a:string, "'", end+1) + 1[J

line 11:       if end == 0[J

line 12:         throw "No matching end single quote"[J

line 13:       endif[J

line 14:     elseif a:string[end] == '"'[J

line 15:       " Find a " preceded by an even number of \ (or 0)[J

line 16:       let pattern = '\%(\\\@<!\%(\\\\\)*\)\@<="'[J

line 17:       let end = matchend(a:string, pattern, end+1) + 1[J

line 18:       if end == 0[J

line 19:         throw "No matching end double quote"[J

line 20:       endif[J

line 21:     else " Found ||[J

line 22:       let end += 2[J

line 23:     endif[J

line 24: [J

line 25:     let end = match(a:string, "[\"'|]", end)[J

line 26:   endwhile[J

line 8:   while end != -1 && (a:string[end] != '|' || a:string[end+1] == '|')[J

line 9:     if a:string[end] == "'"[J

line 10:       let end = match(a:string, "'", end+1) + 1[J

line 11:       if end == 0[J

line 12:         throw "No matching end single quote"[J

line 13:       endif[J

line 14:     elseif a:string[end] == '"'[J

line 15:       " Find a " preceded by an even number of \ (or 0)[J

line 16:       let pattern = '\%(\\\@<!\%(\\\\\)*\)\@<="'[J

line 17:       let end = matchend(a:string, pattern, end+1) + 1[J

line 18:       if end == 0[J

line 19:         throw "No matching end double quote"[J

line 20:       endif[J

line 21:     else " Found ||[J

line 22:       let end += 2[J

line 23:     endif[J

line 24: [J

line 25:     let end = match(a:string, "[\"'|]", end)[J

line 26:   endwhile[J

line 8:   while end != -1 && (a:string[end] != '|' || a:string[end+1] == '|')[J

line 9:     if a:string[end] == "'"[J

line 10:       let end = match(a:string, "'", end+1) + 1[J

line 11:       if end == 0[J

line 12:         throw "No matching end single quote"[J

line 13:       endif[J

line 14:     elseif a:string[end] == '"'[J

line 15:       " Find a " preceded by an even number of \ (or 0)[J

line 16:       let pattern = '\%(\\\@<!\%(\\\\\)*\)\@<="'[J

line 17:       let end = matchend(a:string, pattern, end+1) + 1[J

line 18:       if end == 0[J

line 19:         throw "No matching end double quote"[J

line 20:       endif[J

line 21:     else " Found ||[J

line 22:       let end += 2[J

line 23:     endif[J

line 24: [J

line 25:     let end = match(a:string, "[\"'|]", end)[J

line 26:   endwhile[J

line 27: [J

line 28:   if end == 0 || a:string[0 : end - (end > 0)] =~ '^\s*$'[J

line 29:     throw "Empty element"[J

line 30:   endif[J

line 31: [J

line 32:   if end == -1[J

line 33:     let rv = [ a:string ][J

line 34:   else[J

line 35:     let rv = [ a:string[0 : end-1] ] + s:SplitCommands(a:string[end+1 : -1])[J

calling function AddTabularPipeline[18]..<SNR>41_SplitCommands[35]..<SNR>41_SplitCommands[J(' tabular#TabularizeStrings(a:lines, '...tute(v:val, ''''\s*)'''', ")", "g")'')')

line 1:   if a:string =~ '^\s*$'[J

line 2:     return [][J

line 3:   endif[J

line 4: [J

line 5:   let end = match(a:string, "[\"'|]")[J

line 6: [J

line 7:   " Loop until we find a delimiting | or end-of-string[J

line 8:   while end != -1 && (a:string[end] != '|' || a:string[end+1] == '|')[J

line 9:     if a:string[end] == "'"[J

line 10:       let end = match(a:string, "'", end+1) + 1[J

line 11:       if end == 0[J

line 12:         throw "No matching end single quote"[J

line 13:       endif[J

line 14:     elseif a:string[end] == '"'[J

line 15:       " Find a " preceded by an even number of \ (or 0)[J

line 16:       let pattern = '\%(\\\@<!\%(\\\\\)*\)\@<="'[J

line 17:       let end = matchend(a:string, pattern, end+1) + 1[J

line 18:       if end == 0[J

line 19:         throw "No matching end double quote"[J

line 20:       endif[J

line 21:     else " Found ||[J

line 22:       let end += 2[J

line 23:     endif[J

line 24: [J

line 25:     let end = match(a:string, "[\"'|]", end)[J

line 26:   endwhile[J

line 8:   while end != -1 && (a:string[end] != '|' || a:string[end+1] == '|')[J

line 9:     if a:string[end] == "'"[J

line 10:       let end = match(a:string, "'", end+1) + 1[J

line 11:       if end == 0[J

line 12:         throw "No matching end single quote"[J

line 13:       endif[J

line 14:     elseif a:string[end] == '"'[J

line 15:       " Find a " preceded by an even number of \ (or 0)[J

line 16:       let pattern = '\%(\\\@<!\%(\\\\\)*\)\@<="'[J

line 17:       let end = matchend(a:string, pattern, end+1) + 1[J

line 18:       if end == 0[J

line 19:         throw "No matching end double quote"[J

line 20:       endif[J

line 21:     else " Found ||[J

line 22:       let end += 2[J

line 23:     endif[J

line 24: [J

line 25:     let end = match(a:string, "[\"'|]", end)[J

line 26:   endwhile[J

line 8:   while end != -1 && (a:string[end] != '|' || a:string[end+1] == '|')[J

line 9:     if a:string[end] == "'"[J

line 10:       let end = match(a:string, "'", end+1) + 1[J

line 11:       if end == 0[J

line 12:         throw "No matching end single quote"[J

line 13:       endif[J

line 14:     elseif a:string[end] == '"'[J

line 15:       " Find a " preceded by an even number of \ (or 0)[J

line 16:       let pattern = '\%(\\\@<!\%(\\\\\)*\)\@<="'[J

line 17:       let end = matchend(a:string, pattern, end+1) + 1[J

line 18:       if end == 0[J

line 19:         throw "No matching end double quote"[J

line 20:       endif[J

line 21:     else " Found ||[J

line 22:       let end += 2[J

line 23:     endif[J

line 24: [J

line 25:     let end = match(a:string, "[\"'|]", end)[J

line 26:   endwhile[J

line 27: [J

line 28:   if end == 0 || a:string[0 : end - (end > 0)] =~ '^\s*$'[J

line 29:     throw "Empty element"[J

line 30:   endif[J

line 31: [J

line 32:   if end == -1[J

line 33:     let rv = [ a:string ][J

line 34:   else[J

line 35:     let rv = [ a:string[0 : end-1] ] + s:SplitCommands(a:string[end+1 : -1])[J

calling function AddTabularPipeline[18]..<SNR>41_SplitCommands[35]..<SNR>41_SplitCommands[35]..<SNR>41_SplitCommands[J(' map(a:lines, ''substitute(v:val, '''...tute(v:val, ''''\s*)'''', ")", "g")'')')

line 1:   if a:string =~ '^\s*$'[J

line 2:     return [][J

line 3:   endif[J

line 4: [J

line 5:   let end = match(a:string, "[\"'|]")[J

line 6: [J

line 7:   " Loop until we find a delimiting | or end-of-string[J

line 8:   while end != -1 && (a:string[end] != '|' || a:string[end+1] == '|')[J

line 9:     if a:string[end] == "'"[J

line 10:       let end = match(a:string, "'", end+1) + 1[J

line 11:       if end == 0[J

line 12:         throw "No matching end single quote"[J

line 13:       endif[J

line 14:     elseif a:string[end] == '"'[J

line 15:       " Find a " preceded by an even number of \ (or 0)[J

line 16:       let pattern = '\%(\\\@<!\%(\\\\\)*\)\@<="'[J

line 17:       let end = matchend(a:string, pattern, end+1) + 1[J

line 18:       if end == 0[J

line 19:         throw "No matching end double quote"[J

line 20:       endif[J

line 21:     else " Found ||[J

line 22:       let end += 2[J

line 23:     endif[J

line 24: [J

line 25:     let end = match(a:string, "[\"'|]", end)[J

line 26:   endwhile[J

line 8:   while end != -1 && (a:string[end] != '|' || a:string[end+1] == '|')[J

line 9:     if a:string[end] == "'"[J

line 10:       let end = match(a:string, "'", end+1) + 1[J

line 11:       if end == 0[J

line 12:         throw "No matching end single quote"[J

line 13:       endif[J

line 14:     elseif a:string[end] == '"'[J

line 15:       " Find a " preceded by an even number of \ (or 0)[J

line 16:       let pattern = '\%(\\\@<!\%(\\\\\)*\)\@<="'[J

line 17:       let end = matchend(a:string, pattern, end+1) + 1[J

line 18:       if end == 0[J

line 19:         throw "No matching end double quote"[J

line 20:       endif[J

line 21:     else " Found ||[J

line 22:       let end += 2[J

line 23:     endif[J

line 24: [J

line 25:     let end = match(a:string, "[\"'|]", end)[J

line 26:   endwhile[J

line 8:   while end != -1 && (a:string[end] != '|' || a:string[end+1] == '|')[J

line 9:     if a:string[end] == "'"[J

line 10:       let end = match(a:string, "'", end+1) + 1[J

line 11:       if end == 0[J

line 12:         throw "No matching end single quote"[J

line 13:       endif[J

line 14:     elseif a:string[end] == '"'[J

line 15:       " Find a " preceded by an even number of \ (or 0)[J

line 16:       let pattern = '\%(\\\@<!\%(\\\\\)*\)\@<="'[J

line 17:       let end = matchend(a:string, pattern, end+1) + 1[J

line 18:       if end == 0[J

line 19:         throw "No matching end double quote"[J

line 20:       endif[J

line 21:     else " Found ||[J

line 22:       let end += 2[J

line 23:     endif[J

line 24: [J

line 25:     let end = match(a:string, "[\"'|]", end)[J

line 26:   endwhile[J

line 8:   while end != -1 && (a:string[end] != '|' || a:string[end+1] == '|')[J

line 9:     if a:string[end] == "'"[J

line 10:       let end = match(a:string, "'", end+1) + 1[J

line 11:       if end == 0[J

line 12:         throw "No matching end single quote"[J

line 13:       endif[J

line 14:     elseif a:string[end] == '"'[J

line 15:       " Find a " preceded by an even number of \ (or 0)[J

line 16:       let pattern = '\%(\\\@<!\%(\\\\\)*\)\@<="'[J

line 17:       let end = matchend(a:string, pattern, end+1) + 1[J

line 18:       if end == 0[J

line 19:         throw "No matching end double quote"[J

line 20:       endif[J

line 21:     else " Found ||[J

line 22:       let end += 2[J

line 23:     endif[J

line 24: [J

line 25:     let end = match(a:string, "[\"'|]", end)[J

line 26:   endwhile[J

line 8:   while end != -1 && (a:string[end] != '|' || a:string[end+1] == '|')[J

line 9:     if a:string[end] == "'"[J

line 10:       let end = match(a:string, "'", end+1) + 1[J

line 11:       if end == 0[J

line 12:         throw "No matching end single quote"[J

line 13:       endif[J

line 14:     elseif a:string[end] == '"'[J

line 15:       " Find a " preceded by an even number of \ (or 0)[J

line 16:       let pattern = '\%(\\\@<!\%(\\\\\)*\)\@<="'[J

line 17:       let end = matchend(a:string, pattern, end+1) + 1[J

line 18:       if end == 0[J

line 19:         throw "No matching end double quote"[J

line 20:       endif[J

line 21:     else " Found ||[J

line 22:       let end += 2[J

line 23:     endif[J

line 24: [J

line 25:     let end = match(a:string, "[\"'|]", end)[J

line 26:   endwhile[J

line 8:   while end != -1 && (a:string[end] != '|' || a:string[end+1] == '|')[J

line 9:     if a:string[end] == "'"[J

line 10:       let end = match(a:string, "'", end+1) + 1[J

line 11:       if end == 0[J

line 12:         throw "No matching end single quote"[J

line 13:       endif[J

line 14:     elseif a:string[end] == '"'[J

line 15:       " Find a " preceded by an even number of \ (or 0)[J

line 16:       let pattern = '\%(\\\@<!\%(\\\\\)*\)\@<="'[J

line 17:       let end = matchend(a:string, pattern, end+1) + 1[J

line 18:       if end == 0[J

line 19:         throw "No matching end double quote"[J

line 20:       endif[J

line 21:     else " Found ||[J

line 22:       let end += 2[J

line 23:     endif[J

line 24: [J

line 25:     let end = match(a:string, "[\"'|]", end)[J

line 26:   endwhile[J

line 27: [J

line 28:   if end == 0 || a:string[0 : end - (end > 0)] =~ '^\s*$'[J

line 29:     throw "Empty element"[J

line 30:   endif[J

line 31: [J

line 32:   if end == -1[J

line 33:     let rv = [ a:string ][J

line 34:   else[J

line 35:     let rv = [ a:string[0 : end-1] ] + s:SplitCommands(a:string[end+1 : -1])[J

calling function AddTabularPipeline[18]..<SNR>41_SplitCommands[35]..<SNR>41_SplitCommands[35]..<SNR>41_SplitCommands[35]..<SNR>41_SplitCommands[J(' map(a:lines, ''substitute(v:val, ''''\s*)'''', ")", "g")'')')

line 1:   if a:string =~ '^\s*$'[J

line 2:     return [][J

line 3:   endif[J

line 4: [J

line 5:   let end = match(a:string, "[\"'|]")[J

line 6: [J

line 7:   " Loop until we find a delimiting | or end-of-string[J

line 8:   while end != -1 && (a:string[end] != '|' || a:string[end+1] == '|')[J

line 9:     if a:string[end] == "'"[J

line 10:       let end = match(a:string, "'", end+1) + 1[J

line 11:       if end == 0[J

line 12:         throw "No matching end single quote"[J

line 13:       endif[J

line 14:     elseif a:string[end] == '"'[J

line 15:       " Find a " preceded by an even number of \ (or 0)[J

line 16:       let pattern = '\%(\\\@<!\%(\\\\\)*\)\@<="'[J

line 17:       let end = matchend(a:string, pattern, end+1) + 1[J

line 18:       if end == 0[J

line 19:         throw "No matching end double quote"[J

line 20:       endif[J

line 21:     else " Found ||[J

line 22:       let end += 2[J

line 23:     endif[J

line 24: [J

line 25:     let end = match(a:string, "[\"'|]", end)[J

line 26:   endwhile[J

line 8:   while end != -1 && (a:string[end] != '|' || a:string[end+1] == '|')[J

line 9:     if a:string[end] == "'"[J

line 10:       let end = match(a:string, "'", end+1) + 1[J

line 11:       if end == 0[J

line 12:         throw "No matching end single quote"[J

line 13:       endif[J

line 14:     elseif a:string[end] == '"'[J

line 15:       " Find a " preceded by an even number of \ (or 0)[J

line 16:       let pattern = '\%(\\\@<!\%(\\\\\)*\)\@<="'[J

line 17:       let end = matchend(a:string, pattern, end+1) + 1[J

line 18:       if end == 0[J

line 19:         throw "No matching end double quote"[J

line 20:       endif[J

line 21:     else " Found ||[J

line 22:       let end += 2[J

line 23:     endif[J

line 24: [J

line 25:     let end = match(a:string, "[\"'|]", end)[J

line 26:   endwhile[J

line 8:   while end != -1 && (a:string[end] != '|' || a:string[end+1] == '|')[J

line 9:     if a:string[end] == "'"[J

line 10:       let end = match(a:string, "'", end+1) + 1[J

line 11:       if end == 0[J

line 12:         throw "No matching end single quote"[J

line 13:       endif[J

line 14:     elseif a:string[end] == '"'[J

line 15:       " Find a " preceded by an even number of \ (or 0)[J

line 16:       let pattern = '\%(\\\@<!\%(\\\\\)*\)\@<="'[J

line 17:       let end = matchend(a:string, pattern, end+1) + 1[J

line 18:       if end == 0[J

line 19:         throw "No matching end double quote"[J

line 20:       endif[J

line 21:     else " Found ||[J

line 22:       let end += 2[J

line 23:     endif[J

line 24: [J

line 25:     let end = match(a:string, "[\"'|]", end)[J

line 26:   endwhile[J

line 8:   while end != -1 && (a:string[end] != '|' || a:string[end+1] == '|')[J

line 9:     if a:string[end] == "'"[J

line 10:       let end = match(a:string, "'", end+1) + 1[J

line 11:       if end == 0[J

line 12:         throw "No matching end single quote"[J

line 13:       endif[J

line 14:     elseif a:string[end] == '"'[J

line 15:       " Find a " preceded by an even number of \ (or 0)[J

line 16:       let pattern = '\%(\\\@<!\%(\\\\\)*\)\@<="'[J

line 17:       let end = matchend(a:string, pattern, end+1) + 1[J

line 18:       if end == 0[J

line 19:         throw "No matching end double quote"[J

line 20:       endif[J

line 21:     else " Found ||[J

line 22:       let end += 2[J

line 23:     endif[J

line 24: [J

line 25:     let end = match(a:string, "[\"'|]", end)[J

line 26:   endwhile[J

line 27: [J

line 28:   if end == 0 || a:string[0 : end - (end > 0)] =~ '^\s*$'[J

line 29:     throw "Empty element"[J

line 30:   endif[J

line 31: [J

line 32:   if end == -1[J

line 33:     let rv = [ a:string ][J

line 34:   else[J

line 35:     let rv = [ a:string[0 : end-1] ] + s:SplitCommands(a:string[end+1 : -1])[J

line 36:   endif[J

line 37: [J

line 38:   return rv[J

function AddTabularPipeline[18]..<SNR>41_SplitCommands[35]..<SNR>41_SplitCommands[35]..<SNR>41_SplitCommands[35]..<SNR>41_SplitCommands returning [' map(a:lines, ''substitute(v:val, ''''\s*)'''', ")", "g")'')'][J

continuing in function AddTabularPipeline[18]..<SNR>41_SplitCommands[35]..<SNR>41_SplitCommands[35]..<SNR>41_SplitCommands[J

line 36:   endif[J

line 37: [J

line 38:   return rv[J

function AddTabularPipeline[18]..<SNR>41_SplitCommands[35]..<SNR>41_SplitCommands[35]..<SNR>41_SplitCommands returning [' map(a:lines, ''substitute(v:val, ''...ute(v:val, ''''\s*)'''', ")", "g")'')'][J

continuing in function AddTabularPipeline[18]..<SNR>41_SplitCommands[35]..<SNR>41_SplitCommands[J

line 36:   endif[J

line 37: [J

line 38:   return rv[J

function AddTabularPipeline[18]..<SNR>41_SplitCommands[35]..<SNR>41_SplitCommands returning [' tabular#TabularizeStrings(a:lines, ...ute(v:val, ''''\s*)'''', ")", "g")'')'][J

continuing in function AddTabularPipeline[18]..<SNR>41_SplitCommands[J

line 36:   endif[J

line 37: [J

line 38:   return rv[J

function AddTabularPipeline[18]..<SNR>41_SplitCommands returning [' map(a:lines, ''substitute(v:val, ''...ute(v:val, ''''\s*)'''', ")", "g")'')'][J

continuing in function AddTabularPipeline[J

line 19: [J

line 20:     if empty(commandlist)[J

line 21:       throw "Must provide a list of functions!"[J

line 22:     endif[J

line 23: [J

line 24:     let commandmap[name] = { 'pattern' : pattern, 'commands' : commandlist }[J

line 25:   catch[J

line 26:     echohl ErrorMsg[J

line 27:     echomsg "AddTabularPipeline: " . v:exception[J

line 28:     echohl None[J

line 29:   endtry[J

function AddTabularPipeline returning #0[J

continuing in /home/patrick/.vim/bundle/tabular/after/plugin/TabularMaps.vim[J

line 42: [J

line 43: function! SplitCDeclarations(lines)[J

line 61: [J

line 62: AddTabularPipeline! split_declarations /,.*;/ SplitCDeclarations(a:lines)[J

line 62: call AddTabularPipeline("split_declarations /,.*;/ SplitCDeclarations(a:lines)", !0)[J

calling function AddTabularPipeline[J('split_declarations /,.*;/ SplitCDeclarations(a:lines)', 1)

line 1:   try[J

line 2:     let [ commandmap, rest ] = s:ChooseCommandMap(a:command)[J

calling function AddTabularPipeline[2]..<SNR>41_ChooseCommandMap[J('split_declarations /,.*;/ SplitCDeclarations(a:lines)')

line 1:   let map = s:TabularCommands[J

line 2:   let cmd = a:commandline[J

line 3: [J

line 4:   if cmd =~# '^<buffer>\s\+'[J

line 5:     if !exists('b:TabularCommands')[J

line 6:       let b:TabularCommands = {}[J

line 7:     endif[J

line 8:     let map = b:TabularCommands[J

line 9:     let cmd = substitute(cmd, '^<buffer>\s\+', '', '')[J

line 10:   endif[J

line 11: [J

line 12:   return [ map, cmd ][J

function AddTabularPipeline[2]..<SNR>41_ChooseCommandMap returning [{'assignment': {'pattern': '[|&+*/%<>...ns /,.*;/ SplitCDeclarations(a:lines)'][J

continuing in function AddTabularPipeline[J

line 3: [J

line 4:     let name = matchstr(rest, '.\{-}\ze\s*/')[J

line 5:     let pattern = substitute(rest, '.\{-}\s*\ze/', '', '')[J

line 6: [J

line 7:     let commands = matchstr(pattern, '^/.\{-}\\\@<!\%(\\\\\)\{-}/\zs.*')[J

line 8:     let pattern = matchstr(pattern, '/\zs.\{-}\\\@<!\%(\\\\\)\{-}\ze/')[J

line 9: [J

line 10:     if empty(name) || empty(pattern)[J

line 11:       throw "Invalid arguments!"[J

line 12:     endif[J

line 13: [J

line 14:     if !a:force && has_key(commandmap, name)[J

line 15:       throw string(name) . " is already defined, use ! to overwrite."[J

line 16:     endif[J

line 17: [J

line 18:     let commandlist = s:SplitCommands(commands)[J

calling function AddTabularPipeline[18]..<SNR>41_SplitCommands[J(' SplitCDeclarations(a:lines)')

line 1:   if a:string =~ '^\s*$'[J

line 2:     return [][J

line 3:   endif[J

line 4: [J

line 5:   let end = match(a:string, "[\"'|]")[J

line 6: [J

line 7:   " Loop until we find a delimiting | or end-of-string[J

line 8:   while end != -1 && (a:string[end] != '|' || a:string[end+1] == '|')[J

line 9:     if a:string[end] == "'"[J

line 10:       let end = match(a:string, "'", end+1) + 1[J

line 11:       if end == 0[J

line 12:         throw "No matching end single quote"[J

line 13:       endif[J

line 14:     elseif a:string[end] == '"'[J

line 15:       " Find a " preceded by an even number of \ (or 0)[J

line 16:       let pattern = '\%(\\\@<!\%(\\\\\)*\)\@<="'[J

line 17:       let end = matchend(a:string, pattern, end+1) + 1[J

line 18:       if end == 0[J

line 19:         throw "No matching end double quote"[J

line 20:       endif[J

line 21:     else " Found ||[J

line 22:       let end += 2[J

line 23:     endif[J

line 24: [J

line 25:     let end = match(a:string, "[\"'|]", end)[J

line 26:   endwhile[J

line 27: [J

line 28:   if end == 0 || a:string[0 : end - (end > 0)] =~ '^\s*$'[J

line 29:     throw "Empty element"[J

line 30:   endif[J

line 31: [J

line 32:   if end == -1[J

line 33:     let rv = [ a:string ][J

line 34:   else[J

line 35:     let rv = [ a:string[0 : end-1] ] + s:SplitCommands(a:string[end+1 : -1])[J

line 36:   endif[J

line 37: [J

line 38:   return rv[J

function AddTabularPipeline[18]..<SNR>41_SplitCommands returning [' SplitCDeclarations(a:lines)'][J

continuing in function AddTabularPipeline[J

line 19: [J

line 20:     if empty(commandlist)[J

line 21:       throw "Must provide a list of functions!"[J

line 22:     endif[J

line 23: [J

line 24:     let commandmap[name] = { 'pattern' : pattern, 'commands' : commandlist }[J

line 25:   catch[J

line 26:     echohl ErrorMsg[J

line 27:     echomsg "AddTabularPipeline: " . v:exception[J

line 28:     echohl None[J

line 29:   endtry[J

function AddTabularPipeline returning #0[J

continuing in /home/patrick/.vim/bundle/tabular/after/plugin/TabularMaps.vim[J

line 63: [J

line 64: AddTabularPattern! ternary_operator /^.\{-}\zs?\|:/l1[J

line 64: call AddTabularPattern("ternary_operator /^.\\{-}\\zs?\\|:/l1", !0)[J

calling function AddTabularPattern[J('ternary_operator /^.\{-}\zs?\|:/l1', 1)

line 1:   try[J

line 2:     let [ commandmap, rest ] = s:ChooseCommandMap(a:command)[J

calling function AddTabularPattern[2]..<SNR>41_ChooseCommandMap[J('ternary_operator /^.\{-}\zs?\|:/l1')

line 1:   let map = s:TabularCommands[J

line 2:   let cmd = a:commandline[J

line 3: [J

line 4:   if cmd =~# '^<buffer>\s\+'[J

line 5:     if !exists('b:TabularCommands')[J

line 6:       let b:TabularCommands = {}[J

line 7:     endif[J

line 8:     let map = b:TabularCommands[J

line 9:     let cmd = substitute(cmd, '^<buffer>\s\+', '', '')[J

line 10:   endif[J

line 11: [J

line 12:   return [ map, cmd ][J

function AddTabularPattern[2]..<SNR>41_ChooseCommandMap returning [{'assignment': {'pattern': '[|&+*/%<>..., 'ternary_operator /^.\{-}\zs?\|:/l1'][J

continuing in function AddTabularPattern[J

line 3: [J

line 4:     let name = matchstr(rest, '.\{-}\ze\s*/')[J

line 5:     let pattern = substitute(rest, '.\{-}\s*\ze/', '', '')[J

line 6: [J

line 7:     let [ pattern, format ] = s:ParsePattern(pattern)[J

calling function AddTabularPattern[7]..<SNR>41_ParsePattern[J('/^.\{-}\zs?\|:/l1')

line 1:   if a:string[0] != '/'[J

line 2:     return ['',''][J

line 3:   endif[J

line 4: [J

line 5:   let pat = '\\\@<!\%(\\\\\)\{-}\zs/' . tabular#ElementFormatPattern() . '*$'[J

calling function AddTabularPattern[7]..<SNR>41_ParsePattern[5]..tabular#ElementFormatPattern[J()

line 1:   return s:formatelempat[J

function AddTabularPattern[7]..<SNR>41_ParsePattern[5]..tabular#ElementFormatPattern returning '\%([lrc]\d\+\)'[J

continuing in function AddTabularPattern[7]..<SNR>41_ParsePattern[J

line 6:   let format = matchstr(a:string[1:-1], pat)[J

line 7:   if !empty(format)[J

line 8:     let format = format[1 : -1][J

line 9:     let pattern = a:string[1 : -len(format) - 2][J

line 10:   else[J

line 11:     let pattern = a:string[1 : -1][J

line 12:   endif[J

line 13: [J

line 14:   return [pattern, format][J

function AddTabularPattern[7]..<SNR>41_ParsePattern returning ['^.\{-}\zs?\|:', 'l1'][J

continuing in function AddTabularPattern[J

line 8: [J

line 9:     if empty(name) || empty(pattern)[J

line 10:       throw "Invalid arguments!"[J

line 11:     endif[J

line 12: [J

line 13:     if !a:force && has_key(commandmap, name)[J

line 14:       throw string(name) . " is already defined, use ! to overwrite."[J

line 15:     endif[J

line 16: [J

line 17:     let command = "tabular#TabularizeStrings(a:lines, " . string(pattern)[J

line 18: [J

line 19:     if !empty(format)[J

line 20:       let command .=  ", " . string(format)[J

line 21:     endif[J

line 22: [J

line 23:     let command .= ")"[J

line 24: [J

line 25:     let commandmap[name] = { 'pattern' : pattern, 'commands' : [ command ] }[J

line 26:   catch[J

line 27:     echohl ErrorMsg[J

line 28:     echomsg "AddTabularPattern: " . v:exception[J

line 29:     echohl None[J

line 30:   endtry[J

function AddTabularPattern returning #0[J

continuing in /home/patrick/.vim/bundle/tabular/after/plugin/TabularMaps.vim[J

line 65: [J

line 66: AddTabularPattern! cpp_io /<<\|>>/l1[J

line 66: call AddTabularPattern("cpp_io /<<\\|>>/l1", !0)[J

calling function AddTabularPattern[J('cpp_io /<<\|>>/l1', 1)

line 1:   try[J

line 2:     let [ commandmap, rest ] = s:ChooseCommandMap(a:command)[J

calling function AddTabularPattern[2]..<SNR>41_ChooseCommandMap[J('cpp_io /<<\|>>/l1')

line 1:   let map = s:TabularCommands[J

line 2:   let cmd = a:commandline[J

line 3: [J

line 4:   if cmd =~# '^<buffer>\s\+'[J

line 5:     if !exists('b:TabularCommands')[J

line 6:       let b:TabularCommands = {}[J

line 7:     endif[J

line 8:     let map = b:TabularCommands[J

line 9:     let cmd = substitute(cmd, '^<buffer>\s\+', '', '')[J

line 10:   endif[J

line 11: [J

line 12:   return [ map, cmd ][J

function AddTabularPattern[2]..<SNR>41_ChooseCommandMap returning [{'ternary_operator': {'pattern': '^.\...ions(a:lines)']}}, 'cpp_io /<<\|>>/l1'][J

continuing in function AddTabularPattern[J

line 3: [J

line 4:     let name = matchstr(rest, '.\{-}\ze\s*/')[J

line 5:     let pattern = substitute(rest, '.\{-}\s*\ze/', '', '')[J

line 6: [J

line 7:     let [ pattern, format ] = s:ParsePattern(pattern)[J

calling function AddTabularPattern[7]..<SNR>41_ParsePattern[J('/<<\|>>/l1')

line 1:   if a:string[0] != '/'[J

line 2:     return ['',''][J

line 3:   endif[J

line 4: [J

line 5:   let pat = '\\\@<!\%(\\\\\)\{-}\zs/' . tabular#ElementFormatPattern() . '*$'[J

calling function AddTabularPattern[7]..<SNR>41_ParsePattern[5]..tabular#ElementFormatPattern[J()

line 1:   return s:formatelempat[J

function AddTabularPattern[7]..<SNR>41_ParsePattern[5]..tabular#ElementFormatPattern returning '\%([lrc]\d\+\)'[J

continuing in function AddTabularPattern[7]..<SNR>41_ParsePattern[J

line 6:   let format = matchstr(a:string[1:-1], pat)[J

line 7:   if !empty(format)[J

line 8:     let format = format[1 : -1][J

line 9:     let pattern = a:string[1 : -len(format) - 2][J

line 10:   else[J

line 11:     let pattern = a:string[1 : -1][J

line 12:   endif[J

line 13: [J

line 14:   return [pattern, format][J

function AddTabularPattern[7]..<SNR>41_ParsePattern returning ['<<\|>>', 'l1'][J

continuing in function AddTabularPattern[J

line 8: [J

line 9:     if empty(name) || empty(pattern)[J

line 10:       throw "Invalid arguments!"[J

line 11:     endif[J

line 12: [J

line 13:     if !a:force && has_key(commandmap, name)[J

line 14:       throw string(name) . " is already defined, use ! to overwrite."[J

line 15:     endif[J

line 16: [J

line 17:     let command = "tabular#TabularizeStrings(a:lines, " . string(pattern)[J

line 18: [J

line 19:     if !empty(format)[J

line 20:       let command .=  ", " . string(format)[J

line 21:     endif[J

line 22: [J

line 23:     let command .= ")"[J

line 24: [J

line 25:     let commandmap[name] = { 'pattern' : pattern, 'commands' : [ command ] }[J

line 26:   catch[J

line 27:     echohl ErrorMsg[J

line 28:     echomsg "AddTabularPattern: " . v:exception[J

line 29:     echohl None[J

line 30:   endtry[J

function AddTabularPattern returning #0[J

continuing in /home/patrick/.vim/bundle/tabular/after/plugin/TabularMaps.vim[J

line 67: [J

line 68: AddTabularPattern! pascal_assign /:=/l1[J

line 68: call AddTabularPattern("pascal_assign /:=/l1", !0)[J

calling function AddTabularPattern[J('pascal_assign /:=/l1', 1)

line 1:   try[J

line 2:     let [ commandmap, rest ] = s:ChooseCommandMap(a:command)[J

calling function AddTabularPattern[2]..<SNR>41_ChooseCommandMap[J('pascal_assign /:=/l1')

line 1:   let map = s:TabularCommands[J

line 2:   let cmd = a:commandline[J

line 3: [J

line 4:   if cmd =~# '^<buffer>\s\+'[J

line 5:     if !exists('b:TabularCommands')[J

line 6:       let b:TabularCommands = {}[J

line 7:     endif[J

line 8:     let map = b:TabularCommands[J

line 9:     let cmd = substitute(cmd, '^<buffer>\s\+', '', '')[J

line 10:   endif[J

line 11: [J

line 12:   return [ map, cmd ][J

function AddTabularPattern[2]..<SNR>41_ChooseCommandMap returning [{'ternary_operator': {'pattern': '^.\...s(a:lines)']}}, 'pascal_assign /:=/l1'][J

continuing in function AddTabularPattern[J

line 3: [J

line 4:     let name = matchstr(rest, '.\{-}\ze\s*/')[J

line 5:     let pattern = substitute(rest, '.\{-}\s*\ze/', '', '')[J

line 6: [J

line 7:     let [ pattern, format ] = s:ParsePattern(pattern)[J

calling function AddTabularPattern[7]..<SNR>41_ParsePattern[J('/:=/l1')

line 1:   if a:string[0] != '/'[J

line 2:     return ['',''][J

line 3:   endif[J

line 4: [J

line 5:   let pat = '\\\@<!\%(\\\\\)\{-}\zs/' . tabular#ElementFormatPattern() . '*$'[J

calling function AddTabularPattern[7]..<SNR>41_ParsePattern[5]..tabular#ElementFormatPattern[J()

line 1:   return s:formatelempat[J

function AddTabularPattern[7]..<SNR>41_ParsePattern[5]..tabular#ElementFormatPattern returning '\%([lrc]\d\+\)'[J

continuing in function AddTabularPattern[7]..<SNR>41_ParsePattern[J

line 6:   let format = matchstr(a:string[1:-1], pat)[J

line 7:   if !empty(format)[J

line 8:     let format = format[1 : -1][J

line 9:     let pattern = a:string[1 : -len(format) - 2][J

line 10:   else[J

line 11:     let pattern = a:string[1 : -1][J

line 12:   endif[J

line 13: [J

line 14:   return [pattern, format][J

function AddTabularPattern[7]..<SNR>41_ParsePattern returning [':=', 'l1'][J

continuing in function AddTabularPattern[J

line 8: [J

line 9:     if empty(name) || empty(pattern)[J

line 10:       throw "Invalid arguments!"[J

line 11:     endif[J

line 12: [J

line 13:     if !a:force && has_key(commandmap, name)[J

line 14:       throw string(name) . " is already defined, use ! to overwrite."[J

line 15:     endif[J

line 16: [J

line 17:     let command = "tabular#TabularizeStrings(a:lines, " . string(pattern)[J

line 18: [J

line 19:     if !empty(format)[J

line 20:       let command .=  ", " . string(format)[J

line 21:     endif[J

line 22: [J

line 23:     let command .= ")"[J

line 24: [J

line 25:     let commandmap[name] = { 'pattern' : pattern, 'commands' : [ command ] }[J

line 26:   catch[J

line 27:     echohl ErrorMsg[J

line 28:     echomsg "AddTabularPattern: " . v:exception[J

line 29:     echohl None[J

line 30:   endtry[J

function AddTabularPattern returning #0[J

continuing in /home/patrick/.vim/bundle/tabular/after/plugin/TabularMaps.vim[J

line 69: [J

line 70: AddTabularPattern! trailing_c_comments /\/\*\|\*\/\|\/\//l1[J

line 70: call AddTabularPattern("trailing_c_comments /\\/\\*\\|\\*\\/\\|\\/\\//l1", !0)[J

calling function AddTabularPattern[J('trailing_c_comments /\/\*\|\*\/\|\/\//l1', 1)

line 1:   try[J

line 2:     let [ commandmap, rest ] = s:ChooseCommandMap(a:command)[J

calling function AddTabularPattern[2]..<SNR>41_ChooseCommandMap[J('trailing_c_comments /\/\*\|\*\/\|\/\//l1')

line 1:   let map = s:TabularCommands[J

line 2:   let cmd = a:commandline[J

line 3: [J

line 4:   if cmd =~# '^<buffer>\s\+'[J

line 5:     if !exists('b:TabularCommands')[J

line 6:       let b:TabularCommands = {}[J

line 7:     endif[J

line 8:     let map = b:TabularCommands[J

line 9:     let cmd = substitute(cmd, '^<buffer>\s\+', '', '')[J

line 10:   endif[J

line 11: [J

line 12:   return [ map, cmd ][J

function AddTabularPattern[2]..<SNR>41_ChooseCommandMap returning [{'ternary_operator': {'pattern': '^.\...iling_c_comments /\/\*\|\*\/\|\/\//l1'][J

continuing in function AddTabularPattern[J

line 3: [J

line 4:     let name = matchstr(rest, '.\{-}\ze\s*/')[J

line 5:     let pattern = substitute(rest, '.\{-}\s*\ze/', '', '')[J

line 6: [J

line 7:     let [ pattern, format ] = s:ParsePattern(pattern)[J

calling function AddTabularPattern[7]..<SNR>41_ParsePattern[J('/\/\*\|\*\/\|\/\//l1')

line 1:   if a:string[0] != '/'[J

line 2:     return ['',''][J

line 3:   endif[J

line 4: [J

line 5:   let pat = '\\\@<!\%(\\\\\)\{-}\zs/' . tabular#ElementFormatPattern() . '*$'[J

calling function AddTabularPattern[7]..<SNR>41_ParsePattern[5]..tabular#ElementFormatPattern[J()

line 1:   return s:formatelempat[J

function AddTabularPattern[7]..<SNR>41_ParsePattern[5]..tabular#ElementFormatPattern returning '\%([lrc]\d\+\)'[J

continuing in function AddTabularPattern[7]..<SNR>41_ParsePattern[J

line 6:   let format = matchstr(a:string[1:-1], pat)[J

line 7:   if !empty(format)[J

line 8:     let format = format[1 : -1][J

line 9:     let pattern = a:string[1 : -len(format) - 2][J

line 10:   else[J

line 11:     let pattern = a:string[1 : -1][J

line 12:   endif[J

line 13: [J

line 14:   return [pattern, format][J

function AddTabularPattern[7]..<SNR>41_ParsePattern returning ['\/\*\|\*\/\|\/\/', 'l1'][J

continuing in function AddTabularPattern[J

line 8: [J

line 9:     if empty(name) || empty(pattern)[J

line 10:       throw "Invalid arguments!"[J

line 11:     endif[J

line 12: [J

line 13:     if !a:force && has_key(commandmap, name)[J

line 14:       throw string(name) . " is already defined, use ! to overwrite."[J

line 15:     endif[J

line 16: [J

line 17:     let command = "tabular#TabularizeStrings(a:lines, " . string(pattern)[J

line 18: [J

line 19:     if !empty(format)[J

line 20:       let command .=  ", " . string(format)[J

line 21:     endif[J

line 22: [J

line 23:     let command .= ")"[J

line 24: [J

line 25:     let commandmap[name] = { 'pattern' : pattern, 'commands' : [ command ] }[J

line 26:   catch[J

line 27:     echohl ErrorMsg[J

line 28:     echomsg "AddTabularPattern: " . v:exception[J

line 29:     echohl None[J

line 30:   endtry[J

function AddTabularPattern returning #0[J

continuing in /home/patrick/.vim/bundle/tabular/after/plugin/TabularMaps.vim[J

line 71: [J

line 72: let &cpo = s:save_cpo[J

line 73: unlet s:save_cpo[J

finished sourcing /home/patrick/.vim/bundle/tabular/after/plugin/TabularMaps.vim[J
Searching for "/home/patrick/.vim/bundle/vim-table-mode/after/plugin/**/*.vim"[J
Searching for "/home/patrick/.vim/bundle/ale/after/plugin/**/*.vim"[J
chdir(/home/patrick/.vim/bundle/ale/after/plugin)[J
fchdir() to previous dir[J
sourcing "/home/patrick/.vim/bundle/ale/after/plugin/ale.vim"[J
line 1: " Author: w0rp <devw0rp@gmail.com>[J

line 2: " Description: Follow-up checks for the plugin: warn about conflicting plugins.[J

line 3: [J

line 4: " A flag for ensuring that this is not run more than one time.[J

line 5: if exists('g:loaded_ale_after')[J

line 6:     finish[J

finished sourcing /home/patrick/.vim/bundle/ale/after/plugin/ale.vim[J
Reading viminfo file "/home/patrick/.viminfo" info oldfiles[J
Press ENTER or type command to continue[?12l[?25h[?1049h[?1h=[1;47r[?12;25h[?12l[?25h[27m[23m[m[38;2;248;248;242m[48;2;0;0;0m[H[2J[?25l[47;1HExecuting BufWinEnter Auto commands for "*"
autocommand if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 1 |   call s:diffoff() | endif
line 0: if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 1 |   call s:diffoff() | endif
calling function <SNR>38_can_diffoff(1)
line 1:   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getbufvar(a:buf, 'git_dir')) && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_
[46;140Hd[47;1Hiff_restore'))
function <SNR>38_can_diffoff returning #0
continuing in BufWinEnter Auto commands for "*"
line 0:    call s:diffoff() | endif
line 0:  endif
Executing BufWinEnter Auto commands for "*"
autocommand call ale#Queue(0, 'lint_file', str2nr(expand('<abuf>')))
line 0: call ale#Queue(0, 'lint_file', str2nr(expand('<abuf>')))
calling function ale#Queue(0, 'lint_file', 1)
line 1:     if a:0 > 2
line 2:[9Cthrow 'too many arguments!'
line 3:     endif
line 4:
line 5:     " Default linting_flag to ''
line 6:     let l:linting_flag = get(a:000, 0, '')
line 7:     let l:buffer = get(a:000, 1, bufnr(''))
line 8:
line 9:     return ale#CallWithCooldown(   'dont_queue_until',   function('s:ALEQueueImpl'),   [a:delay, l:linting_flag, l:buffer],)
calling function ale#Queue[9]..ale#CallWithCooldown('dont_queue_until', function('<SNR>40_ALEQueueImpl'), [0, 'lint_file', 1])
line 1:     let l:now = ale#util#ClockMilliseconds()
Searching for "autoload/ale/util.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/h
[46;140Ho[47;1Hme/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bun
[46;140Hd[47;1Hle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/
[46;140Hb[47;1Hundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vim80/pack/dist/opt/matchit,/usr/share
[46;140H/[47;1Hvim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle
[46;140H.[47;1Hvim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/afte
[46;140Hr[47;1H,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/a
[46;140Hf[47;1Hter,/home/patrick/.vim/bundle/ale/after,/hom
Searching for "/home/patrick/.vim/autoload/ale/util.vim"
Searching for "/home/patrick/.vim/bundle/Vundle.vim/autoload/ale/util.vim"
Searching for "/home/patrick/.vim/bundle/vim-sensible/autoload/ale/util.vim"
Searching for "/home/patrick/.vim/bundle/molokai-dark/autoload/ale/util.vim"
Searching for "/home/patrick/.vim/bundle/nerdtree/autoload/ale/util.vim"
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/autoload/ale/util.vim"
Searching for "/home/patrick/.vim/bundle/nerdcommenter/autoload/ale/util.vim"
Searching for "/home/patrick/.vim/bundle/vim-fugitive/autoload/ale/util.vim"
Searching for "/home/patrick/.vim/bundle/ale/autoload/ale/util.vim"
chdir(/home/patrick/.vim/bundle/ale/autoload/ale)
fchdir() to previous dir
line 1: sourcing "/home/patrick/.vim/bundle/ale/autoload/ale/util.vim"
line 1: " Author: w0rp <devw0rp@gmail.com>
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 2: " Description: Contains miscellaneous functions
line 3:
line 4: " A wrapper function for mode() so we can test calls for it.
line 5: function! ale#util#Mode(...) abort
line 8:
line 9: " A wrapper function for feedkeys so we can test calls for it.
line 10: function! ale#util#FeedKeys(...) abort
line 13:
line 14: if !exists('g:ale#util#nul_file')
line 15:     " A null file for sending output to nothing.
line 16:     let g:ale#util#nul_file = '/dev/null'
line 17:
line 18:     if has('win32')
line 19:[9Clet g:ale#util#nul_file = 'nul'
line 20:     endif
line 21: endif
line 22:
line 23: " Return the number of lines for a given buffer.
line 24: function! ale#util#GetLineCount(buffer) abort
line 27:
line 28: function! ale#util#GetFunction(string_or_ref) abort
line 35:
line 36: " Compare two loclist items for ALE, sorted by their buffers, filenames, and
line 37: " line numbers and column numbers.
line 38: function! ale#util#LocItemCompare(left, right) abort
line 75:
line 76: " Compare two loclist items, including the text for the items.
line 77: "
line 78: " This function can be used for de-duplicating lists.
line 79: function! ale#util#LocItemCompareWithText(left, right) abort
line 96:
line 97: " This function will perform a binary search and a small sequential search
line 98: " on the list to find the last problem in the buffer and line which is
line 99: " on or before the column. The index of the problem will be returned.
line 100: "
line 101: " -1 will be returned if nothing can be found.
line 102: function! ale#util#BinarySearch(loclist, buffer, line, column) abort
line 146:
line 147: " A function for testing if a function is running inside a sandbox.
line 148: " See :help sandbox
line 149: function! ale#util#InSandbox() abort
line 160:
line 161: " Get the number of milliseconds since some vague, but consistent, point in
line 162: " the past.
line 163: "
line 164: " This function can be used for timing execution, etc.
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 165: "
line 166: " The time will be returned as a Number.
line 167: function! ale#util#ClockMilliseconds() abort
line 170:
line 171: " Given a single line, or a List of lines, and a single pattern, or a List
line 172: " of patterns, return all of the matches for the lines(s) from the given
line 173: " patterns, using matchlist().
line 174: "
line 175: " Only the first pattern which matches a line will be returned.
line 176: function! ale#util#GetMatches(lines, patterns) abort
line 194:
line 195: function! s:LoadArgCount(function) abort
line 211:
line 212: " Given the name of a function, a Funcref, or a lambda, return the number
line 213: " of named arguments for a function.
line 214: function! ale#util#FunctionArgCount(function) abort
line 232:
line 233: " Escape a string so the characters in it will be safe for use inside of PCRE
line 234: " or RE2 regular expressions without characters having special meanings.
line 235: function! ale#util#EscapePCRE(unsafe_string) abort
line 238:
line 239: " Given a String or a List of String values, try and decode the string(s)
line 240: " as a JSON value which can be decoded with json_decode. If the JSON string
line 241: " is invalid, the default argument value will be returned instead.
line 242: "
line 243: " This function is useful in code where the data can't be trusted to be valid
line 244: " JSON, and where throwing exceptions is mostly just irritating.
line 245: function! ale#util#FuzzyJSONDecode(data, default) abort
line 258:
line 259: " Write a file, including carriage return characters for DOS files.
line 260: "
line 261: " The buffer number is required for determining the fileformat setting for
line 262: " the buffer.
line 263: function! ale#util#Writefile(buffer, lines, filename) abort
line 270:
line 271: if !exists('s:patial_timers')
line 272:     let s:partial_timers = {}
line 273: endif
line 274:
line 275: function! s:ApplyPartialTimer(timer_id) abort
line 279:
line 280: " Given a delay, a callback, a List of arguments, start a timer with
line 281: " timer_start() and call the callback provided with [timer_id] + args.
line 282: "
line 283: " The timer must not be stopped with timer_stop().
line 284: " Use ale#util#StopPartialTimer() instead, which can stop any timer, and will
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 285: " clear any arguments saved for executing callbacks later.
line 286: function! ale#util#StartPartialTimer(delay, callback, args) abort
line 292:
line 293: function! ale#util#StopPartialTimer(timer_id) abort
finished sourcing /home/patrick/.vim/bundle/ale/autoload/ale/util.vim
continuing in function ale#Queue[9]..ale#CallWithCooldown
calling function ale#Queue[9]..ale#CallWithCooldown[1]..ale#util#ClockMilliseconds()
line 1:     return float2nr(reltimefloat(reltime()) * 1000)
function ale#Queue[9]..ale#CallWithCooldown[1]..ale#util#ClockMilliseconds returning #1505404179241
continuing in function ale#Queue[9]..ale#CallWithCooldown
line 2:
line 3:     if l:now < get(s:timestamp_map, a:timestamp_key, -1)
line 4:[9Creturn 0
line 5:     endif
line 6:
line 7:     let s:timestamp_map[a:timestamp_key] = l:now + s:error_delay_ms
line 8:
line 9:     let l:return_value = call(a:func, a:arglist)
calling function ale#Queue[9]..ale#CallWithCooldown[9]..<SNR>40_ALEQueueImpl(0, 'lint_file', 1)
line 1:     if a:linting_flag isnot# '' && a:linting_flag isnot# 'lint_file'
line 2:[9Cthrow "linting_flag must be either '' or 'lint_file'"
line 3:     endif
line 4:
line 5:     if type(a:buffer) != type(0)
line 6:[9Cthrow 'buffer_number must be a Number'
line 7:     endif
line 8:
line 9:     if ale#ShouldDoNothing(a:buffer)
calling function ale#Queue[9]..ale#CallWithCooldown[9]..<SNR>40_ALEQueueImpl[9]..ale#ShouldDoNothing(1)
line 1:     " Do nothing for blacklisted files
line 2:     " OR if ALE is running in the sandbox
line 3:     return index(g:ale_filetype_blacklist, &filetype) >= 0   || (exists('*getcmdwintype') && !empty(getcmdwintype()))   || ale#util
[46;140H#[47;1HInSandbox()   || !ale#Var(a:buffer, 'enabled')   || ale#FileTooLarge()   || getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
calling function ale#Queue[9]..ale#CallWithCooldown[9]..<SNR>40_ALEQueueImpl[9]..ale#ShouldDoNothing[3]..ale#util#InSandbox()
line 1:     try
line 2:[9Cfunction! s:SandboxCheck() abort
line 4:     catch /^Vim\%((\a\+)\)\=:E48/
line 5:[9C" E48 is the sandbox error.
line 6:[9Creturn 1
line 7:     endtry
line 8:
line 9:     return 0
function ale#Queue[9]..ale#CallWithCooldown[9]..<SNR>40_ALEQueueImpl[9]..ale#ShouldDoNothing[3]..ale#util#InSandbox returning #0
continuing in function ale#Queue[9]..ale#CallWithCooldown[9]..<SNR>40_ALEQueueImpl[9]..ale#ShouldDoNothing
calling function ale#Queue[9]..ale#CallWithCooldown[9]..<SNR>40_ALEQueueImpl[9]..ale#ShouldDoNothing[3]..ale#Var(1, 'enabled')
line 1:     let l:nr = str2nr(a:buffer)
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 2:     let l:full_name = 'ale_' . a:variable_name
line 3:
line 4:     if bufexists(l:nr)
line 5:[9Clet l:vars = getbufvar(l:nr, '')
line 6:     elseif has_key(g:, 'ale_fix_buffer_data')
line 7:[9Clet l:vars = get(g:ale_fix_buffer_data, l:nr, {'vars': {}}).vars
line 8:     else
line 9:[9Clet l:vars = {}
line 10:     endif
line 11:
line 12:     return get(l:vars, l:full_name, g:[l:full_name])
function ale#Queue[9]..ale#CallWithCooldown[9]..<SNR>40_ALEQueueImpl[9]..ale#ShouldDoNothing[3]..ale#Var returning #1
continuing in function ale#Queue[9]..ale#CallWithCooldown[9]..<SNR>40_ALEQueueImpl[9]..ale#ShouldDoNothing
calling function ale#Queue[9]..ale#CallWithCooldown[9]..<SNR>40_ALEQueueImpl[9]..ale#ShouldDoNothing[3]..ale#FileTooLarge()
line 1:     let l:max = ale#Var(bufnr(''), 'maximum_file_size')
calling function ale#Queue[9]..ale#CallWithCooldown[9]..<SNR>40_ALEQueueImpl[9]..ale#ShouldDoNothing[3]..ale#FileTooLarge[1]..ale#Var(1, 'm
[46;140Ha[47;1Hximum_file_size')
line 1:     let l:nr = str2nr(a:buffer)
line 2:     let l:full_name = 'ale_' . a:variable_name
line 3:
line 4:     if bufexists(l:nr)
line 5:[9Clet l:vars = getbufvar(l:nr, '')
line 6:     elseif has_key(g:, 'ale_fix_buffer_data')
line 7:[9Clet l:vars = get(g:ale_fix_buffer_data, l:nr, {'vars': {}}).vars
line 8:     else
line 9:[9Clet l:vars = {}
line 10:     endif
line 11:
line 12:     return get(l:vars, l:full_name, g:[l:full_name])
function ale#Queue[9]..ale#CallWithCooldown[9]..<SNR>40_ALEQueueImpl[9]..ale#ShouldDoNothing[3]..ale#FileTooLarge[1]..ale#Var returning #0
continuing in function ale#Queue[9]..ale#CallWithCooldown[9]..<SNR>40_ALEQueueImpl[9]..ale#ShouldDoNothing[3]..ale#FileTooLarge
line 2:
line 3:     return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0
function ale#Queue[9]..ale#CallWithCooldown[9]..<SNR>40_ALEQueueImpl[9]..ale#ShouldDoNothing[3]..ale#FileTooLarge returning #0
continuing in function ale#Queue[9]..ale#CallWithCooldown[9]..<SNR>40_ALEQueueImpl[9]..ale#ShouldDoNothing
function ale#Queue[9]..ale#CallWithCooldown[9]..<SNR>40_ALEQueueImpl[9]..ale#ShouldDoNothing returning #0
continuing in function ale#Queue[9]..ale#CallWithCooldown[9]..<SNR>40_ALEQueueImpl
line 10:[9Creturn
line 11:     endif
line 12:
line 13:     " Remember that we want to check files for this buffer.
line 14:     " We will remember this until we finally run the linters, via any event.
line 15:     if a:linting_flag is# 'lint_file'
line 16:[9Clet s:should_lint_file_for_buffer[bufnr('%')] = 1
line 17:     endif
line 18:
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 19:     if s:lint_timer != -1
line 20:[9Ccall timer_stop(s:lint_timer)
line 21:[9Clet s:lint_timer = -1
line 22:     endif
line 23:
line 24:     let l:linters = ale#linter#Get(getbufvar(a:buffer, '&filetype'))
Searching for "autoload/ale/linter.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,
[46;140H/[47;1Hhome/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/b
[46;140Hu[47;1Hndle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vi
[46;140Hm[47;1H/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vim80/pack/dist/opt/matchit,/usr/sha
[46;140Hr[47;1He/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vund
[46;140Hl[47;1He.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/af
[46;140Ht[47;1Her,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive
[46;140H/[47;1Hafter,/home/patrick/.vim/bundle/ale/after,/h
Searching for "/home/patrick/.vim/autoload/ale/linter.vim"
Searching for "/home/patrick/.vim/bundle/Vundle.vim/autoload/ale/linter.vim"
Searching for "/home/patrick/.vim/bundle/vim-sensible/autoload/ale/linter.vim"
Searching for "/home/patrick/.vim/bundle/molokai-dark/autoload/ale/linter.vim"
Searching for "/home/patrick/.vim/bundle/nerdtree/autoload/ale/linter.vim"
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/autoload/ale/linter.vim"
Searching for "/home/patrick/.vim/bundle/nerdcommenter/autoload/ale/linter.vim"
Searching for "/home/patrick/.vim/bundle/vim-fugitive/autoload/ale/linter.vim"
Searching for "/home/patrick/.vim/bundle/ale/autoload/ale/linter.vim"
chdir(/home/patrick/.vim/bundle/ale/autoload/ale)
fchdir() to previous dir
line 24: sourcing "/home/patrick/.vim/bundle/ale/autoload/ale/linter.vim"
line 1: " Author: w0rp <devw0rp@gmail.com>
line 2: " Description: Linter registration and lazy-loading
line 3: "   Retrieves linters as requested by the engine, loading them if needed.
line 4:
line 5: let s:linters = {}
line 6:
line 7: " Default filetype aliases.
line 8: " The user defined aliases will be merged with this Dictionary.
line 15: let s:default_ale_linter_aliases = {   'Dockerfile': 'dockerfile',   'csh': 'sh',   'plaintex': 'tex',   'systemverilog': 'verilog
[46;140H'[47;1H,   'zsh': 'sh',}
line 16:
line 17: " Default linters to run for particular filetypes.
line 18: " The user defined linter selections will be merged with this Dictionary.
line 19: "
line 20: " No linters are used for plaintext files by default.
line 21: "
line 22: " Only cargo is enabled for Rust by default.
line 23: " rpmlint is disabled by default because it can result in code execution.
line 33: let s:default_ale_linters = {   'csh': ['shell'],   'go': ['gofmt', 'golint', 'go vet'],   'help': [],   'python': ['flake8', 'myp
[46;140Hy[47;1H', 'pylint'],   'rust': ['cargo'],   'spec': [],   'text': [],   'zsh': ['shell'],}
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 34:
line 35: " Testing/debugging helper to unload all linters.
line 36: function! ale#linter#Reset() abort
line 39:
line 40: function! s:IsCallback(value) abort
line 43:
line 44: function! s:IsBoolean(value) abort
line 47:
line 48: function! ale#linter#PreProcess(linter) abort
line 230:
line 231: function! ale#linter#Define(filetype, linter) abort
line 240:
line 241: function! ale#linter#GetAll(filetypes) abort
line 262:
line 263: function! s:GetAliasedFiletype(original_filetype) abort
line 280:
line 281: function! ale#linter#ResolveFiletype(original_filetype) abort
line 290:
line 291: function! s:GetLinterNames(original_filetype) abort
line 304:
line 305: function! ale#linter#Get(original_filetypes) abort
line 350:
line 351: " Given a buffer and linter, get the executable String for the linter.
line 352: function! ale#linter#GetExecutable(buffer, linter) abort
line 357:
line 358: " Given a buffer and linter, get the command String for the linter.
line 359: " The command_chain key is not supported.
line 360: function! ale#linter#GetCommand(buffer, linter) abort
line 365:
line 366: " Given a buffer and linter, get the address for connecting to the server.
line 367: function! ale#linter#GetAddress(buffer, linter) abort
line 372:
line 373: " Given a buffer, an LSP linter, and a callback to register for handling
line 374: " messages, start up an LSP linter and get ready to receive errors or
line 375: " completions.
line 376: function! ale#linter#StartLSP(buffer, linter, callback) abort
finished sourcing /home/patrick/.vim/bundle/ale/autoload/ale/linter.vim
continuing in function ale#Queue[9]..ale#CallWithCooldown[9]..<SNR>40_ALEQueueImpl
calling function ale#Queue[9]..ale#CallWithCooldown[9]..<SNR>40_ALEQueueImpl[24]..ale#linter#Get('')
line 1:     let l:possibly_duplicated_linters = []
line 2:
line 3:     " Handle dot-seperated filetypes.
line 4:     for l:original_filetype in split(a:original_filetypes, '\.')
line 5:[9Clet l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
line 6:[9Clet l:linter_names = s:GetLinterNames(l:original_filetype)
line 7:[9Clet l:all_linters = ale#linter#GetAll(l:filetype)
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 8:[9Clet l:filetype_linters = []
line 9:
line 10:[9Cif type(l:linter_names) == type('') && l:linter_names is# 'all'
line 11:[13Clet l:filetype_linters = l:all_linters
line 12:[9Celseif type(l:linter_names) == type([])
line 13:[13C" Select only the linters we or the user has specified.
line 14:[13Cfor l:linter in l:all_linters
line 15:[17Clet l:name_list = [l:linter.name] + l:linter.aliases
line 16:
line 17:[17Cfor l:name in l:name_list
line 18:[21Cif index(l:linter_names, l:name) >= 0
line 19:[25Ccall add(l:filetype_linters, l:linter)
line 20:[25Cbreak
line 21:[21Cendif
line 22:[17Cendfor
line 23:[13Cendfor
line 24:[9Cendif
line 25:
line 26:[9Ccall extend(l:possibly_duplicated_linters, l:filetype_linters)
line 27:     endfor
line 28:
line 29:     let l:name_list = []
line 30:     let l:combined_linters = []
line 31:
line 32:     " Make sure we override linters so we don't get two with the same name,
line 33:     " like 'eslint' for both 'javascript' and 'typescript'
line 34:     "
line 35:     " Note that the reverse calls here modify the List variables.
line 36:     for l:linter in reverse(l:possibly_duplicated_linters)
line 37:[9Cif index(l:name_list, l:linter.name) < 0
line 38:[13Ccall add(l:name_list, l:linter.name)
line 39:[13Ccall add(l:combined_linters, l:linter)
line 40:[9Cendif
line 41:     endfor
line 42:
line 43:     return reverse(l:combined_linters)
function ale#Queue[9]..ale#CallWithCooldown[9]..<SNR>40_ALEQueueImpl[24]..ale#linter#Get returning []
continuing in function ale#Queue[9]..ale#CallWithCooldown[9]..<SNR>40_ALEQueueImpl
line 25:
line 26:     " Don't set up buffer data and so on if there are no linters to run.
line 27:     if empty(l:linters)
line 28:[9C" If we have some previous buffer data, then stop any jobs currently
line 29:[9C" running and clear everything.
line 30:[9Cif has_key(g:ale_buffer_info, a:buffer)
line 31:[13Ccall ale#engine#RunLinters(a:buffer, [], 1)
line 32:[9Cendif
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 33:
line 34:[9Creturn
function ale#Queue[9]..ale#CallWithCooldown[9]..<SNR>40_ALEQueueImpl returning #0
continuing in function ale#Queue[9]..ale#CallWithCooldown
line 10:
line 11:     let s:timestamp_map[a:timestamp_key] = -1
line 12:
line 13:     return l:return_value
function ale#Queue[9]..ale#CallWithCooldown returning #0
continuing in function ale#Queue
function ale#Queue returning #0
continuing in BufWinEnter Auto commands for "*"
Executing BufEnter Auto commands for "*"
autocommand set relativenumber
line 0: set relativenumber
Executing BufEnter Auto commands for "*"
autocommand call nerdtree#checkForBrowse(expand("<amatch>"))
line 0: call nerdtree#checkForBrowse(expand("<amatch>"))
calling function nerdtree#checkForBrowse('')
line 1:     if !isdirectory(a:dir)
line 2:[9Creturn
function nerdtree#checkForBrowse returning #0
continuing in BufEnter Auto commands for "*"
Executing BufEnter Auto commands for "*"
autocommand :call s:SetUpForNewFiletype(&filetype, 0)
line 0: :call s:SetUpForNewFiletype(&filetype, 0)
calling function <SNR>37_SetUpForNewFiletype('', 0)
line 1:     let ft = a:filetype
line 2:
line 3:     "for compound filetypes, if we don't know how to handle the full filetype
line 4:     "then break it down and use the first part that we know how to handle
line 5:     if ft =~ '\.' && !has_key(s:delimiterMap, ft)
line 6:[9Clet filetypes = split(a:filetype, '\.')
line 7:[9Cfor i in filetypes
line 8:[13Cif has_key(s:delimiterMap, i)
line 9:[17Clet ft = i
line 10:[17Cbreak
line 11:[13Cendif
line 12:[9Cendfor
line 13:     endif
line 14:
line 15:     let b:NERDSexyComMarker = ''
line 16:
line 17:     if has_key(s:delimiterMap, ft)
line 18:[9Clet b:NERDCommenterDelims = s:delimiterMap[ft]
line 19:[9Cfor i in ['left', 'leftAlt', 'right', 'rightAlt']
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 20:[13Cif !has_key(b:NERDCommenterDelims, i)
line 21:[17Clet b:NERDCommenterDelims[i] = ''
line 22:[13Cendif
line 23:[9Cendfor
line 24:[9Cfor i in ['nested', 'nestedAlt']
line 25:[13Cif !has_key(b:NERDCommenterDelims, i)
line 26:[17Clet b:NERDCommenterDelims[i] = 0
line 27:[13Cendif
line 28:[9Cendfor
line 29:[9C" if g:NERD_<filetype>_alt_style is defined, use the alternate style
line 30:[9Clet b:NERDCommenterFirstInit = getbufvar(1,"NERDCommenterFirstInit")
line 31:[9Cif exists('g:NERDAltDelims_'.ft) && eval('g:NERDAltDelims_'.ft) && !b:NERDCommenterFirstInit
line 32:[13Ccall s:SwitchToAlternativeDelimiters(0)
line 33:[13Clet b:NERDCommenterFirstInit = 1
line 34:[9Cendif
line 35:     else
line 36:[9Clet b:NERDCommenterDelims = s:CreateDelimMapFromCms()
calling function <SNR>37_SetUpForNewFiletype[36]..<SNR>37_CreateDelimMapFromCms()
line 1:     if &ft == '' && exists('g:NERDDefaultDelims')
line 2:[9Clet delims = g:NERDDefaultDelims
line 3:[9Cfor i in ['left', 'leftAlt', 'right', 'rightAlt']
line 4:[13Cif !has_key(delims, i)
line 5:[17Clet delims[i] = ''
line 6:[13Cendif
line 7:[9Cendfor
line 8:[9Creturn delims
line 9:     endif
line 10:     return { 'left': substitute(&commentstring, '\([^ \t]*\)\s*%s.*', '\1', ''), 'right': substitute(&commentstring, '.*%s\s*\(.*\
[46;140H)[47;1H', '\1', 'g'), 'nested': 0, 'leftAlt': '', 'rightAlt': '', 'nestedAlt': 0}
function <SNR>37_SetUpForNewFiletype[36]..<SNR>37_CreateDelimMapFromCms returning {'nestedAlt': 0, 'right': '*/', 'neste...Alt': '', 'left'
[46;140H:[47;2H'/*', 'rightAlt': ''}
continuing in function <SNR>37_SetUpForNewFiletype
line 37:     endif
line 38:
function <SNR>37_SetUpForNewFiletype returning #0
continuing in BufEnter Auto commands for "*"
Executing BufEnter Auto commands for "*"
autocommand call ale#events#EnterEvent(str2nr(expand('<abuf>')))
line 0: call ale#events#EnterEvent(str2nr(expand('<abuf>')))
Searching for "autoload/ale/events.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,
[46;140H/[47;1Hhome/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/b
[46;140Hu[47;1Hndle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vi
[46;140Hm[47;1H/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vim80/pack/dist/opt/matchit,/usr/sha
[46;140Hr[47;1He/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vund
[46;140Hl[47;1He.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/af
[46;140Ht[47;1Her,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive
[46;140H/[47;1H[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[47;1Hafter,/home/patrick/.vim/bundle/ale/after,/h
[?25lSearching for "/home/patrick/.vim/autoload/ale/events.vim"
Searching for "/home/patrick/.vim/bundle/Vundle.vim/autoload/ale/events.vim"
Searching for "/home/patrick/.vim/bundle/vim-sensible/autoload/ale/events.vim"
Searching for "/home/patrick/.vim/bundle/molokai-dark/autoload/ale/events.vim"
Searching for "/home/patrick/.vim/bundle/nerdtree/autoload/ale/events.vim"
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/autoload/ale/events.vim"
Searching for "/home/patrick/.vim/bundle/nerdcommenter/autoload/ale/events.vim"
Searching for "/home/patrick/.vim/bundle/vim-fugitive/autoload/ale/events.vim"
Searching for "/home/patrick/.vim/bundle/ale/autoload/ale/events.vim"
chdir(/home/patrick/.vim/bundle/ale/autoload/ale)
fchdir() to previous dir
line 0: sourcing "/home/patrick/.vim/bundle/ale/autoload/ale/events.vim"
line 1: " Author: w0rp <devw0rp@gmail.com>
line 2:
line 3: function! ale#events#SaveEvent(buffer) abort
line 16:
line 17: function! s:LintOnEnter(buffer) abort
line 25:
line 26: function! ale#events#EnterEvent(buffer) abort
line 32:
line 33: function! ale#events#FileTypeEvent(buffer, new_filetype) abort
line 46:
line 47: function! ale#events#FileChangedEvent(buffer) abort
finished sourcing /home/patrick/.vim/bundle/ale/autoload/ale/events.vim
continuing in BufEnter Auto commands for "*"
calling function ale#events#EnterEvent(1)
line 1:     let l:filetype = getbufvar(a:buffer, '&filetype')
line 2:     call setbufvar(a:buffer, 'ale_original_filetype', l:filetype)
line 3:
line 4:     call s:LintOnEnter(a:buffer)
calling function ale#events#EnterEvent[4]..<SNR>60_LintOnEnter(1)
line 1:     if ale#Var(a:buffer, 'enabled')&& g:ale_lint_on_enter&& has_key(b:, 'ale_file_changed')
calling function ale#events#EnterEvent[4]..<SNR>60_LintOnEnter[1]..ale#Var(1, 'enabled')
line 1:     let l:nr = str2nr(a:buffer)
line 2:     let l:full_name = 'ale_' . a:variable_name
line 3:
line 4:     if bufexists(l:nr)
line 5:[9Clet l:vars = getbufvar(l:nr, '')
line 6:     elseif has_key(g:, 'ale_fix_buffer_data')
line 7:[9Clet l:vars = get(g:ale_fix_buffer_data, l:nr, {'vars': {}}).vars
line 8:     else
line 9:[9Clet l:vars = {}
line 10:     endif
line 11:
line 12:     return get(l:vars, l:full_name, g:[l:full_name])
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hfunction ale#events#EnterEvent[4]..<SNR>60_LintOnEnter[1]..ale#Var returning #1
continuing in function ale#events#EnterEvent[4]..<SNR>60_LintOnEnter
line 4:[9Ccall remove(b:, 'ale_file_changed')
line 5:[9Ccall ale#Queue(0, 'lint_file', a:buffer)
line 6:     endif
function ale#events#EnterEvent[4]..<SNR>60_LintOnEnter returning #0
continuing in function ale#events#EnterEvent
function ale#events#EnterEvent returning #0
continuing in BufEnter Auto commands for "*"
Executing BufEnter Auto commands for "*"
autocommand sil call s:LocalBrowse(expand("<amatch>"))
line 0: sil call s:LocalBrowse(expand("<amatch>"))
Executing VimEnter Auto commands for "*"
[38;2;102;217;239mPress ENTER or type command to continue[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m
[?25lautocommand NERDTree
[38;2;102;217;239mPress ENTER or type command to continue[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m
[?25lline 0: NERDTree
line 0: :call g:NERDTreeCreator.CreateTabTree('')
calling function 184('')
line 1:     let creator = s:Creator.New()
calling function 184[1]..193()
line 1:     let newCreator = copy(self)
line 2:     return newCreator
function 184[1]..193 returning {'_createNERDTree': function('188'), '...95'), '_bindMappings': function('181')}
continuing in function 184
line 2:     call creator.createTabTree(a:name)
calling function 184[2]..185('')
line 1:     let path = self._pathForString(a:name)
calling function 184[2]..185[1]..196('')
line 1:     let path = {}
line 2:     if g:NERDTreeBookmark.BookmarkExistsFor(a:str)
calling function 184[2]..185[1]..196[2]..82('')
line 1:     try
line 2:[9Ccall s:Bookmark.BookmarkFor(a:name)
calling function 184[2]..185[1]..196[2]..82[2]..83('')
line 1:     let l:result = {}
line 2:     for l:bookmark in s:Bookmark.Bookmarks()
calling function 184[2]..185[1]..196[2]..82[2]..83[2]..81()
line 1:     if !exists("g:NERDTreeBookmarks")
line 2:[9Clet g:NERDTreeBookmarks = []
line 3:     endif
line 4:     return g:NERDTreeBookmarks
function 184[2]..185[1]..196[2]..82[2]..83[2]..81 returning []
continuing in function 184[2]..185[1]..196[2]..82[2]..83
line 3:[9Cif l:bookmark.name ==# a:name
line 4:[13Clet l:result = l:bookmark
line 5:[13Cbreak
line 6:[9Cendif
line 7:     endfor
line 8:     if empty(l:result)
line 9:[9Cthrow 'NERDTree.BookmarkNotFoundError: "' . a:name  . '" not found'
Exception thrown: NERDTree.BookmarkNotFoundError: "" not found
function 184[2]..185[1]..196[2]..82[2]..83 aborted
continuing in function 184[2]..185[1]..196[2]..82
line 3:[9Creturn 1
line 4:     catch /^NERDTree.BookmarkNotFoundError/
Exception caught: NERDTree.BookmarkNotFoundError: "" not found
line 5:[9Creturn 0
Exception finished: NERDTree.BookmarkNotFoundError: "" not found
:return 0 made pending
line 6:     endtry
:return 0 resumed
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hfunction 184[2]..185[1]..196[2]..82 returning #0
continuing in function 184[2]..185[1]..196
line 3:[9Clet path = g:NERDTreeBookmark.BookmarkFor(a:str).path
line 4:     else
line 5:[9Clet dir = a:str ==# '' ? getcwd() : a:str
line 6:
line 7:[9C"hack to get an absolute path if a relative path is given
line 8:[9Cif dir =~# '^\.'
line 9:[13Clet dir = getcwd() . g:NERDTreePath.Slash() . dir
line 10:[9Cendif
line 11:[9Clet dir = g:NERDTreePath.Resolve(dir)
calling function 184[2]..185[1]..196[11]..35('/home/patrick/docu/sphinx')
line 1:     let tmp = resolve(a:path)
line 2:     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp
function 184[2]..185[1]..196[11]..35 returning '/home/patrick/docu/sphinx'
continuing in function 184[2]..185[1]..196
line 12:
line 13:[9Ctry
line 14:[13Clet path = g:NERDTreePath.New(dir)
calling function 184[2]..185[1]..196[14]..33('/home/patrick/docu/sphinx')
line 1:     let newPath = copy(self)
line 2:
line 3:     call newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:path))
calling function 184[2]..185[1]..196[14]..33[3]..3('/home/patrick/docu/sphinx')
line 1:     let prependCWD = 0
line 2:     if nerdtree#runningWindows()
calling function 184[2]..185[1]..196[14]..33[3]..3[2]..nerdtree#runningWindows()
line 1:     return has("win16") || has("win32") || has("win64")
function 184[2]..185[1]..196[14]..33[3]..3[2]..nerdtree#runningWindows returning #0
continuing in function 184[2]..185[1]..196[14]..33[3]..3
line 3:[9Clet prependCWD = a:str !~# '^.:\(\\\|\/\)' && a:str !~# '^\(\\\\\|\/\/\)'
line 4:     else
line 5:[9Clet prependCWD = a:str !~# '^/'
line 6:     endif
line 7:
line 8:     let toReturn = a:str
line 9:     if prependCWD
line 10:[9Clet toReturn = getcwd() . s:Path.Slash() . a:str
line 11:     endif
line 12:
line 13:     return toReturn
function 184[2]..185[1]..196[14]..33[3]..3 returning '/home/patrick/docu/sphinx'
continuing in function 184[2]..185[1]..196[14]..33
calling function 184[2]..185[1]..196[14]..33[3]..36('/home/patrick/docu/sphinx')
line 1:     call self.extractDriveLetter(a:fullpath)
calling function 184[2]..185[1]..196[14]..33[3]..36[1]..16('/home/patrick/docu/sphinx')
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 1:     if nerdtree#runningWindows()
calling function 184[2]..185[1]..196[14]..33[3]..36[1]..16[1]..nerdtree#runningWindows()
line 1:     return has("win16") || has("win32") || has("win64")
function 184[2]..185[1]..196[14]..33[3]..36[1]..16[1]..nerdtree#runningWindows returning #0
continuing in function 184[2]..185[1]..196[14]..33[3]..36[1]..16
line 2:[9Cif a:fullpath =~ '^\(\\\\\|\/\/\)'
line 3:[13C"For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
line 4:[13Clet self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
line 5:[13Clet self.drive = substitute(self.drive, '/', '\', "g")
line 6:[9Celse
line 7:[13Clet self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
line 8:[9Cendif
line 9:     else
line 10:[9Clet self.drive = ''
line 11:     endif
line 12:
function 184[2]..185[1]..196[14]..33[3]..36[1]..16 returning #0
continuing in function 184[2]..185[1]..196[14]..33[3]..36
line 2:
line 3:     let fullpath = s:Path.WinToUnixPath(a:fullpath)
calling function 184[2]..185[1]..196[14]..33[3]..36[3]..48('/home/patrick/docu/sphinx')
line 1:     if !nerdtree#runningWindows()
calling function 184[2]..185[1]..196[14]..33[3]..36[3]..48[1]..nerdtree#runningWindows()
line 1:     return has("win16") || has("win32") || has("win64")
function 184[2]..185[1]..196[14]..33[3]..36[3]..48[1]..nerdtree#runningWindows returning #0
continuing in function 184[2]..185[1]..196[14]..33[3]..36[3]..48
line 2:[9Creturn a:pathstr
function 184[2]..185[1]..196[14]..33[3]..36[3]..48 returning '/home/patrick/docu/sphinx'
continuing in function 184[2]..185[1]..196[14]..33[3]..36
line 4:
line 5:     if getftype(fullpath) ==# "fifo"
line 6:[9Cthrow "NERDTree.InvalidFiletypeError: Cant handle FIFO files: " . a:fullpath
line 7:     endif
line 8:
line 9:     let self.pathSegments = filter(split(fullpath, '/'), '!empty(v:val)')
line 10:
line 11:     let self.isReadOnly = 0
line 12:     if isdirectory(a:fullpath)
line 13:[9Clet self.isDirectory = 1
line 14:     elseif filereadable(a:fullpath)
line 15:[9Clet self.isDirectory = 0
line 16:[9Clet self.isReadOnly = filewritable(a:fullpath) ==# 0
line 17:     else
line 18:[9Cthrow "NERDTree.InvalidArgumentsError: Invalid path = " . a:fullpath
line 19:     endif
line 20:
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 21:     let self.isExecutable = 0
line 22:     if !self.isDirectory
line 23:[9Clet self.isExecutable = getfperm(a:fullpath) =~# 'x'
line 24:     endif
line 25:
line 26:     "grab the last part of the path (minus the trailing slash)
line 27:     let lastPathComponent = self.getLastPathComponent(0)
calling function 184[2]..185[1]..196[14]..33[3]..36[27]..21(0)
line 1:     if empty(self.pathSegments)
line 2:[9Creturn ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:[9Clet toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function 184[2]..185[1]..196[14]..33[3]..36[27]..21 returning 'sphinx'
continuing in function 184[2]..185[1]..196[14]..33[3]..36
line 28:
line 29:     "get the path to the new node with the parent dir fully resolved
line 30:     let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
calling function 184[2]..185[1]..196[14]..33[3]..36[30]..46()
line 1:     return self.drive . '/' . join(self.pathSegments[0:-2], '/')
function 184[2]..185[1]..196[14]..33[3]..36[30]..46 returning '/home/patrick/docu'
continuing in function 184[2]..185[1]..196[14]..33[3]..36
calling function 184[2]..185[1]..196[14]..33[3]..36[30]..35('/home/patrick/docu')
line 1:     let tmp = resolve(a:path)
line 2:     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp
function 184[2]..185[1]..196[14]..33[3]..36[30]..35 returning '/home/patrick/docu'
continuing in function 184[2]..185[1]..196[14]..33[3]..36
line 31:
line 32:     "if  the last part of the path is a symlink then flag it as such
line 33:     let self.isSymLink = (s:Path.Resolve(hardPath) != hardPath)
calling function 184[2]..185[1]..196[14]..33[3]..36[33]..35('/home/patrick/docu/sphinx')
line 1:     let tmp = resolve(a:path)
line 2:     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp
function 184[2]..185[1]..196[14]..33[3]..36[33]..35 returning '/home/patrick/docu/sphinx'
continuing in function 184[2]..185[1]..196[14]..33[3]..36
line 34:     if self.isSymLink
line 35:[9Clet self.symLinkDest = s:Path.Resolve(fullpath)
line 36:
line 37:[9C"if the link is a dir then slap a / on the end of its dest
line 38:[9Cif isdirectory(self.symLinkDest)
line 39:
line 40:[13C"we always wanna treat MS windows shortcuts as files for
line 41:[13C"simplicity
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 42:[13Cif hardPath !~# '\.lnk$'
line 43:
line 44:[17Clet self.symLinkDest = self.symLinkDest . '/'
line 45:[13Cendif
line 46:[9Cendif
line 47:     endif
function 184[2]..185[1]..196[14]..33[3]..36 returning #0
continuing in function 184[2]..185[1]..196[14]..33
line 4:
line 5:     let newPath.cachedDisplayString = ""
line 6:     let newPath.flagSet = g:NERDTreeFlagSet.New()
calling function 184[2]..185[1]..196[14]..33[6]..207()
line 1:     let newObj = copy(self)
line 2:     let newObj._flags = {}
line 3:     return newObj
function 184[2]..185[1]..196[14]..33[6]..207 returning {'clearFlags': function('205'), '_flag..., '_flags': {}, 'New': function('207')}
continuing in function 184[2]..185[1]..196[14]..33
line 7:
line 8:     return newPath
function 184[2]..185[1]..196[14]..33 returning {'copyingWillOverwrite': function('11'...('48'), 'refreshFlags': function('38')}
continuing in function 184[2]..185[1]..196
line 15:[9Ccatch /^NERDTree.InvalidArgumentsError/
line 16:[13Ccall nerdtree#echo("No bookmark or directory found for: " . a:str)
line 17:[13Creturn {}
line 18:[9Cendtry
line 19:     endif
line 20:     if !path.isDirectory
line 21:[9Clet path = path.getParent()
line 22:     endif
line 23:
line 24:     return path
function 184[2]..185[1]..196 returning {'copyingWillOverwrite': function('11'...('48'), 'refreshFlags': function('38')}
continuing in function 184[2]..185
line 2:
line 3:     "abort if exception was thrown (bookmark/dir doesn't exist)
line 4:     if empty(path)
line 5:[9Creturn
line 6:     endif
line 7:
line 8:     if path == {}
line 9:[9Creturn
line 10:     endif
line 11:
line 12:     "if instructed to, then change the vim CWD to the dir the NERDTree is
line 13:     "inited in
line 14:     if g:NERDTreeChDirMode != 0
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 15:[9Ccall path.changeToDir()
line 16:     endif
line 17:
line 18:     if g:NERDTree.ExistsForTab()
calling function 184[2]..185[18]..217()
line 1:     if !exists("t:NERDTreeBufName")
line 2:[9Creturn
function 184[2]..185[18]..217 returning #0
continuing in function 184[2]..185
line 19:[9Cif g:NERDTree.IsOpen()
line 20:[13Ccall g:NERDTree.Close()
line 21:[9Cendif
line 22:
line 23:[9Ccall self._removeTreeBufForTab()
line 24:     endif
line 25:
line 26:     call self._createTreeWin()
calling function 184[2]..185[26]..191()
line 1:     "create the nerd tree window
line 2:     let splitLocation = g:NERDTreeWinPos ==# "left" ? "topleft " : "botright "
line 3:     let splitSize = g:NERDTreeWinSize
line 4:
line 5:     if !exists('t:NERDTreeBufName')
line 6:[9Clet t:NERDTreeBufName = self._nextBufferName()
calling function 184[2]..185[26]..191[6]..194()
line 1:     let name = s:Creator.BufNamePrefix() . self._nextBufferNumber()
calling function 184[2]..185[26]..191[6]..194[1]..183()
line 1:     return 'NERD_tree_'
function 184[2]..185[26]..191[6]..194[1]..183 returning 'NERD_tree_'
continuing in function 184[2]..185[26]..191[6]..194
calling function 184[2]..185[26]..191[6]..194[1]..195()
line 1:     if !exists("s:Creator._NextBufNum")
line 2:[9Clet s:Creator._NextBufNum = 1
line 3:     else
line 4:[9Clet s:Creator._NextBufNum += 1
line 5:     endif
line 6:
line 7:     return s:Creator._NextBufNum
function 184[2]..185[26]..191[6]..194[1]..195 returning #1
continuing in function 184[2]..185[26]..191[6]..194
line 2:     return name
function 184[2]..185[26]..191[6]..194 returning 'NERD_tree_1'
continuing in function 184[2]..185[26]..191
line 7:[9Csilent! exec splitLocation . 'vertical ' . splitSize . ' new'
line 8:[9Csilent! exec "edit " . t:NERDTreeBufName
line 9:     else
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 10:[9Csilent! exec splitLocation . 'vertical ' . splitSize . ' split'
line 11:[9Csilent! exec "buffer " . t:NERDTreeBufName
line 12:     endif
line 13:
line 14:     setlocal winfixwidth
line 15:     call self._setCommonBufOptions()
calling function 184[2]..185[26]..191[15]..198()
line 1:     "throwaway buffer options
line 2:     setlocal noswapfile
line 3:     setlocal buftype=nofile
line 4:     setlocal bufhidden=hide
line 5:     setlocal nowrap
line 6:     setlocal foldcolumn=0
line 7:     setlocal foldmethod=manual
line 8:     setlocal nofoldenable
line 9:     setlocal nobuflisted
line 10:     setlocal nospell
line 11:     if g:NERDTreeShowLineNumbers
line 12:[9Csetlocal nu
line 13:     else
line 14:[9Csetlocal nonu
line 15:[9Cif v:version >= 703
line 16:[13Csetlocal nornu
line 17:[9Cendif
line 18:     endif
line 19:
line 20:     iabc <buffer>
line 21:
line 22:     if g:NERDTreeHighlightCursorline
line 23:[9Csetlocal cursorline
line 24:     endif
line 25:
line 26:     call self._setupStatusline()
calling function 184[2]..185[26]..191[15]..198[26]..199()
line 1:     if g:NERDTreeStatusline != -1
line 2:[9Clet &l:statusline = g:NERDTreeStatusline
line 3:     endif
function 184[2]..185[26]..191[15]..198[26]..199 returning #0
continuing in function 184[2]..185[26]..191[15]..198
line 27:     call self._bindMappings()
calling function 184[2]..185[26]..191[15]..198[27]..181()
line 1:     "make <cr> do the same as the activate node mapping
line 2:     nnoremap <silent> <buffer> <cr> :call nerdtree#ui_glue#invokeKeyMap(g:NERDTreeMapActivateNode)<cr>
line 3:
line 4:     call g:NERDTreeKeyMap.BindAll()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72()
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 1:     for i in s:KeyMap.All()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[1]..70()
line 1:     if !exists("s:keyMaps")
line 2:[9Clet s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[1]..70 returning [{'All': function('70'), 'BindAll': fu...'<SNR>36_jumpToPrevHunk',
[46;140H'[47;1Hkey': '[c'}]
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> <MiddleMouse> :call nerdtree#ui_glue#invokeKeyMap("<lt>MiddleMouse>")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> <LeftRelease> <LeftRelease>:call nerdtree#ui_glue#invokeKeyMap("<lt>LeftRelease>")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> <2-LeftMouse> :call nerdtree#ui_glue#invokeKeyMap("<lt>2-LeftMouse>")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 15: nnoremap <buffer> <silent> <2-LeftMouse> :call nerdtree#ui_glue#invokeKeyMap("<lt>2-LeftMouse>")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> <2-LeftMouse> :call nerdtree#ui_glue#invokeKeyMap("<lt>2-LeftMouse>")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> <2-LeftMouse> :call nerdtree#ui_glue#invokeKeyMap("<lt>2-LeftMouse>")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hcontinuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> o :call nerdtree#ui_glue#invokeKeyMap("o")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> o :call nerdtree#ui_glue#invokeKeyMap("o")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> o :call nerdtree#ui_glue#invokeKeyMap("o")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> o :call nerdtree#ui_glue#invokeKeyMap("o")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hcalling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> i :call nerdtree#ui_glue#invokeKeyMap("i")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> s :call nerdtree#ui_glue#invokeKeyMap("s")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> i :call nerdtree#ui_glue#invokeKeyMap("i")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> s :call nerdtree#ui_glue#invokeKeyMap("s")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> go :call nerdtree#ui_glue#invokeKeyMap("go")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> gs :call nerdtree#ui_glue#invokeKeyMap("gs")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> gi :call nerdtree#ui_glue#invokeKeyMap("gi")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> go :call nerdtree#ui_glue#invokeKeyMap("go")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> gs :call nerdtree#ui_glue#invokeKeyMap("gs")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> gi :call nerdtree#ui_glue#invokeKeyMap("gi")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> O :call nerdtree#ui_glue#invokeKeyMap("O")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> u :call nerdtree#ui_glue#invokeKeyMap("u")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> U :call nerdtree#ui_glue#invokeKeyMap("U")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> C :call nerdtree#ui_glue#invokeKeyMap("C")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> cd :call nerdtree#ui_glue#invokeKeyMap("cd")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> q :call nerdtree#ui_glue#invokeKeyMap("q")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 15: nnoremap <buffer> <silent> CD :call nerdtree#ui_glue#invokeKeyMap("CD")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> R :call nerdtree#ui_glue#invokeKeyMap("R")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> r :call nerdtree#ui_glue#invokeKeyMap("r")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hcontinuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> ? :call nerdtree#ui_glue#invokeKeyMap("?")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> A :call nerdtree#ui_glue#invokeKeyMap("A")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> I :call nerdtree#ui_glue#invokeKeyMap("I")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> f :call nerdtree#ui_glue#invokeKeyMap("f")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hcalling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> F :call nerdtree#ui_glue#invokeKeyMap("F")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> B :call nerdtree#ui_glue#invokeKeyMap("B")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> x :call nerdtree#ui_glue#invokeKeyMap("x")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> X :call nerdtree#ui_glue#invokeKeyMap("X")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> m :call nerdtree#ui_glue#invokeKeyMap("m")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> p :call nerdtree#ui_glue#invokeKeyMap("p")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> K :call nerdtree#ui_glue#invokeKeyMap("K")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> J :call nerdtree#ui_glue#invokeKeyMap("J")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> P :call nerdtree#ui_glue#invokeKeyMap("P")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> <C-j> :call nerdtree#ui_glue#invokeKeyMap("<lt>C-j>")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> <C-k> :call nerdtree#ui_glue#invokeKeyMap("<lt>C-k>")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> t :call nerdtree#ui_glue#invokeKeyMap("t")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> T :call nerdtree#ui_glue#invokeKeyMap("T")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> t :call nerdtree#ui_glue#invokeKeyMap("t")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> T :call nerdtree#ui_glue#invokeKeyMap("T")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> e :call nerdtree#ui_glue#invokeKeyMap("e")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hline 15: nnoremap <buffer> <silent> D :call nerdtree#ui_glue#invokeKeyMap("D")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> ]c :call nerdtree#ui_glue#invokeKeyMap("]c")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
calling function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73()
line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:[9Clet keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:[9Clet keymapInvokeString = self.key
line 11:     endif
line 12:
line 13:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 14:
line 15:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 15: nnoremap <buffer> <silent> [c :call nerdtree#ui_glue#invokeKeyMap("[c")<cr>
function 184[2]..185[26]..191[15]..198[27]..181[4]..72[2]..73 returning #0
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[?25l[47;1Hcontinuing in function 184[2]..185[26]..191[15]..198[27]..181[4]..72
line 3:     endfor
line 1:     for i in s:KeyMap.All()
line 2:[9Ccall i.bind()
line 3:     endfor
function 184[2]..185[26]..191[15]..198[27]..181[4]..72 returning #0
continuing in function 184[2]..185[26]..191[15]..198[27]..181
line 5:
line 6:     command! -buffer -nargs=? Bookmark :call nerdtree#ui_glue#bookmarkNode('<args>')
line 7:     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 RevealBookmark :call nerdtree#ui_glue#revealBookmark(
[46;140H'[47;1H<args>')
line 8:     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 OpenBookmark call nerdtree#ui_glue#openBookmark('<arg
[46;140Hs[47;1H>')
line 9:     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=* ClearBookmarks call nerdtree#ui_glue#clearBookmarks('
[46;140H<[47;1Hargs>')
line 10:     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=+ BookmarkToRoot call g:NERDTreeBookmark.ToRoot('<args
[46;140H>[47;1H', b:NERDTree)
line 11:     command! -buffer -nargs=0 ClearAllBookmarks call g:NERDTreeBookmark.ClearAll() <bar> call b:NERDTree.render()
line 12:     command! -buffer -nargs=0 ReadBookmarks call g:NERDTreeBookmark.CacheBookmarks(0) <bar> call b:NERDTree.render()
line 13:     command! -buffer -nargs=0 WriteBookmarks call g:NERDTreeBookmark.Write()
function 184[2]..185[26]..191[15]..198[27]..181 returning #0
continuing in function 184[2]..185[26]..191[15]..198
line 28:     setlocal filetype=nerdtree
Executing FileType Auto commands for "*"
[38;2;102;217;239mPress ENTER or type command to continue[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m
[?25lautocommand call s:LoadFTPlugin()
[38;2;102;217;239mPress ENTER or type command to continue[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m
[?25lline 0: call s:LoadFTPlugin()
calling function <SNR>8_LoadFTPlugin()
line 1:     if exists("b:undo_ftplugin")
line 2:[7Cexe b:undo_ftplugin
line 3:[7Cunlet! b:undo_ftplugin b:did_ftplugin
line 4:     endif
line 5:
line 6:     let s = expand("<amatch>")
line 7:     if s != ""
line 8:[7Cif &cpo =~# "S" && exists("b:did_ftplugin")
line 9: [38;2;70;84;87m^I[m[38;2;248;248;242m[48;2;0;0;0m" In compatible mode options are reset to the global values, need to
line 10: [38;2;70;84;87m^I[m[38;2;248;248;242m[48;2;0;0;0m" set the local values also when a plugin was already used.
line 11: [38;2;70;84;87m^I[m[38;2;248;248;242m[48;2;0;0;0munlet b:did_ftplugin
line 12:[7Cendif
line 13:
line 14:[7C" When there is a dot it is used to separate filetype names.  Thus for
line 15:[7C" "aaa.bbb" load "aaa" and then "bbb".
line 16:[7Cfor name in split(s, '\.')
line 17: [38;2;70;84;87m^I[m[38;2;248;248;242m[48;2;0;0;0mexe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
line 17: runtime! ftplugin/nerdtree.vim ftplugin/nerdtree_*.vim ftplugin/nerdtree/*.vim
Searching for "ftplugin/nerdtree.vim ftplugin/nerdtree_*.vim ftplugin/nerdtree/*.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vund
[46;140Hl[47;1He.vim,/home/patrick/.vim/bundle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/b
[46;140Hu[47;1Hndle/nerdtree-git-plugin,/home/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home
[46;140H/[47;1Hpatrick/.vim/bundle/tabular,/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/
[46;140Hs[47;1Hhare/vim/vim80/pack/dist/opt/matchit,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bu
[46;140Hn[47;1Hdle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-da
[46;140Hr[47;1Hk/after,/home/patrick/.vim/bundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommente
[46;140Hr[47;1H/after,/home/patrick/.vim/bundle/vim-fugitiv
[38;2;102;217;239mPress ENTER or type command to continue[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m
[?25lSearching for "/home/patrick/.vim/ftplugin/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m
[?25lSearching for "/home/patrick/.vim/ftplugin/nerdtree_*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m
[?25lSearching for "/home/patrick/.vim/ftplugin/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m
[?25lSearching for "/home/patrick/.vim/bundle/Vundle.vim/ftplugin/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m
[?25lSearching for "/home/patrick/.vim/bundle/Vundle.vim/ftplugin/nerdtree_*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m
[?25lSearching for "/home/patrick/.vim/bundle/Vundle.vim/ftplugin/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m
[?25lSearching for "/home/patrick/.vim/bundle/vim-sensible/ftplugin/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m
[?25lSearching for "/home/patrick/.vim/bundle/vim-sensible/ftplugin/nerdtree_*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m
[?25lSearching for "/home/patrick/.vim/bundle/vim-sensible/ftplugin/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m
[?25lSearching for "/home/patrick/.vim/bundle/molokai-dark/ftplugin/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m
[?25lSearching for "/home/patrick/.vim/bundle/molokai-dark/ftplugin/nerdtree_*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m
[?25lSearching for "/home/patrick/.vim/bundle/molokai-dark/ftplugin/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m
[?25lSearching for "/home/patrick/.vim/bundle/nerdtree/ftplugin/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m
[?25lSearching for "/home/patrick/.vim/bundle/nerdtree/ftplugin/nerdtree_*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m
[?25lSearching for "/home/patrick/.vim/bundle/nerdtree/ftplugin/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/ftplugin/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/ftplugin/nerdtree_*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/ftplugin/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdcommenter/ftplugin/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdcommenter/ftplugin/nerdtree_*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdcommenter/ftplugin/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-fugitive/ftplugin/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-fugitive/ftplugin/nerdtree_*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-fugitive/ftplugin/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/ale/ftplugin/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/ale/ftplugin/nerdtree_*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/ale/ftplugin/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/tabular/ftplugin/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/tabular/ftplugin/nerdtree_*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/tabular/ftplugin/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-table-mode/ftplugin/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-table-mode/ftplugin/nerdtree_*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-table-mode/ftplugin/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/var/lib/vim/addons/ftplugin/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/var/lib/vim/addons/ftplugin/nerdtree_*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/var/lib/vim/addons/ftplugin/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/usr/share/vim/vimfiles/ftplugin/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/usr/share/vim/vimfiles/ftplugin/nerdtree_*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/usr/share/vim/vimfiles/ftplugin/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/usr/share/vim/vim80/ftplugin/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/usr/share/vim/vim80/ftplugin/nerdtree_*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/usr/share/vim/vim80/ftplugin/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/usr/share/vim/vim80/pack/dist/opt/matchit/ftplugin/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/usr/share/vim/vim80/pack/dist/opt/matchit/ftplugin/nerdtree_*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/usr/share/vim/vim80/pack/dist/opt/matchit/ftplugin/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/usr/share/vim/vimfiles/after/ftplugin/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/usr/share/vim/vimfiles/after/ftplugin/nerdtree_*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/usr/share/vim/vimfiles/after/ftplugin/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/var/lib/vim/addons/after/ftplugin/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/var/lib/vim/addons/after/ftplugin/nerdtree_*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/var/lib/vim/addons/after/ftplugin/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/after/ftplugin/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/after/ftplugin/nerdtree_*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/after/ftplugin/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/Vundle.vim/ftplugin/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/Vundle.vim/ftplugin/nerdtree_*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/Vundle.vim/ftplugin/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/Vundle.vim/after/ftplugin/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/Vundle.vim/after/ftplugin/nerdtree_*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/Vundle.vim/after/ftplugin/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-sensible/after/ftplugin/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-sensible/after/ftplugin/nerdtree_*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-sensible/after/ftplugin/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/molokai-dark/after/ftplugin/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/molokai-dark/after/ftplugin/nerdtree_*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/molokai-dark/after/ftplugin/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdtree/after/ftplugin/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdtree/after/ftplugin/nerdtree_*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdtree/after/ftplugin/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/after/ftplugin/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/after/ftplugin/nerdtree_*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/after/ftplugin/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdcommenter/after/ftplugin/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdcommenter/after/ftplugin/nerdtree_*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdcommenter/after/ftplugin/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-fugitive/after/ftplugin/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-fugitive/after/ftplugin/nerdtree_*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-fugitive/after/ftplugin/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/ale/after/ftplugin/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/ale/after/ftplugin/nerdtree_*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/ale/after/ftplugin/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/tabular/after/ftplugin/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/tabular/after/ftplugin/nerdtree_*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/tabular/after/ftplugin/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-table-mode/after/ftplugin/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-table-mode/after/ftplugin/nerdtree_*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-table-mode/after/ftplugin/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/ale/after/ftplugin/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/ale/after/ftplugin/nerdtree_*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/ale/after/ftplugin/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
not found in 'runtimepath': "ftplugin/nerdtree.vim ftplugin/nerdtree_*.vim ftplugin/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
line 18:[7Cendfor
line 16:[7Cfor name in split(s, '\.')
line 17: [38;2;70;84;87m^I[m[38;2;248;248;242m[48;2;0;0;0mexe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
line 18:[7Cendfor
line 19:     endif
function <SNR>8_LoadFTPlugin returning #0
continuing in FileType Auto commands for "*"
Executing FileType Auto commands for "*"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
autocommand call s:LoadIndent()
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
line 0: call s:LoadIndent()
calling function <SNR>9_LoadIndent()
line 1:     if exists("b:undo_indent")
line 2:[7Cexe b:undo_indent
line 3:[7Cunlet! b:undo_indent b:did_indent
line 4:     endif
line 5:     let s = expand("<amatch>")
line 6:     if s != ""
line 7:[7Cif exists("b:did_indent")
line 8: [38;2;70;84;87m^I[m[38;2;248;248;242m[48;2;0;0;0munlet b:did_indent
line 9:[7Cendif
line 10:
line 11:[7C" When there is a dot it is used to separate filetype names.  Thus for
line 12:[7C" "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
line 13:[7Cfor name in split(s, '\.')
line 14: [38;2;70;84;87m^I[m[38;2;248;248;242m[48;2;0;0;0mexe 'runtime! indent/' . name . '.vim'
line 14: runtime! indent/nerdtree.vim
Searching for "indent/nerdtree.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,/hom
[46;140He[47;1H/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/bundl
[46;140He[47;1H/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vim/bu
[46;140Hn[47;1Hdle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vim80/pack/dist/opt/matchit,/usr/share/v
[46;140Hi[47;1Hm/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vundle.v
[46;140Hi[47;1Hm/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/after,
[46;140H/[47;1Hhome/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive/aft
[46;140He[47;1Hr,/home/patrick/.vim/bundle/ale/after,/home/
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/indent/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/Vundle.vim/indent/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-sensible/indent/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/molokai-dark/indent/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdtree/indent/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/indent/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdcommenter/indent/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-fugitive/indent/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/ale/indent/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/tabular/indent/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-table-mode/indent/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/var/lib/vim/addons/indent/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/usr/share/vim/vimfiles/indent/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/usr/share/vim/vim80/indent/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/usr/share/vim/vim80/pack/dist/opt/matchit/indent/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/usr/share/vim/vimfiles/after/indent/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/var/lib/vim/addons/after/indent/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/after/indent/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/Vundle.vim/indent/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/Vundle.vim/after/indent/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-sensible/after/indent/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/molokai-dark/after/indent/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdtree/after/indent/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/after/indent/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdcommenter/after/indent/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-fugitive/after/indent/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/ale/after/indent/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/tabular/after/indent/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-table-mode/after/indent/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/ale/after/indent/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
not found in 'runtimepath': "indent/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
line 15:[7Cendfor
line 13:[7Cfor name in split(s, '\.')
line 14: [38;2;70;84;87m^I[m[38;2;248;248;242m[48;2;0;0;0mexe 'runtime! indent/' . name . '.vim'
line 15:[7Cendfor
line 16:     endif
function <SNR>9_LoadIndent returning #0
continuing in FileType Auto commands for "*"
Executing FileType Auto commands for "*"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
autocommand exe "set syntax=" . expand("<amatch>")
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
line 0: exe "set syntax=" . expand("<amatch>")
line 0: set syntax=nerdtree
Executing Syntax Auto commands for "*"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
autocommand call s:SynSet()
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
line 0: call s:SynSet()
calling function <SNR>11_SynSet()
line 1:   " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
line 2:   syn clear
line 3:   if exists("b:current_syntax")
line 4:     unlet b:current_syntax
line 5:   endif
line 6:
line 7:   let s = expand("<amatch>")
line 8:   if s == "ON"
line 9:     " :set syntax=ON
line 10:     if &filetype == ""
line 11:[7Cechohl ErrorMsg
line 12:[7Cecho "filetype unknown"
line 13:[7Cechohl None
line 14:     endif
line 15:     let s = &filetype
line 16:   elseif s == "OFF"
line 17:     let s = ""
line 18:   endif
line 19:
line 20:   if s != ""
line 21:     " Load the syntax file(s).  When there are several, separated by dots,
line 22:     " load each in sequence.
line 23:     for name in split(s, '\.')
line 24:[7Cexe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
line 24: runtime! syntax/nerdtree.vim syntax/nerdtree/*.vim
Searching for "syntax/nerdtree.vim syntax/nerdtree/*.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bu
[46;140Hn[47;1Hdle/vim-sensible,/home/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/h
[46;140Ho[47;1Hme/patrick/.vim/bundle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular
[46;140H,[47;1H/home/patrick/.vim/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vim80/pack/dist/op
[46;140Ht[47;1H/matchit,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patric
[46;140Hk[47;1H/.vim/bundle/Vundle.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/
[46;140Hb[47;1Hundle/nerdtree/after,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/b
[46;140Hu[47;1Hndle/vim-fugitive/after,/home/patrick/.vim/b
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/syntax/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/syntax/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/Vundle.vim/syntax/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/Vundle.vim/syntax/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-sensible/syntax/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-sensible/syntax/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/molokai-dark/syntax/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/molokai-dark/syntax/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdtree/syntax/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
chdir(/home/patrick/.vim/bundle/nerdtree/syntax)
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
fchdir() to previous dir
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
line 24: sourcing "/home/patrick/.vim/bundle/nerdtree/syntax/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
line 1: let s:tree_up_dir_line = '.. (up a dir)'
line 2: syn match NERDTreeIgnore #\~#
line 3: exec 'syn match NERDTreeIgnore #\['.g:NERDTreeGlyphReadOnly.'\]#'
line 3: syn match NERDTreeIgnore #\[RO\]#
line 4:
line 5: "highlighting for the .. (up dir) line at the top of the tree
line 6: execute "syn match NERDTreeUp #\\V". s:tree_up_dir_line ."#"
line 6: syn match NERDTreeUp #\V.. (up a dir)#
line 7:
line 8: "quickhelp syntax elements
line 9: syn match NERDTreeHelpKey #" \{1,2\}[^ ]*:#ms=s+2,me=e-1
line 10: syn match NERDTreeHelpKey #" \{1,2\}[^ ]*,#ms=s+2,me=e-1
line 11: syn match NERDTreeHelpTitle #" .*\~$#ms=s+2,me=e-1
line 12: syn match NERDTreeToggleOn #(on)#ms=s+1,he=e-1
line 13: syn match NERDTreeToggleOff #(off)#ms=e-3,me=e-1
line 14: syn match NERDTreeHelpCommand #" :.\{-}\>#hs=s+3
line 15: syn match NERDTreeHelp  #^".*# contains=NERDTreeHelpKey,NERDTreeHelpTitle,NERDTreeIgnore,NERDTreeToggleOff,NERDTreeToggleOn,NERDTr
[46;140He[47;1HeHelpCommand
line 16:
line 17: "highlighting for sym links
line 18: syn match NERDTreeLinkTarget #->.*# containedin=NERDTreeDir,NERDTreeFile
line 19: syn match NERDTreeLinkFile #.* ->#me=e-3 containedin=NERDTreeFile
line 20: syn match NERDTreeLinkDir #.*/ ->#me=e-3 containedin=NERDTreeDir
line 21:
line 22: "highlighing for directory nodes and file nodes
line 23: syn match NERDTreeDirSlash #/# containedin=NERDTreeDir
line 24:
line 25: exec 'syn match NERDTreeClosable #' . escape(g:NERDTreeDirArrowCollapsible, '~') . '\ze .*/# containedin=NERDTreeDir,NERDTreeFile'
line 25: syn match NERDTreeClosable #▾\ze .*/# containedin=NERDTreeDir,NERDTreeFile
line 26: exec 'syn match NERDTreeOpenable #' . escape(g:NERDTreeDirArrowExpandable, '~') . '\ze .*/# containedin=NERDTreeDir,NERDTreeFile'
line 26: syn match NERDTreeOpenable #▸\ze .*/# containedin=NERDTreeDir,NERDTreeFile
line 27:
line 28: let s:dirArrows = escape(g:NERDTreeDirArrowCollapsible, '~]\-').escape(g:NERDTreeDirArrowExpandable, '~]\-')
line 29: exec 'syn match NERDTreeDir #[^'.s:dirArrows.' ].*/#'
line 29: syn match NERDTreeDir #[^▾▸ ].*/#
line 30: syn match NERDTreeExecFile  #^ .*\*\($\| \)# contains=NERDTreeRO,NERDTreeBookmark
line 31: exec 'syn match NERDTreeFile  #^[^"\.'.s:dirArrows.'] *[^'.s:dirArrows.']*# contains=NERDTreeLink,NERDTreeRO,NERDTreeBookmark,NERD
[46;140HT[47;1HreeExecFile'
line 31: syn match NERDTreeFile  #^[^"\.▾▸] *[^▾▸]*# contains=NERDTreeLink,NERDTreeRO,NERDTreeBookmark,NERDTreeExecFile
line 32:
line 33: "highlighting for readonly files
line 34: exec 'syn match NERDTreeRO # *\zs.*\ze \['.g:NERDTreeGlyphReadOnly.'\]# contains=NERDTreeIgnore,NERDTreeBookmark,NERDTreeFile'
line 34: syn match NERDTreeRO # *\zs.*\ze \[RO\]# contains=NERDTreeIgnore,NERDTreeBookmark,NERDTreeFile
line 35:
line 36: syn match NERDTreeFlags #^ *\zs\[.\]# containedin=NERDTreeFile,NERDTreeExecFile
line 37: syn match NERDTreeFlags #\[.\]# containedin=NERDTreeDir
[38;2;230;219;116m-- More --[?12l[?25h SPACE/d/j: screen/page/line down, b/u/k: up, q: quit [m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[47;1H
[?25l[1m[38;2;249;38;114m[48;2;35;37;38mError detected while processing /home/patrick/.vim/bundle/nerdtree/syntax/nerdtree.vim:[m[38;2;248;248;242m[48;2;0;0;0m
[38;2;70;84;87m[48;2;35;37;38mline   37:[m[38;2;248;248;242m[48;2;0;0;0m
[1m[38;2;249;38;114m[48;2;35;37;38mInterrupted[m[38;2;248;248;242m[48;2;0;0;0m
finished sourcing /home/patrick/.vim/bundle/nerdtree/syntax/nerdtree.vim
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
continuing in function <SNR>11_SynSet
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdtree/syntax/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/syntax/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/syntax/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdcommenter/syntax/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdcommenter/syntax/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-fugitive/syntax/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-fugitive/syntax/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/ale/syntax/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/ale/syntax/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/tabular/syntax/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/tabular/syntax/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-table-mode/syntax/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-table-mode/syntax/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/var/lib/vim/addons/syntax/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/var/lib/vim/addons/syntax/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/usr/share/vim/vimfiles/syntax/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/usr/share/vim/vimfiles/syntax/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/usr/share/vim/vim80/syntax/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/usr/share/vim/vim80/syntax/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/usr/share/vim/vim80/pack/dist/opt/matchit/syntax/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/usr/share/vim/vim80/pack/dist/opt/matchit/syntax/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/usr/share/vim/vimfiles/after/syntax/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/usr/share/vim/vimfiles/after/syntax/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/var/lib/vim/addons/after/syntax/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/var/lib/vim/addons/after/syntax/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/after/syntax/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/after/syntax/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/Vundle.vim/syntax/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/Vundle.vim/syntax/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/Vundle.vim/after/syntax/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/Vundle.vim/after/syntax/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-sensible/after/syntax/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-sensible/after/syntax/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/molokai-dark/after/syntax/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/molokai-dark/after/syntax/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdtree/after/syntax/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdtree/after/syntax/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/after/syntax/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/after/syntax/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdcommenter/after/syntax/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdcommenter/after/syntax/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-fugitive/after/syntax/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-fugitive/after/syntax/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/ale/after/syntax/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/ale/after/syntax/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/tabular/after/syntax/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/tabular/after/syntax/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-table-mode/after/syntax/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-table-mode/after/syntax/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/ale/after/syntax/nerdtree.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/ale/after/syntax/nerdtree/*.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
line 25:     endfor
line 23:     for name in split(s, '\.')
line 24:[7Cexe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
line 25:     endfor
line 26:   endif
function <SNR>11_SynSet returning #0
continuing in Syntax Auto commands for "*"
Executing FileType Auto commands for "nerdtree"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
autocommand call s:AddHighlighting()
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
line 0: call s:AddHighlighting()
calling function <SNR>36_AddHighlighting()
line 1:     let l:synmap = { 'NERDTreeGitStatusModified'    : s:NERDTreeGetIndicator('Modified'), 'NERDTreeGitStatusStaged'      : s:NERDTr
[46;140He[47;1HeGetIndicator('Staged'), 'NERDTreeGitStatusUntracked'   : s:NERDTreeGetIndicator('Untracked'), 'NERDTreeGitStatusRenamed'     : s:NERDTreeG
[46;140He[47;1HtIndicator('Renamed'), 'NERDTreeGitStatusIgnored'     : s:NERDTreeGetIndicator('Ignored'), 'NERDTreeGitStatusDirDirty'    : s:NERDTreeGetIn
[46;140Hd[47;1Hicator('Dirty'), 'NERDTreeGitStatusDirClean'    : s:NERDTreeGetIndicator('Clean') }
calling function <SNR>36_AddHighlighting[1]..<SNR>36_NERDTreeGetIndicator('Modified')
line 1:     if exists('g:NERDTreeIndicatorMapCustom')
line 2:[9Clet l:indicator = get(g:NERDTreeIndicatorMapCustom, a:statusKey, '')
line 3:[9Cif l:indicator !=# ''
line 4:[13Creturn l:indicator
line 5:[9Cendif
line 6:     endif
line 7:     let l:indicator = get(s:NERDTreeIndicatorMap, a:statusKey, '')
line 8:     if l:indicator !=# ''
line 9:[9Creturn l:indicator
function <SNR>36_AddHighlighting[1]..<SNR>36_NERDTreeGetIndicator returning '✹'
continuing in function <SNR>36_AddHighlighting
calling function <SNR>36_AddHighlighting[1]..<SNR>36_NERDTreeGetIndicator('Staged')
line 1:     if exists('g:NERDTreeIndicatorMapCustom')
line 2:[9Clet l:indicator = get(g:NERDTreeIndicatorMapCustom, a:statusKey, '')
line 3:[9Cif l:indicator !=# ''
line 4:[13Creturn l:indicator
line 5:[9Cendif
line 6:     endif
line 7:     let l:indicator = get(s:NERDTreeIndicatorMap, a:statusKey, '')
line 8:     if l:indicator !=# ''
line 9:[9Creturn l:indicator
function <SNR>36_AddHighlighting[1]..<SNR>36_NERDTreeGetIndicator returning '✚'
continuing in function <SNR>36_AddHighlighting
calling function <SNR>36_AddHighlighting[1]..<SNR>36_NERDTreeGetIndicator('Untracked')
line 1:     if exists('g:NERDTreeIndicatorMapCustom')
line 2:[9Clet l:indicator = get(g:NERDTreeIndicatorMapCustom, a:statusKey, '')
line 3:[9Cif l:indicator !=# ''
line 4:[13Creturn l:indicator
line 5:[9Cendif
line 6:     endif
line 7:     let l:indicator = get(s:NERDTreeIndicatorMap, a:statusKey, '')
line 8:     if l:indicator !=# ''
line 9:[9Creturn l:indicator
function <SNR>36_AddHighlighting[1]..<SNR>36_NERDTreeGetIndicator returning '✭'
continuing in function <SNR>36_AddHighlighting
calling function <SNR>36_AddHighlighting[1]..<SNR>36_NERDTreeGetIndicator('Renamed')
line 1:     if exists('g:NERDTreeIndicatorMapCustom')
line 2:[9Clet l:indicator = get(g:NERDTreeIndicatorMapCustom, a:statusKey, '')
line 3:[9Cif l:indicator !=# ''
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[47;1H
[?25lfunction <SNR>36_AddHighlighting[1]..<SNR>36_NERDTreeGetIndicator aborted
continuing in function <SNR>36_AddHighlighting
function <SNR>36_AddHighlighting aborted
continuing in FileType Auto commands for "nerdtree"
function 184[2]..185[26]..191[15]..198 aborted
continuing in function 184[2]..185[26]..191
function 184[2]..185[26]..191 aborted
continuing in function 184[2]..185
function 184[2]..185 aborted
continuing in function 184
function 184 aborted
continuing in VimEnter Auto commands for "*"
:c[?12l[?25hq[?25l[?12l[?25h[?25l[47;3H[K[47;3H[?12l[?25h[?25l[47;2H[K[47;2H[?12l[?25h [?25lExecuting CursorMoved Auto commands for "*"
[38;2;102;217;239mPress ENTER or type command to continue[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m
[?25lautocommand call ale#cursor#EchoCursorWarningWithDelay()
[38;2;102;217;239mPress ENTER or type command to continue[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m
[?25lline 0: call ale#cursor#EchoCursorWarningWithDelay()
Searching for "autoload/ale/cursor.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,
[46;140H/[47;1Hhome/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/b
[46;140Hu[47;1Hndle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vi
[46;140Hm[47;1H/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vim80/pack/dist/opt/matchit,/usr/sha
[46;140Hr[47;1He/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vund
[46;140Hl[47;1He.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/af
[46;140Ht[47;1Her,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive
[46;140H/[47;1Hafter,/home/patrick/.vim/bundle/ale/after,/h
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/autoload/ale/cursor.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/Vundle.vim/autoload/ale/cursor.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-sensible/autoload/ale/cursor.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/molokai-dark/autoload/ale/cursor.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdtree/autoload/ale/cursor.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/autoload/ale/cursor.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/nerdcommenter/autoload/ale/cursor.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/vim-fugitive/autoload/ale/cursor.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
Searching for "/home/patrick/.vim/bundle/ale/autoload/ale/cursor.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
chdir(/home/patrick/.vim/bundle/ale/autoload/ale)
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
fchdir() to previous dir
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
line 0: sourcing "/home/patrick/.vim/bundle/ale/autoload/ale/cursor.vim"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
line 1: " Author: w0rp <devw0rp@gmail.com>
line 2: " Description: Echoes lint message for the current line, if any
line 3:
line 4: let s:cursor_timer = -1
line 5: let s:last_pos = [0, 0, 0]
line 6: let s:error_delay_ms = 1000 * 60 * 2
line 7:
line 8: if !exists('s:dont_queue_until')
line 9:     let s:dont_queue_until = -1
line 10: endif
line 11:
line 12: if !exists('s:dont_echo_until')
line 13:     let s:dont_echo_until = -1
line 14: endif
line 15:
line 16: " Return a formatted message according to g:ale_echo_msg_format variable
line 17: function! s:GetMessage(linter, type, text) abort
line 30:
line 31: function! s:EchoWithShortMess(setting, message) abort
line 53:
line 54: function! ale#cursor#TruncatedEcho(message) abort
line 63:
line 64: function! s:FindItemAtCursor() abort
line 74:
line 75: function! s:StopCursorTimer() abort
line 81:
line 82: function! ale#cursor#EchoCursorWarning(...) abort
line 85:
line 86: function! s:EchoImpl() abort
line 109:
line 110: function! ale#cursor#EchoCursorWarningWithDelay() abort
line 117:
line 118: function! s:EchoWithDelayImpl() abort
line 136:
line 137: function! ale#cursor#ShowCursorDetail() abort
finished sourcing /home/patrick/.vim/bundle/ale/autoload/ale/cursor.vim
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
continuing in CursorMoved Auto commands for "*"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
calling function ale#cursor#EchoCursorWarningWithDelay()
line 1:     return ale#CallWithCooldown(   'dont_echo_with_delay_until',   function('s:EchoWithDelayImpl'),   [],)
calling function ale#cursor#EchoCursorWarningWithDelay[1]..ale#CallWithCooldown('dont_echo_with_delay_until', function('<SNR>62_EchoWithDel
[46;140Ha[47;1HyImpl'), [])
line 1:     let l:now = ale#util#ClockMilliseconds()
calling function ale#cursor#EchoCursorWarningWithDelay[1]..ale#CallWithCooldown[1]..ale#util#ClockMilliseconds()
line 1:     return float2nr(reltimefloat(reltime()) * 1000)
function ale#cursor#EchoCursorWarningWithDelay[1]..ale#CallWithCooldown[1]..ale#util#ClockMilliseconds returning #1505404196586
continuing in function ale#cursor#EchoCursorWarningWithDelay[1]..ale#CallWithCooldown
line 2:
line 3:     if l:now < get(s:timestamp_map, a:timestamp_key, -1)
line 4:[9Creturn 0
line 5:     endif
line 6:
line 7:     let s:timestamp_map[a:timestamp_key] = l:now + s:error_delay_ms
line 8:
line 9:     let l:return_value = call(a:func, a:arglist)
calling function ale#cursor#EchoCursorWarningWithDelay[1]..ale#CallWithCooldown[9]..<SNR>62_EchoWithDelayImpl()
line 1:     if ale#ShouldDoNothing(bufnr(''))
calling function ale#cursor#EchoCursorWarningWithDelay[1]..ale#CallWithCooldown[9]..<SNR>62_EchoWithDelayImpl[1]..ale#ShouldDoNothing(2)
line 1:     " Do nothing for blacklisted files
line 2:     " OR if ALE is running in the sandbox
line 3:     return index(g:ale_filetype_blacklist, &filetype) >= 0   || (exists('*getcmdwintype') && !empty(getcmdwintype()))   || ale#util
[46;140H#[47;1HInSandbox()   || !ale#Var(a:buffer, 'enabled')   || ale#FileTooLarge()   || getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
function ale#cursor#EchoCursorWarningWithDelay[1]..ale#CallWithCooldown[9]..<SNR>62_EchoWithDelayImpl[1]..ale#ShouldDoNothing returning #1
continuing in function ale#cursor#EchoCursorWarningWithDelay[1]..ale#CallWithCooldown[9]..<SNR>62_EchoWithDelayImpl
line 2:[9Creturn
function ale#cursor#EchoCursorWarningWithDelay[1]..ale#CallWithCooldown[9]..<SNR>62_EchoWithDelayImpl returning #0
continuing in function ale#cursor#EchoCursorWarningWithDelay[1]..ale#CallWithCooldown
line 10:
line 11:     let s:timestamp_map[a:timestamp_key] = -1
line 12:
line 13:     return l:return_value
function ale#cursor#EchoCursorWarningWithDelay[1]..ale#CallWithCooldown returning #0
continuing in function ale#cursor#EchoCursorWarningWithDelay
function ale#cursor#EchoCursorWarningWithDelay returning #0
continuing in CursorMoved Auto commands for "*"
Executing CursorMoved Auto commands for "*"
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
autocommand call s:Highlight_Matching_Pair()
[38;2;102;217;239mPress ENTER or type command to continue[m[38;2;248;248;242m[48;2;0;0;0m
line 0: call s:Highlight_Matching_Pair()
calling function <SNR>47_Highlight_Matching_Pair()
line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6:
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12:
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17:
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:[7Clet before = strlen(c_before)
line 31:[7Clet c = c_before
line 32:[7Clet i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:[7C" not found, nothing to do
line 36:[7Creturn
function <SNR>47_Highlight_Matching_Pair returning #0
continuing in CursorMoved Auto commands for "*"
[27m[23m[m[38;2;248;248;242m[48;2;0;0;0m[H[2J[1;1H[48;2;28;28;28m                               [m[38;2;248;248;242m[48;2;0;0;0m[1m[38;2;128;128;128m[48;2;8;8;8m|[2;32H|[3;32H|[4;32H|[5;32H|[6;32H|[7;32H|[8;32H|[9;32H|[10;32H|[11;32H|[12;32H|[13;32H|[14;32H|[15;32H|[16;32H|[17;32H|[18;32H|[19;32H|[20;32H|[21;32H|[22;32H|[23;32H|[24;32H|[25;32H|[26;32H|[27;32H|[28;32H|[29;32H|[30;32H|[31;32H|[32;32H|[33;32H|[34;32H|[35;32H|[36;32H|[37;32H|[38;32H|[39;32H|[40;32H|[41;32H|[42;32H|[43;32H|[44;32H|[45;32H|[m[38;2;248;248;242m[48;2;0;0;0m[2;1H[38;2;70;84;87m~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              
~                              [m[38;2;248;248;242m[48;2;0;0;0m
[1m[7m[38;2;69;83;84m[48;2;248;248;242m                                [m[38;2;248;248;242m[48;2;0;0;0m[1;33H[38;2;253;151;31m[48;2;28;28;28m1   [m[38;2;248;248;242m[48;2;0;0;0m[2;33H[38;2;70;84;87m~                                                                                                           [3;33H~                                                                                                           [4;33H~                                                                                                           [5;33H~                                                                                                           [6;33H~                                                                                                           [7;33H~                                                                                                           [8;33H~                                                                                                           [9;33H~                                                                                                           [10;33H~                                                                                                           [11;33H~                                                                                                           [12;33H~                                                                                                           [13;33H~                                                                                                           [14;33H~                                                                                                           [15;33H~                                                                                                           [16;33H~                                                                                                           [17;33H~                                                                                                           [18;33H~                                                                                                           [19;33H~                                                                                                           [20;33H~                                                                                                           [21;33H~                                                                                                           [22;33H~                                                                                                           [23;33H~                                                                                                           [24;33H~                                                                                                           [25;33H~                                                                                                           [26;33H~                                                                                                           [27;33H~                                                                                                           [28;33H~                                                                                                           [29;33H~                                                                                                           [30;33H~                                                                                                           [31;33H~                                                                                                           [32;33H~                                                                                                           [33;33H~                                                                                                           [34;33H~                                                                                                           [35;33H~                                                                                                           [36;33H~                                                                                                           [37;33H~                                                                                                           [38;33H~                                                                                                           [39;33H~                                                                                                           [40;33H~                                                                                                           [41;33H~                                                                                                           [42;33H~                                                                                                           [43;33H~                                                                                                           [44;33H~                                                                                                           [45;33H~                                                                                                           [m[38;2;248;248;242m[48;2;0;0;0m[46;33H[7m[38;2;128;128;128m[48;2;8;8;8m[No Name]                                                                                 0,0-1          All[1;1H[?12l[?25h[?25l[47;1H[m[38;2;248;248;242m[48;2;0;0;0m:[?12l[?25hq[?25l[?12l[?25h
[?25lExecuting BufLeave Auto commands for "*"
autocommand set norelativenumber
line 0: set norelativenumber
Executing BufLeave Auto commands for "NERD_tree_*"
autocommand if g:NERDTree.IsOpen() | call b:NERDTree.ui.saveScreenState() | endif
line 0: if g:NERDTree.IsOpen() | call b:NERDTree.ui.saveScreenState() | endif
calling function 222()
line 1:     return s:NERDTree.GetWinNum() != -1
calling function 222[1]..221()
line 1:     if exists("t:NERDTreeBufName")
line 2:[9Creturn bufwinnr(t:NERDTreeBufName)
function 222[1]..221 returning #1
continuing in function 222
function 222 returning #1
continuing in BufLeave Auto commands for "NERD_tree_*"
line 0:  call b:NERDTree.ui.saveScreenState() | endif
[1m[38;2;249;38;114m[48;2;35;37;38mError detected while processing BufLeave Auto commands for "NERD_tree_*":[m[38;2;248;248;242m[48;2;0;0;0m
[1m[38;2;249;38;114m[48;2;35;37;38mE121: Undefined variable: b:NERDTree[m[38;2;248;248;242m[48;2;0;0;0m
Executing BufLeave Auto commands for "*"
autocommand if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif
line 0: if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif
line 0: let w:netrw_prvfile= expand("%:p")|endif
line 0: endif
Executing BufWinLeave Auto commands for "*"
autocommand execute getwinvar(+bufwinnr(+expand('<abuf>')), 'fugitive_leave')
line 0: execute getwinvar(+bufwinnr(+expand('<abuf>')), 'fugitive_leave')
line 0:
Executing BufWinLeave Auto commands for "*"
autocommand if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 2 |   call s:diffoff_all(getbufvar(+expand('<abuf>'), 'git_dir'
[46;140H)[47;1H) | endif
line 0: if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 2 |   call s:diffoff_all(getbufvar(+expand('<abuf>'), 'git_dir')) |
endif
calling function <SNR>38_can_diffoff(2)
line 1:   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getbufvar(a:buf, 'git_dir')) && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_
[46;140Hd[47;1Hiff_restore'))
function <SNR>38_can_diffoff returning #0
continuing in BufWinLeave Auto commands for "*"
line 0:    call s:diffoff_all(getbufvar(+expand('<abuf>'), 'git_dir')) | endif
line 0:  endif
Executing WinEnter Auto commands for "*"
autocommand call s:Highlight_Matching_Pair()
line 0: call s:Highlight_Matching_Pair()
calling function <SNR>47_Highlight_Matching_Pair()
line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[47;1H
[?25lfunction <SNR>47_Highlight_Matching_Pair aborted
continuing in WinEnter Auto commands for "*"
:[?12l[?25hq[?25l[?12l[?25h[?25lExecuting BufWinLeave Auto commands for "*"
autocommand execute getwinvar(+bufwinnr(+expand('<abuf>')), 'fugitive_leave')
line 0: execute getwinvar(+bufwinnr(+expand('<abuf>')), 'fugitive_leave')
line 0:
Executing BufWinLeave Auto commands for "*"
autocommand if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 2 |   call s:diffoff_all(getbufvar(+expand('<abuf>'), 'git_dir'
[46;140H)[47;1H) | endif
line 0: if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 2 |   call s:diffoff_all(getbufvar(+expand('<abuf>'), 'git_dir')) |
endif
calling function <SNR>38_can_diffoff(1)
line 1:   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getbufvar(a:buf, 'git_dir')) && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_
[46;140Hd[47;1Hiff_restore'))
function <SNR>38_can_diffoff returning #0
continuing in BufWinLeave Auto commands for "*"
line 0:    call s:diffoff_all(getbufvar(+expand('<abuf>'), 'git_dir')) | endif
line 0:  endif
Executing BufUnload Auto commands for "*"
autocommand call ale#engine#Cleanup(str2nr(expand('<abuf>')))
line 0: call ale#engine#Cleanup(str2nr(expand('<abuf>')))
Searching for "autoload/ale/engine.vim" in "/home/patrick/.vim,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/vim-sensible,
[46;140H/[47;1Hhome/patrick/.vim/bundle/molokai-dark,/home/patrick/.vim/bundle/nerdtree,/home/patrick/.vim/bundle/nerdtree-git-plugin,/home/patrick/.vim/b
[46;140Hu[47;1Hndle/nerdcommenter,/home/patrick/.vim/bundle/vim-fugitive,/home/patrick/.vim/bundle/ale,/home/patrick/.vim/bundle/tabular,/home/patrick/.vi
[46;140Hm[47;1H/bundle/vim-table-mode,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim80,/usr/share/vim/vim80/pack/dist/opt/matchit,/usr/sha
[46;140Hr[47;1He/vim/vimfiles/after,/var/lib/vim/addons/after,/home/patrick/.vim/after,/home/patrick/.vim/bundle/Vundle.vim,/home/patrick/.vim/bundle/Vund
[46;140Hl[47;1He.vim/after,/home/patrick/.vim/bundle/vim-sensible/after,/home/patrick/.vim/bundle/molokai-dark/after,/home/patrick/.vim/bundle/nerdtree/af
[46;140Ht[47;1Her,/home/patrick/.vim/bundle/nerdtree-git-plugin/after,/home/patrick/.vim/bundle/nerdcommenter/after,/home/patrick/.vim/bundle/vim-fugitive
[46;140H/[47;1Hafter,/home/patrick/.vim/bundle/ale/after,/h
Searching for "/home/patrick/.vim/autoload/ale/engine.vim"
Searching for "/home/patrick/.vim/bundle/Vundle.vim/autoload/ale/engine.vim"
Searching for "/home/patrick/.vim/bundle/vim-sensible/autoload/ale/engine.vim"
Searching for "/home/patrick/.vim/bundle/molokai-dark/autoload/ale/engine.vim"
Searching for "/home/patrick/.vim/bundle/nerdtree/autoload/ale/engine.vim"
Searching for "/home/patrick/.vim/bundle/nerdtree-git-plugin/autoload/ale/engine.vim"
Searching for "/home/patrick/.vim/bundle/nerdcommenter/autoload/ale/engine.vim"
Searching for "/home/patrick/.vim/bundle/vim-fugitive/autoload/ale/engine.vim"
Searching for "/home/patrick/.vim/bundle/ale/autoload/ale/engine.vim"
chdir(/home/patrick/.vim/bundle/ale/autoload/ale)
fchdir() to previous dir
line 0: sourcing "/home/patrick/.vim/bundle/ale/autoload/ale/engine.vim"
line 1: " Author: w0rp <devw0rp@gmail.com>
line 2: " Description: Backend execution and job management
line 3: "   Executes linters in the background, using NeoVim or Vim 8 jobs
line 4:
line 5: " Stores information for each job including:
line 6: "
line 7: " linter: The linter dictionary for the job.
[38;2;230;219;116m-- More --[?12l[?25h[m[38;2;248;248;242m[48;2;0;0;0m[47;1H[K[47;1H
[?25l[1m[38;2;249;38;114m[48;2;35;37;38mError detected while processing /home/patrick/.vim/bundle/ale/autoload/ale/engine.vim:[m[38;2;248;248;242m[48;2;0;0;0m
[38;2;70;84;87m[48;2;35;37;38mline    7:[m[38;2;248;248;242m[48;2;0;0;0m
[1m[38;2;249;38;114m[48;2;35;37;38mInterrupted[m[38;2;248;248;242m[48;2;0;0;0m
finished sourcing /home/patrick/.vim/bundle/ale/autoload/ale/engine.vim
continuing in BufUnload Auto commands for "*"
Writing viminfo file "/home/patrick/.viminfo"[39;49m[?1l>[?12l[?25h[?1049l
